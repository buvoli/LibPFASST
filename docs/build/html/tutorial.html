
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Tutorial &#8212; LIBPFASST 1.1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="Parameters and variables" href="parameters.html" />
    <link rel="prev" title="Compiling" href="compiling.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="parameters.html" title="Parameters and variables"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="compiling.html" title="Compiling"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">LIBPFASST 1.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="example-1">
<h2>Example 1<a class="headerlink" href="#example-1" title="Permalink to this headline">¶</a></h2>
<p>The following material will walk the user through a couple of examples to demonstrate how to set up an application using
LibPFASST.</p>
<p>Once libpfasst has been successfully built, move to the directory  LibPFASST/Tutorials/EX1_Dahlquist
This example solves the  scalar model problem or Dahlquist equation</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}y'  = \lambda y\\y(0) = 1\end{aligned}\end{align} \]</div>
<p>An implicit-explicit or IMEX  (also known as semi-implicit) splitting is used in this example, so the equation can be written</p>
<div class="math notranslate nohighlight">
\[y'  = \lambda_1 y + \lambda_2 y\]</div>
<p>Typing</p>
<blockquote>
<div><p><cite>$ make</cite></p>
</div></blockquote>
<p>in the directory should compile the example creating an executable called <cite>main.exe</cite>.  In the same directory, there are a few parameter files with the extension <cite>.nml</cite>.  You can run the example using one of these files, as in</p>
<blockquote>
<div><p><cite>$ ./main.exe sdc.nml</cite></p>
</div></blockquote>
<p>Using your favorite editor, open the file sdc.nml.  There are two namelists here, <code class="docutils literal notranslate"><span class="pre">PF_PARAMS</span></code> and <code class="docutils literal notranslate"><span class="pre">PARAMS</span></code>.  The second of these is for local variables which in this simple example are just the values of <code class="docutils literal notranslate"><span class="pre">lam1</span></code> and <code class="docutils literal notranslate"><span class="pre">lam2</span></code>, the simulation time and the number of steps.  The <code class="docutils literal notranslate"><span class="pre">PF_PARAMS</span></code> variables are discussed below in the section <a class="reference external" href="parameters">Parameters</a>.
Any parameter in either list can be overwritten by adding it to the command line, as in</p>
<p><cite>$ ./main.exe sdc.nml lam1=3.0 niters=10</cite></p>
<p>The order of the command line parameters is not important except that they must come after the input file is specified.</p>
<p>To run an example that does the actual PFASST algorithm</p>
<p><cite>$ mpirun -n 32 ./main.exe multi_level.nml</cite></p>
<p>The main program is in <cite>src/main.f90</cite> and can be used as a template for building applications using LibPFASST.  The main routine here
only initializes MPI, calls a routine <code class="docutils literal notranslate"><span class="pre">run_pfasst</span></code> to run the PFASST algorithm, then closes MPI.</p>
<p>The first thing done in <code class="docutils literal notranslate"><span class="pre">run_pfasst</span></code> is to read in local problem parameters by calling  the subroutine <code class="docutils literal notranslate"><span class="pre">probin_init</span></code> located in <cite>src/probin.f90</cite>.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt; Read problem parameters</span>
<span class="k">call </span><span class="n">probin_init</span><span class="p">(</span><span class="n">pf_fname</span><span class="p">)</span>
</pre></div>
</div>
<p>This routine also returns the location of the namelist for the PFASST parameters, which in this case will match the location of the local parameters (a different file can be specified if desired).  After
the MPI based communicator is set up, the routine <code class="docutils literal notranslate"><span class="pre">pf_pfasst_create</span></code> is called to allocate the main PFASST structure called <code class="docutils literal notranslate"><span class="pre">pf</span></code>.  Note that the filename for PFASST parameters is
passed to this routine so that it can be read.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt;  Create the pfasst structure</span>
<span class="k">call </span><span class="n">pf_pfasst_create</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">pf_fname</span><span class="p">)</span>
</pre></div>
</div>
<p>The most important part of the initialization in <code class="docutils literal notranslate"><span class="pre">run_pfasst</span></code> is the loop over levels where the level, sweeper, and data encapsulation are specified.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt; Loop over levels and set some level specific parameters</span>
<span class="k">do </span><span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pf</span><span class="p">%</span><span class="n">nlevels</span>
   <span class="c">!&gt;  Allocate the user specific level object</span>
   <span class="k">allocate</span><span class="p">(</span><span class="n">my_level_t</span><span class="kd">::</span><span class="n">pf</span><span class="p">%</span><span class="n">levels</span><span class="p">(</span><span class="n">l</span><span class="p">)%</span><span class="n">ulevel</span><span class="p">)</span>

   <span class="c">!&gt;  Allocate the user specific data constructor</span>
   <span class="k">allocate</span><span class="p">(</span><span class="n">ndarray_factory</span><span class="kd">::</span><span class="n">pf</span><span class="p">%</span><span class="n">levels</span><span class="p">(</span><span class="n">l</span><span class="p">)%</span><span class="n">ulevel</span><span class="p">%</span><span class="n">factory</span><span class="p">)</span>

   <span class="c">!&gt;  Allocate the sweeper at this level</span>
   <span class="k">allocate</span><span class="p">(</span><span class="n">my_sweeper_t</span><span class="kd">::</span><span class="n">pf</span><span class="p">%</span><span class="n">levels</span><span class="p">(</span><span class="n">l</span><span class="p">)%</span><span class="n">ulevel</span><span class="p">%</span><span class="n">sweeper</span><span class="p">)</span>

   <span class="c">!&gt;  Set the size of the data on this level (here just one)</span>
   <span class="k">call </span><span class="n">pf_level_set_size</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span><span class="n">l</span><span class="p">,[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">end do</span>
</pre></div>
</div>
<p>The abstract type defining a level must be extended with spatial restriction and
interpolation operators (in this example, these are the identity operators).  This is done in the file <cite>src/level.f90</cite>.
Next, the encapsulation of the data type must be specified by assigning its factory.  In this example, the data type <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> provided by LibPFASST and corresponding to an N-dimensional array is used.
In the next Tutorial, a local encapsulation will be demonstrated.  Third, the abstract sweeper type must be extended and assigned to the level. This is done in the file <cite>src/sweeper.f90</cite> discussed below.  Finally, the level type carries a one-dimensional integer array to carry information about the size of the data.  This array must be set, and here the size is simply a one-dimensional array of length 1.</p>
<p>The local sweeper type needs to define
functions to evaluate each term in the IMEX splitting and
a routine to solve an implicit equation equivalent to a
backward-Euler step.  These routines are in <cite>src/sweeper.f90</cite> and are called
<code class="docutils literal notranslate"><span class="pre">f_eval</span></code> and <code class="docutils literal notranslate"><span class="pre">f_comp</span></code>.</p>
<p>After the levels are assigned, the rest of the PFASST structure can is made by calling</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt;  Set up some pfasst stuff</span>
<span class="k">call </span><span class="n">pf_pfasst_setup</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, a hook is added that will echo residuals to the screen after every iteration.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt; add some hooks for output  (using a LibPFASST hook here)</span>
<span class="k">call </span><span class="n">pf_add_hook</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">PF_POST_ITERATION</span><span class="p">,</span> <span class="n">pf_echo_residual</span><span class="p">)</span>
</pre></div>
</div>
<p>After a routine to echo
the run options to the screen, the initial conditions are set, and then the
routine to actually do the time stepping is called.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt; Do the PFASST time stepping</span>
<span class="k">call </span><span class="n">pf_pfasst_run</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mf">0.0_pfdp</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">)</span>
</pre></div>
</div>
<p>The rest is just cleanup.</p>
</div>
<div class="section" id="example-2">
<h2>Example 2<a class="headerlink" href="#example-2" title="Permalink to this headline">¶</a></h2>
<p>This example solves exactly the same equation as Example 1, but using more user generated code.
The main difference is that instead of using the LibPFASST data encapsulation <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>, a local data
encapsulation called <code class="docutils literal notranslate"><span class="pre">scalar_encap</span></code> is defined</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt;  Allocate the user specific data constructor</span>
<span class="k">allocate</span><span class="p">(</span><span class="n">scalar_factory</span><span class="kd">::</span><span class="n">pf</span><span class="p">%</span><span class="n">levels</span><span class="p">(</span><span class="n">l</span><span class="p">)%</span><span class="n">ulevel</span><span class="p">%</span><span class="n">factory</span><span class="p">)</span>
</pre></div>
</div>
<p>The relevant code for the factory is in <cite>src/encap.f90</cite>.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt;  Type to create and destroy the local data encapsulation</span>
<span class="k">type</span><span class="p">,</span> <span class="k">extends</span><span class="p">(</span><span class="n">pf_factory_t</span><span class="p">)</span> <span class="kd">::</span> <span class="n">scalar_factory</span>
 <span class="k">contains</span>
<span class="k">   procedure</span> <span class="kd">::</span> <span class="n">create_single</span>  <span class="o">=&gt;</span> <span class="n">scalar_create_single</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="n">create_array</span>  <span class="o">=&gt;</span> <span class="n">scalar_create_array</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="n">destroy_single</span> <span class="o">=&gt;</span> <span class="n">scalar_destroy_single</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="n">destroy_array</span> <span class="o">=&gt;</span> <span class="n">scalar_destroy_array</span>
<span class="k">end type </span><span class="n">scalar_factory</span>
</pre></div>
</div>
<p>The four required subroutines are in this case trivial since no data structures need to be allocated to make the encapsulation.</p>
<p>To define a data encapsulation, the user must also provide
7 subroutines that define actions on the data set corresponding to the procedures in
<cite>src/encap.f90</cite>.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">contains</span>
<span class="k">   procedure</span> <span class="kd">::</span> <span class="n">setval</span> <span class="o">=&gt;</span> <span class="n">scalar_setval</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="n">copy</span> <span class="o">=&gt;</span> <span class="n">scalar_copy</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="n">norm</span> <span class="o">=&gt;</span> <span class="n">scalar_norm</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="nb">pack</span> <span class="o">=&gt;</span> <span class="n">scalar_pack</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="nb">unpack</span> <span class="o">=&gt;</span> <span class="n">scalar_unpack</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="n">axpy</span> <span class="o">=&gt;</span> <span class="n">scalar_axpy</span>
   <span class="k">procedure</span> <span class="kd">::</span> <span class="n">eprint</span> <span class="o">=&gt;</span> <span class="n">scalar_eprint</span>
<span class="k">end type </span><span class="n">scalar_encap</span>
</pre></div>
</div>
<p>In this example, these are all trivial and should be self-explanatory from the code.  The last of these, eprint, is not typically needed  by LibPFASST but is included for convenience in debugging.</p>
<p>The sweeper assigned in this example is the same as in Example 1, but there are two additional routines defined in <cite>src/sweeper.f90</cite>.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">procedure</span> <span class="kd">::</span> <span class="n">initialize</span> <span class="c">!  Overwrites imex sweeper initialize</span>
<span class="k">procedure</span> <span class="kd">::</span> <span class="n">destroy</span>    <span class="c">!  Overwrites imex sweeper destroy</span>
</pre></div>
</div>
<p>These two routines will be called instead of the base sweeper initialize and destroy in LibPFASST.  The point is that this then allows the user to add whatever things to the sweeper as necessary.  Here, there is nothing to do, but one must explicitly call the LibPFASST versions of these routines, as in</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt;  Call the imex sweeper initialization</span>
<span class="k">call </span><span class="n">this</span><span class="p">%</span><span class="n">imex_initialize</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span><span class="n">level_index</span><span class="p">)</span>
</pre></div>
</div>
<p>Another difference in this example, is that a local hook is defined in the file <cite>src/hooks.f90</cite> to print the error to the screen.  It is assigned by</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt;  Add some hooks for output</span>
<span class="k">call </span><span class="n">pf_add_hook</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">PF_POST_ITERATION</span><span class="p">,</span> <span class="n">echo_error</span><span class="p">)</span>
</pre></div>
</div>
<p>The user can construct custom hooks following this template.</p>
<p>Finally, note that in this example, an optional argument to return the solution at the final time, <code class="docutils literal notranslate"><span class="pre">y_end</span></code> is included in the call to <code class="docutils literal notranslate"><span class="pre">pf_pfasst_run</span></code></p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt; Do the PFASST time stepping</span>
<span class="k">call </span><span class="n">pf_pfasst_run</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mf">0.0_pfdp</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">,</span><span class="n">y_end</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="example-3">
<h2>Example 3<a class="headerlink" href="#example-3" title="Permalink to this headline">¶</a></h2>
<p>Please see the <cite>LibPFASST/Tutorials/EX3_adv_diff</cite> directory included in LibPFASST
for a simple PDE application of LibPFASST.</p>
<p>This example solves a 1d linear advection diffusion equation</p>
<div class="math notranslate nohighlight">
\[u_t  = - v u_x + \nu u_{xx},\]</div>
<p>where $v$ and $nu$ are scalars.</p>
<p>This right hand side of the equation will be split into stiff terms handled implicitly
(<span class="math notranslate nohighlight">\(\nu u_{xx}\)</span>) and non-stiff terms handled explicitly (<span class="math notranslate nohighlight">\(-v u_x\)</span>),
hence an IMEX SDC substepper will be used to evolve the equation through time.
As in Example 1, the <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> encapsulation provided by LibPFASST is used here.</p>
<p>The code in <cite>src/main.f90</cite> is almost identical to that of Example 1 except that the size of the <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> is different and set per level
from the variable <code class="docutils literal notranslate"><span class="pre">nx</span></code> read from the local namelist.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt;  Set the size of the data on this level (here just one)</span>
<span class="k">call </span><span class="n">pf_level_set_size</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span><span class="n">l</span><span class="p">,[</span><span class="n">nx</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>
</pre></div>
</div>
<p>The most noticable difference in this example is that the function evaluations, implicit solves, and interpolation and restriction operators
are not trivial as in the Dahlquist examples.  This example is done with a pseudo-spectral discretization in space and the method of lines in time.
In the local definition of the sweeper,  variables are added to facilitate operations in spectral space</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">!&gt;  FFT and Spectral derivatives</span>
<span class="k">type</span><span class="p">(</span><span class="n">pf_fft_t</span><span class="p">),</span> <span class="k">pointer</span> <span class="kd">::</span> <span class="n">fft_tool</span>
<span class="kt">complex</span><span class="p">(</span><span class="n">pfdp</span><span class="p">),</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">opE</span><span class="p">(:)</span> <span class="c">! Explicit spectral operator</span>
<span class="kt">complex</span><span class="p">(</span><span class="n">pfdp</span><span class="p">),</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">opI</span><span class="p">(:)</span> <span class="c">! Implicit spectral operator</span>
</pre></div>
</div>
<p>The first of these is a pointer to the fft based type included in LibPFASST.  These variables are allocated and initialized in the local sweeper initialization routine.  In both  <code class="docutils literal notranslate"><span class="pre">feval</span></code> and <code class="docutils literal notranslate"><span class="pre">f_comp</span></code> the convolution subroutine <code class="docutils literal notranslate"><span class="pre">conv</span></code> is used for either implicit or explicit
function evaluations in spectral space, e.g.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">! Apply the inverse operator with the FFT convolution</span>
<span class="k">call </span><span class="n">fft</span><span class="p">%</span><span class="n">conv</span><span class="p">(</span><span class="n">rhsvec</span><span class="p">,</span><span class="mf">1.0_pfdp</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0_pfdp</span> <span class="o">-</span> <span class="n">dtq</span><span class="o">*</span><span class="n">this</span><span class="p">%</span><span class="n">opI</span><span class="p">),</span><span class="n">yvec</span><span class="p">)</span>
</pre></div>
</div>
<p>In a similar manner, in the local definition of the <code class="docutils literal notranslate"><span class="pre">level</span></code>, the interpolation is done in spectral space while the restriction is just pointwise coarsening.</p>
<p>When creating an example using a new data structure or equation, the most important things that must be provided are in fact the function evaluations and interpolation restriction operators.  The user is allowed to add any useful code to the local sweeper and level structures to implement these routines.</p>
</div>
<div class="section" id="example-4">
<h2>Example 4<a class="headerlink" href="#example-4" title="Permalink to this headline">¶</a></h2>
<p id="tut4">In the directory <cite>LibPFASST/Tutorials/EX4_Boussinesq</cite> is a more complicated example involving the 2-dimenstional Boussinesq eqauations in a vorticity-function form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\omega_t  = - (\bf{u} \cdot \nabla)\omega + \nu \nabla^2 \omega - g\rho_x \\
\rho_t  = - (\bf{u} \cdot \nabla)\rho + \kappa \nabla^2 \rho\end{split}\]</div>
<p>Here (<span class="math notranslate nohighlight">\(\omega\)</span>) is the vorticity, (<span class="math notranslate nohighlight">\(\bf{u}\)</span>)  is the velocity, and
(<span class="math notranslate nohighlight">\(\rho\)</span>) a density or bouyancy term.  The constants (<span class="math notranslate nohighlight">\(\nu\)</span>) and (<span class="math notranslate nohighlight">\(\kappa\)</span>) determine the diffusion terms, and (<span class="math notranslate nohighlight">\(g\)</span>)  “gravity”.</p>
<p>The example code is similar to Example 3 except is based on the encapsulation for a complex N-dimensional system of equations called <code class="docutils literal notranslate"><span class="pre">zndsysarray</span></code>.  Using the input file <cite>tg.nml</cite>, will run a special case with an exact solution and report errors.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial</a><ul>
<li><a class="reference internal" href="#example-1">Example 1</a></li>
<li><a class="reference internal" href="#example-2">Example 2</a></li>
<li><a class="reference internal" href="#example-3">Example 3</a></li>
<li><a class="reference internal" href="#example-4">Example 4</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="compiling.html"
                        title="previous chapter">Compiling</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="parameters.html"
                        title="next chapter">Parameters and variables</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tutorial.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="parameters.html" title="Parameters and variables"
             >next</a> |</li>
        <li class="right" >
          <a href="compiling.html" title="Compiling"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">LIBPFASST 1.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="copyright.html">Copyright</a> 2018, Matthew Emmett, Michael Minion, Brandon Krull, Sebastian Goetschel, Francois Hamon.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>