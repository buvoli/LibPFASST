var tipuesearch = {"pages":[{"text":"LibPFASST Developer Info Matthew Emmett. Michael Minion, Sebastian Goetschel, Brandon Krull, Francois Hamon, Tomasso Buvoli","tags":"home","loc":"index.html","title":" LibPFASST "},{"text":"Runge-Kutta time steppers Contents Modules pf_mod_rkstepper Source Code pf_rkstepper.f90 Source Code !!  Runge-Kutta time steppers ! ! This file is part of LIBPFASST. ! !>  Module to do Runge-Kutta stepping module pf_mod_rkstepper use pf_mod_dtype use pf_mod_utils implicit none !>  IMEX or additive or semi-implicit Runge-Kutta stepper  type type , extends ( pf_stepper_t ), abstract :: pf_ark_stepper_t real ( pfdp ), allocatable :: AmatI (:,:) real ( pfdp ), allocatable :: AmatE (:,:) real ( pfdp ), allocatable :: cvec (:) real ( pfdp ), allocatable :: bvecI (:) real ( pfdp ), allocatable :: bvecE (:) real ( pfdp ), allocatable :: QtilI (:,:) logical :: explicit = . true . logical :: implicit = . true . integer :: nstages !  Local storage (not optimal) class ( pf_encap_t ), allocatable :: rhs !!  Accumulated right hand side for implicit solves class ( pf_encap_t ), allocatable :: qtemp !!  Temp for y class ( pf_encap_t ), allocatable :: q0 !!  Local q0 class ( pf_encap_t ), allocatable :: qend !!  Local qend class ( pf_encap_t ), pointer :: F (:,:) !!  Pointer to F contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: do_n_steps => ark_do_n_steps procedure :: initialize => ark_initialize procedure :: destroy => ark_destroy procedure :: ark_initialize procedure :: ark_destroy end type pf_ark_stepper_t interface subroutine pf_f_eval_p ( this , y , t , level_index , f , piece ) import pf_ark_stepper_t , pf_encap_t , pfdp class ( pf_ark_stepper_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_eval_p subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece ) import pf_ark_stepper_t , pf_encap_t , pfdp class ( pf_ark_stepper_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: dtq class ( pf_encap_t ), intent ( in ) :: rhs integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_comp_p end interface contains !> Perform N steps of ark on level level_index and set qend appropriately. subroutine ark_do_n_steps ( this , pf , level_index , t0 , q0 , qend , big_dt , nsteps_rk ) use pf_mod_timer use pf_mod_hooks class ( pf_ark_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 !!  Time at start of time interval class ( pf_encap_t ), intent ( in ) :: q0 !!  Starting value class ( pf_encap_t ), intent ( inout ) :: qend !!  Final value real ( pfdp ), intent ( in ) :: big_dt !!  Size of time interval to integrato on integer , intent ( in ) :: level_index !!  Level of the index to step on integer , intent ( in ) :: nsteps_rk !!  Number of steps to use class ( pf_level_t ), pointer :: lev !!  Pointer to level level_index integer :: j , m , n !!  Loop counters real ( pfdp ) :: tn !!  Time at beginning of RKstep real ( pfdp ) :: tc !!  Time at  RK stage real ( pfdp ) :: dt !!  Size of each ark step lev => pf % levels ( level_index ) !! Assign pointer to appropriate level dt = big_dt / real ( nsteps_rk , pfdp ) ! Set the internal time step size based on the number of rk steps call this % q0 % copy ( q0 ) do n = 1 , nsteps_rk ! Loop over time steps tn = t0 + dt * real ( n - 1 , pfdp ) ! Reset initial condition if ( n > 1 ) call this % q0 % copy ( this % qend ) ! this assumes that cvec(1) == 0 if ( this % explicit ) & call this % f_eval ( this % q0 , tn + dt * this % cvec ( 1 ), level_index , this % F ( 1 , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( this % q0 , tn + dt * this % cvec ( 1 ), level_index , this % F ( 1 , 2 ), 2 ) ! Loop over stage values do m = 1 , this % nstages - 1 ! Set current time tc = tn + dt * this % cvec ( m + 1 ) ! Initialize the right-hand size for each stage call this % rhs % copy ( this % q0 ) do j = 1 , m ! Add explicit rhs if ( this % explicit ) & call this % rhs % axpy ( dt * this % AmatE ( m + 1 , j ), this % F ( j , 1 )) ! Add implicit rhs if ( this % implicit ) & call this % rhs % axpy ( dt * this % AmatI ( m + 1 , j ), this % F ( j , 2 )) end do ! Solve the implicit system if ( this % implicit . and . this % AmatI ( m + 1 , m + 1 ) /= 0 ) then call this % f_comp ( this % qtemp , tc , dt * this % AmatI ( m + 1 , m + 1 ), this % rhs , level_index , this % F ( m + 1 , 2 ), 2 ) else call this % qtemp % copy ( this % rhs ) end if ! Reevaluate explicit rhs with the new solution if ( this % explicit ) & call this % f_eval ( this % qtemp , tc , level_index , this % F ( m + 1 , 1 ), 1 ) end do ! End loop over stage values ! Compute final value using quadrature rule call this % qend % copy ( this % q0 ) ! Loop over stage values one more time do j = 1 , this % nstages ! Add explicit terms if ( this % explicit ) & call this % qend % axpy ( dt * this % bvecE ( j ), this % F ( j , 1 )) ! Add implicit terms if ( this % implicit ) & call this % qend % axpy ( dt * this % bvecI ( j ), this % F ( j , 2 )) end do ! End loop over stage values end do ! End Loop over time steps call qend % copy ( this % qend ) end subroutine ark_do_n_steps subroutine ark_initialize ( this , pf , level_index ) class ( pf_ark_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize integer :: nstages , npieces , i !  Local copies for convenience real ( pfdp ) :: gamma , delta type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer !  The implicit and explicit flags should be set before calling initialize npieces = 1 if ( this % implicit . eqv . . true . . and . this % explicit . eqv . . true .) npieces = 2 select case ( this % order ) case ( 1 ) !  Forward-backward Euler nstages = 2 case ( 2 ) !  Ascher-Ruuth-Spiteri nstages = 3 case ( 3 ) ! Third-order Kennedy-Carpenter nstages = 4 case ( 4 ) ! Fourth-order Kennedy-Carpenter nstages = 6 case DEFAULT stop \"ark_initialize: This RK order is not supported\" call exit ( 0 ) end select this % nstages = nstages this % npieces = npieces allocate ( this % AmatE ( nstages , nstages )) !  Explicit Butcher matrix allocate ( this % AmatI ( nstages , nstages )) !  Implicit Butcher matrix allocate ( this % cvec ( nstages )) !  stage times allocate ( this % bvecE ( nstages )) !  quadrature weights on explicit allocate ( this % bvecI ( nstages )) !  quadrature weights on implicit this % AmatE = 0.0_pfdp this % AmatI = 0.0_pfdp this % bvecE = 0.0_pfdp this % bvecI = 0.0_pfdp this % cvec = 0.0_pfdp select case ( this % order ) case ( 1 ) !  Forward-backward Euler this % AmatE ( 2 , 1 ) = ONE this % AmatI ( 2 , 2 ) = ONE this % cvec = ( / ZERO , ONE / ) this % bvecE = ( / ONE , ZERO / ) this % bvecI = ( / ZERO , ONE / ) case ( 2 ) !  Ascher-Ruuth-Spiteri gamma = ( TWO - sqrt ( TWO )) / TWO delta = - TWO * sqrt ( TWO ) / THREE this % AmatE ( 2 , 1 ) = gamma this % AmatE ( 3 , 1 ) = delta this % AmatE ( 3 , 2 ) = ONE - delta this % AmatI ( 2 , 2 ) = gamma this % AmatI ( 3 , 2 ) = ONE - gamma this % AmatI ( 3 , 3 ) = gamma this % cvec = ( / ZERO , gamma , ONE / ) this % bvecE = ( / ZERO , ONE - gamma , gamma / ) this % bvecI = this % bvecE case ( 3 ) ! Third-order Kennedy-Carpenter this % AmatE ( 2 , 1 ) = 176773220590 3.0_pfdp / 202783664111 8.0_pfdp this % AmatE ( 3 , 1 ) = 553582888582 5.0_pfdp / 1049269177363 7.0_pfdp this % AmatE ( 3 , 2 ) = 78802234243 7.0_pfdp / 1088263485894 0.0_pfdp this % AmatE ( 4 , 1 ) = 648598928062 9.0_pfdp / 1625170173562 2.0_pfdp this % AmatE ( 4 , 2 ) = - 424626684708 9.0_pfdp / 970447391861 9.0_pfdp this % AmatE ( 4 , 3 ) = 1075544844929 2.0_pfdp / 1035709742484 1.0_pfdp this % AmatI ( 2 , 1 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 2 , 2 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 3 , 1 ) = 274623878971 9.0_pfdp / 1065886856070 8.0_pfdp this % AmatI ( 3 , 2 ) = - 64016744523 7.0_pfdp / 684562943199 7.0_pfdp this % AmatI ( 3 , 3 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 4 , 1 ) = 147126639957 9.0_pfdp / 784085678865 4.0_pfdp this % AmatI ( 4 , 2 ) = - 448244416785 8.0_pfdp / 752975506669 7.0_pfdp this % AmatI ( 4 , 3 ) = 1126623926642 8.0_pfdp / 1159328672282 1.0_pfdp this % AmatI ( 4 , 4 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % cvec = ( / 0.0_pfdp , 176773220590 3.0_pfdp / 202783664111 8.0_pfdp , 3.0_pfdp / 5.0_pfdp , 1.0_pfdp / ) this % bvecE = ( / 147126639957 9.0_pfdp / 784085678865 4.0_pfdp , - 448244416785 8.0_pfdp / 752975506669 7.0_pfdp ,& 1126623926642 8.0_pfdp / 1159328672282 1.0_pfdp , 176773220590 3.0_pfdp / 405567328223 6.0_pfdp / ) this % bvecI = this % bvecE case ( 4 ) ! Fourth-order Kennedy-Carpenter this % AmatE ( 2 , 1 ) = 0.5_pfdp this % AmatE ( 3 , 1 ) = 1386 1.0_pfdp / 6250 0.0_pfdp this % AmatE ( 3 , 2 ) = 688 9.0_pfdp / 6250 0.0_pfdp this % AmatE ( 4 , 1 ) = - 11692331627 5.0_pfdp / 239368406146 8.0_pfdp this % AmatE ( 4 , 2 ) = - 273121846731 7.0_pfdp / 1536804210183 1.0_pfdp this % AmatE ( 4 , 3 ) = 940804670208 9.0_pfdp / 1111317113920 9.0_pfdp this % AmatE ( 5 , 1 ) = - 45108634878 8.0_pfdp / 290242868990 9.0_pfdp this % AmatE ( 5 , 2 ) = - 268234879257 2.0_pfdp / 751979568189 7.0_pfdp this % AmatE ( 5 , 3 ) = 1266286877508 2.0_pfdp / 1196047911538 3.0_pfdp this % AmatE ( 5 , 4 ) = 335581797596 5.0_pfdp / 1106085150927 1.0_pfdp this % AmatE ( 6 , 1 ) = 64784517918 8.0_pfdp / 321632005775 1.0_pfdp this % AmatE ( 6 , 2 ) = 7328151925 0.0_pfdp / 838263948453 3.0_pfdp this % AmatE ( 6 , 3 ) = 55253951339 1.0_pfdp / 345466838623 3.0_pfdp this % AmatE ( 6 , 4 ) = 335451267163 9.0_pfdp / 830676392457 3.0_pfdp this % AmatE ( 6 , 5 ) = 404 0.0_pfdp / 1787 1.0_pfdp this % AmatI ( 2 , 1 ) = 0.25_pfdp this % AmatI ( 2 , 2 ) = 0.25_pfdp this % AmatI ( 3 , 1 ) = 861 1.0_pfdp / 6250 0.0_pfdp this % AmatI ( 3 , 2 ) = - 174 3.0_pfdp / 3125 0.0_pfdp this % AmatI ( 3 , 3 ) = 0.25_pfdp this % AmatI ( 4 , 1 ) = 501202 9.0_pfdp / 3465250 0.0_pfdp this % AmatI ( 4 , 2 ) = - 65444 1.0_pfdp / 292250 0.0_pfdp this % AmatI ( 4 , 3 ) = 17437 5.0_pfdp / 38810 8.0_pfdp this % AmatI ( 4 , 4 ) = 0.25_pfdp this % AmatI ( 5 , 1 ) = 1526708280 9.0_pfdp / 15537626560 0.0_pfdp this % AmatI ( 5 , 2 ) = - 7144340 1.0_pfdp / 12077440 0.0_pfdp this % AmatI ( 5 , 3 ) = 73087887 5.0_pfdp / 90218476 8.0_pfdp this % AmatI ( 5 , 4 ) = 228539 5.0_pfdp / 807091 2.0_pfdp this % AmatI ( 5 , 5 ) = 0.25_pfdp this % AmatI ( 6 , 1 ) = 8288 9.0_pfdp / 52489 2.0_pfdp this % AmatI ( 6 , 2 ) = 0.0_pfdp this % AmatI ( 6 , 3 ) = 1562 5.0_pfdp / 8366 4.0_pfdp this % AmatI ( 6 , 4 ) = 6987 5.0_pfdp / 10267 2.0_pfdp this % AmatI ( 6 , 5 ) = - 226 0.0_pfdp / 821 1.0_pfdp this % AmatI ( 6 , 6 ) = 0.25_pfdp this % cvec = ( / 0.0_pfdp , 0.5_pfdp , 8 3.0_pfdp / 25 0.0_pfdp , & 3 1.0_pfdp / 5 0.0_pfdp , 1 7.0_pfdp / 2 0.0_pfdp , 1.0_pfdp / ) this % bvecE = ( / 8288 9.0_pfdp / 52489 2.0_pfdp , 0.0_pfdp , 1562 5.0_pfdp / 8366 4.0_pfdp , & 6987 5.0_pfdp / 10267 2.0_pfdp , - 226 0.0_pfdp / 821 1.0_pfdp , 0.25_pfdp / ) this % bvecI = this % bvecE case DEFAULT stop \"ark_initialize: This RK order is not supported\" call exit ( 0 ) end select ! Allocate space for local variables call lev % ulevel % factory % create_single ( this % rhs , level_index , lev % shape ) call lev % ulevel % factory % create_single ( this % q0 , level_index , lev % shape ) call lev % ulevel % factory % create_single ( this % qend , level_index , lev % shape ) call lev % ulevel % factory % create_single ( this % qtemp , level_index , lev % shape ) call lev % ulevel % factory % create_array ( lev % Frkflt , nstages * npieces , level_index , lev % shape ) do i = 1 , nstages * npieces call lev % Frkflt ( i )% setval ( 0.0_pfdp , 0 ) end do this % F ( 1 : nstages , 1 : npieces ) => lev % Frkflt end subroutine ark_initialize subroutine ark_destroy ( this , pf , level_index ) class ( pf_ark_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % AmatE ) deallocate ( this % AmatI ) deallocate ( this % bvecE ) deallocate ( this % bvecI ) deallocate ( this % cvec ) call lev % ulevel % factory % destroy_single ( this % qend ) call lev % ulevel % factory % destroy_single ( this % q0 ) call lev % ulevel % factory % destroy_single ( this % rhs ) call lev % ulevel % factory % destroy_single ( this % qtemp ) call lev % ulevel % factory % destroy_array ( lev % Frkflt ) end subroutine ark_destroy end module pf_mod_rkstepper","tags":"","loc":"sourcefile/pf_rkstepper.f90.html","title":"pf_rkstepper.f90 – LibPFASST"},{"text":"IMEX Sweeper Module Contents Modules pf_mod_imex_sweeper Source Code pf_imex_sweeper.f90 Source Code !!  IMEX Sweeper Module ! ! This file is part of LIBPFASST. ! !>  IMEX Sweeper Module !!  Module of the  the derived sweeper class for doing IMEX sweeps for an equation of the form !!            y' = f_1(y) + f_2(y)   !!  The f_1 piece is treated explicitly and f_2 implicitl !!  Afer this sweeper is initialized (usually in main), the logical flags can be changed if desired !! !!     explicit:  Make false if there is no explicit piece !! !!     implicit:  Make false if there is no implicit piece !! !!  The user needs to supply the feval and fcomp routines for a given example module pf_mod_imex_sweeper use pf_mod_dtype use pf_mod_utils implicit none !>  IMEX SDC sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_imex_sweeper_t real ( pfdp ), allocatable :: QtilE (:,:) !!  Approximate explicit quadrature rule real ( pfdp ), allocatable :: QtilI (:,:) !!  Approximate implicit quadrature rule real ( pfdp ), allocatable :: dtsdc (:) !!  SDC step sizes real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: QdiffI (:,:) !!  qmat-QtilI logical :: explicit !!  True if there is an explicit piece (must set in derived sweeper) logical :: implicit !!  True if there an implicit piece (must set in derived sweeper) class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver !>  Set the generic functions procedure :: sweep => imex_sweep procedure :: initialize => imex_initialize procedure :: evaluate => imex_evaluate procedure :: integrate => imex_integrate procedure :: residual => imex_residual procedure :: spreadq0 => imex_spreadq0 procedure :: evaluate_all => imex_evaluate_all procedure :: destroy => imex_destroy procedure :: imex_destroy procedure :: imex_initialize end type pf_imex_sweeper_t interface !>  The interface to the routine to compute the RHS function values !>  Evaluate f_piece(y), where piece is one or two subroutine pf_f_eval_p ( this , y , t , level_index , f , piece ) import pf_imex_sweeper_t , pf_encap_t , pfdp class ( pf_imex_sweeper_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_eval_p !>  The interface to the routine to do implicit solve !>  i.e, solve the equation y - dtq*f_2(y) =rhs subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece ) import pf_imex_sweeper_t , pf_encap_t , pfdp class ( pf_imex_sweeper_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_2 of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_comp_p end interface contains !> Perform nsweeps SDC sweeps on level level_index and set qend appropriately. subroutine imex_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to sweep real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !!  sweep specific flags !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level integer :: m , n , k !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( level_index ) !  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) !  Add terms from previous iteration  (not passing CI tests) !do m = 1, lev%nnodes-1 !   call lev%I(m)%setval(0.0_pfdp) !end do !if (this%explicit) call pf_apply_mat(lev%I, dt, this%QdiffE, lev%F(:,1), .false.) !if (this%implicit) call pf_apply_mat(lev%I, dt, this%QdiffI, lev%F(:,2), .false.) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) if ( this % explicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) end do end if if ( this % implicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 )) end do end if end do !  Add the tau FAS correction if ( level_index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) if ( m > 1 . and . pf % use_Sform ) then call lev % I ( m )% axpy ( - 1.0_pfdp , lev % tauQ ( m - 1 )) end if end do end if !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) end if t = t0 ! do the sub-stepping in sweep do m = 1 , lev % nnodes - 1 !!  Loop over substeps t = t + dt * this % dtsdc ( m ) !>  Accumulate rhs call this % rhs % setval ( 0.0_pfdp ) do n = 1 , m if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do !>  Add the integral term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m )) !>  Add the starting value if ( pf % use_Sform ) then call this % rhs % axpy ( 1.0_pfdp , lev % Q ( m )) else call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 )) end if !>  Solve for the implicit piece if ( this % implicit ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) else call lev % Q ( m + 1 )% copy ( this % rhs ) end if !>  Compute explicit function on new value if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) end do !!  End substep loop call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imex_sweep !> Subroutine to initialize matrices and space for sweeper subroutine imex_initialize ( this , pf , level_index ) use pf_mod_quadrature class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize type ( pf_level_t ), pointer :: lev !  Current level integer :: nnodes , ierr lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 2 !  The default is to use both pieces, but can be overriddent in local sweeper this % explicit = . TRUE . this % implicit = . TRUE . nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for QdiffE\" allocate ( this % QdiffI ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for QdiffI\" allocate ( this % QtilE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for QtilE\" allocate ( this % QtilI ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for QtilI\" allocate ( this % dtsdc ( nnodes - 1 ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for dtsdc\" this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes this % dtsdc = lev % sdcmats % qnodes ( 2 : nnodes ) - lev % sdcmats % qnodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI if ( pf % use_Sform ) then this % QdiffE ( 2 : nnodes - 1 ,:) = this % QdiffE ( 2 : nnodes - 1 ,:) - this % QdiffE ( 1 : nnodes - 2 ,:) this % QdiffI ( 2 : nnodes - 1 ,:) = this % QdiffI ( 2 : nnodes - 1 ,:) - this % QdiffI ( 1 : nnodes - 2 ,:) this % QtilE ( 2 : nnodes - 1 ,:) = this % QtilE ( 2 : nnodes - 1 ,:) - this % QtilE ( 1 : nnodes - 2 ,:) this % QtilI ( 2 : nnodes - 1 ,:) = this % QtilI ( 2 : nnodes - 1 ,:) - this % QtilI ( 1 : nnodes - 2 ,:) end if !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine imex_initialize !>  Subroutine to deallocate sweeper subroutine imex_destroy ( this , pf , level_index ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine imex_destroy !> Subroutine to compute  Picard integral of function values subroutine imex_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags integer :: n , m type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes if ( this % explicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 1 )) if ( this % implicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 2 )) end do end do !    if (this%explicit) call pf_apply_mat(fintSDC, dt, lev%sdcmats%Qmat, fSDC(:,1), .false.) !    if (this%implicit) call pf_apply_mat(fintSDC, dt, lev%sdcmats%Qmat, fSDC(:,2), .false.) end subroutine imex_integrate !> Subroutine to compute  Residual subroutine imex_residual ( this , pf , level_index , dt , flags ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags call pf_generic_residual ( this , pf , level_index , dt ) end subroutine imex_residual subroutine imex_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine imex_spreadq0 !> Subroutine to evaluate function value at node m subroutine imex_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) end subroutine imex_evaluate !> Subroutine to evaluate the function values at all nodes subroutine imex_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine imex_evaluate_all end module pf_mod_imex_sweeper","tags":"","loc":"sourcefile/pf_imex_sweeper.f90.html","title":"pf_imex_sweeper.f90 – LibPFASST"},{"text":"Multi-implicit sweeper module Contents Modules pf_mod_misdcQ Source Code pf_misdcQ_sweeper.f90 Source Code !! Multi-implicit sweeper module ! ! This file is part of LIBPFASST. ! !>  Module of the  the derived sweeper class for doing MISDC sweeps for an equation of the form !!            y' = f_1(y) + f_2(y) + f_3(y)  !!  The f_1 piece is treated explicitly and f_2 and f_3 implicitly !!  Afer this sweeper is initialized (usually in main), the locgical flags can be changed if desired module pf_mod_misdcQ use pf_mod_dtype use pf_mod_utils implicit none !>  Multi-implicit SDC sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_misdcQ_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) real ( pfdp ), allocatable :: dtsdc (:) class ( pf_encap_t ), allocatable :: I3 (:) class ( pf_encap_t ), allocatable :: rhs contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdcQ_sweep procedure :: initialize => misdcQ_initialize procedure :: integrate => misdcQ_integrate procedure :: residual => misdcQ_residual procedure :: spreadq0 => misdcQ_spreadq0 procedure :: evaluate_all => misdcQ_evaluate_all procedure :: evaluate => misdcQ_evaluate procedure :: destroy => misdcQ_destroy procedure :: misdcQ_destroy procedure :: misdcQ_initialize end type pf_misdcQ_t interface !>  This is the interface for the routine to compute the RHS function values !>  Evaluate f_piece(y), where piece is one or two subroutine pf_f_eval_p ( this , y , t , level_index , f , piece ) !>  Evaluate f_piece(y), where piece is one or two import pf_misdcQ_t , pf_encap_t , pfdp class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_eval_p !>  Solve the equation y - dtq*f_n(y) =rhs  where n is given by the argument piece subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece ) import pf_misdcQ_t , pf_encap_t , pfdp class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_n of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_comp_p end interface contains ! Perform on SDC sweep on level lev and set qend appropriately. subroutine misdcQ_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables integer :: m , n , k real ( pfdp ) :: t type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) call this % I3 ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 )) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( m , n ), lev % F ( n , 3 )) call this % I3 ( m )% axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 )) !  Note we have to leave off the -dt*Qtil here and put it in after f2comp end do if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do ! do the time-stepping if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 ) endif t = t0 do m = 1 , lev % nnodes - 1 t = t + dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m )) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 )) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( Lev % Q ( m + 1 )) do n = 1 , m call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 3 ), 3 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 ) end do call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine misdcQ_sweep ! Initialize matrices subroutine misdcQ_initialize ( this , pf , level_index ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index integer :: m , n , nnodes type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) ! S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) ! S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) ! S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) ! S-BE allocate ( this % dtsdc ( nnodes - 1 )) this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) !>  Make space for extra integration piece call lev % ulevel % factory % create_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) end subroutine misdcQ_initialize subroutine misdcQ_destroy ( this , pf , level_index ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % I3 ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine misdcQ_destroy ! Compute SDC integral subroutine misdcQ_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: n , m , p type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine misdcQ_integrate !> Subroutine to evaluate function value at node m subroutine misdcQ_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 ) end subroutine misdcQ_evaluate !> Subroutine to evaluate the function values at all nodes subroutine misdcQ_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine misdcQ_evaluate_all !> Subroutine to compute  Residual subroutine misdcQ_residual ( this , pf , level_index , dt , flags ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags call pf_generic_residual ( this , pf , level_index , dt ) end subroutine misdcQ_residual subroutine misdcQ_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine misdcQ_spreadq0 end module pf_mod_misdcQ","tags":"","loc":"sourcefile/pf_misdcq_sweeper.f90.html","title":"pf_misdcQ_sweeper.f90 – LibPFASST"},{"text":"Old style multi-implicit sweeper Contents Modules pf_mod_misdc Source Code pf_misdc_sweeper.f90 Source Code !!  Old style multi-implicit sweeper ! ! This file is part of LIBPFASST. ! !>  Multi-implicit SDC sweeper type (old style), extends abstract sweeper module pf_mod_misdc use pf_mod_dtype use pf_mod_utils implicit none !>  MISDC sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_misdc_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdc_sweep procedure :: initialize => misdc_initialize procedure :: evaluate => misdc_evaluate procedure :: integrate => misdc_integrate procedure :: residual => misdc_residual procedure :: evaluate_all => misdc_evaluate_all procedure :: destroy => misdc_destroy procedure :: misdc_destroy end type pf_misdc_t interface subroutine pf_f_eval_p ( this , y , t , level , f , piece ) import pf_misdc_t , pf_encap_t , pfdp class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_eval_p subroutine pf_f_comp_p ( this , y , t , dt , rhs , level , f , piece ) import pf_misdc_t , pf_encap_t , pfdp class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( in ) :: rhs integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_comp_p end interface contains ! Perform on SDC sweep on level lev and set qend appropriately. subroutine misdc_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_misdc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: S3 (:) class ( pf_encap_t ), allocatable :: rhs call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * this % SdiffI ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call misdc_evaluate ( this , lev , t , 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 ) call lev % ulevel % factory % create_single ( rhs , lev % index , lev % shape ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhs % copy ( lev % Q ( m )) call rhs % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhs % axpy ( 1.0_pfdp , lev % S ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) !  Now we need to do the final subtraction for the f3 piece call rhs % copy ( Lev % Q ( m + 1 )) call rhs % axpy ( - 1.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 3 )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 3 ), 3 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 ) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! done call lev % ulevel % factory % destroy_single ( rhs , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine misdc_sweep ! Evaluate function values subroutine misdc_evaluate ( this , lev , t , m ) use pf_mod_dtype class ( pf_misdc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 ) end subroutine misdc_evaluate ! Initialize matrices subroutine misdc_initialize ( this , lev ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine misdc_initialize subroutine misdc_destroy ( this , lev ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine misdc_destroy ! Compute SDC integral subroutine misdc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine misdc_integrate subroutine misdc_residual ( this , lev , dt ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine misdc_residual subroutine misdc_evaluate_all ( this , lev , t ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine misdc_evaluate_all end module pf_mod_misdc","tags":"","loc":"sourcefile/pf_misdc_sweeper.f90.html","title":"pf_misdc_sweeper.f90 – LibPFASST"},{"text":"Module of FFT based routines using fftpack Contents Modules pf_mod_fft_abs Source Code pf_fft.f90 Source Code !!  Module of FFT based routines using fftpack ! ! This file is part of LIBPFASST. ! !>  Module for using fftpack module pf_mod_fft_abs use pf_mod_dtype use pf_mod_utils implicit none !>  Variables and storage for FFT type , abstract :: pf_fft_abs_t integer :: nx , ny , nz !! grid sizes integer :: dim !! spatial dimension real ( pfdp ) :: Lx , Ly , Lz !! domain size complex ( pfdp ), pointer :: wk_1d (:) ! work space complex ( pfdp ), pointer :: wk_2d (:,:) ! work space complex ( pfdp ), pointer :: wk_3d (:,:,:) ! work space contains procedure ( pf_fft_s_p ), deferred :: fft_setup procedure ( pf_fft_p ), deferred :: fft_destroy procedure ( pf_fft_p ), deferred :: fftf !  Forward FFT procedure ( pf_fft_p ), deferred :: fftb !  Inverse (backward)  FFT !  FFT procedure , private :: fft_1d , fft_2d , fft_3d , zfft_1d , zfft_2d , zfft_3d generic :: fft => fft_1d , fft_2d , fft_3d , zfft_1d , zfft_2d , zfft_3d !  Inverse FFT procedure , private :: ifft_1d , ifft_2d , ifft_3d , izfft_1d , izfft_2d , izfft_3d generic :: ifft => ifft_1d , ifft_2d , ifft_3d , izfft_1d , izfft_2d , izfft_3d !  Convolution in spectral space procedure , private :: conv_1d , conv_2d , conv_3d generic :: conv => conv_1d , conv_2d , conv_3d !  Complex convolution in real space procedure , private :: zconv_1d , zconv_2d , zconv_3d generic :: zconv => zconv_1d , zconv_2d , zconv_3d !  Convenience function to grab pointer to workspace procedure , private :: get_wk_ptr_1d , get_wk_ptr_2d , get_wk_ptr_3d generic :: get_wk_ptr => get_wk_ptr_1d , get_wk_ptr_2d , get_wk_ptr_3d !  Construct spectral Laplacian procedure , private :: make_lap_1d , make_lap_2d , make_lap_3d generic :: make_lap => make_lap_1d , make_lap_2d , make_lap_3d !  Construct spectral derivative procedure , private :: make_deriv_1d , make_deriv_2d , make_deriv_3d generic :: make_deriv => make_deriv_1d , make_deriv_2d , make_deriv_3d !  Restrict in spectral space procedure , private :: restrict_1d , restrict_2d , restrict_3d , zrestrict_1d , zrestrict_2d , zrestrict_3d generic :: restrict => restrict_1d , restrict_2d , restrict_3d , zrestrict_1d , zrestrict_2d , zrestrict_3d end type pf_fft_abs_t interface subroutine pf_fft_s_p ( this , grid_shape , dim , grid_size ) import pf_fft_abs_t , pfdp class ( pf_fft_abs_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) end subroutine pf_fft_s_p subroutine pf_fft_p ( this ) import pf_fft_abs_t , pfdp class ( pf_fft_abs_t ), intent ( inout ) :: this end subroutine pf_fft_p end interface contains subroutine get_wk_ptr_1d ( this , wk ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer , intent ( inout ) :: wk (:) ! work space wk => this % wk_1d end subroutine get_wk_ptr_1d subroutine get_wk_ptr_2d ( this , wk ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer , intent ( inout ) :: wk (:,:) ! work space wk => this % wk_2d end subroutine get_wk_ptr_2d subroutine get_wk_ptr_3d ( this , wk ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer , intent ( inout ) :: wk (:,:,:) ! work space wk => this % wk_3d end subroutine get_wk_ptr_3d !++++++++++ Forward FFT real to complex  ++++++++++++++++ subroutine fft_1d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:) complex ( pfdp ), intent ( inout ) :: ghat (:) this % wk_1d = g call this % fftf () ghat = this % wk_1d end subroutine fft_1d subroutine fft_2d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:,:) complex ( pfdp ), intent ( inout ) :: ghat (:,:) this % wk_2d = g call this % fftf () ghat = this % wk_2d end subroutine fft_2d subroutine fft_3d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:,:,:) complex ( pfdp ), intent ( inout ) :: ghat (:,:,:) this % wk_3d = g call this % fftf () ghat = this % wk_3d end subroutine fft_3d !++++++++++ Backward FFT complex to real   ++++++++++++++++ subroutine ifft_1d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ) :: g (:) complex ( pfdp ), intent ( in ) :: ghat (:) this % wk_1d = ghat call this % fftb () g = real ( this % wk_1d , pfdp ) end subroutine ifft_1d subroutine ifft_2d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ) :: g (:,:) complex ( pfdp ), intent ( in ) :: ghat (:,:) this % wk_2d = ghat call this % fftb () g = real ( this % wk_2d , pfdp ) end subroutine ifft_2d subroutine ifft_3d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ) :: g (:,:,:) complex ( pfdp ), intent ( in ) :: ghat (:,:,:) this % wk_3d = ghat call this % fftb () g = real ( this % wk_3d ) end subroutine ifft_3d !++++++++++ Forward FFT complex to complex   ++++++++++++++++ subroutine zfft_1d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:) complex ( pfdp ), intent ( inout ) :: ghat (:) this % wk_1d = g call this % fftf () ghat = this % wk_1d end subroutine zfft_1d subroutine zfft_2d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:) complex ( pfdp ), intent ( inout ) :: ghat (:,:) this % wk_2d = g call this % fftf () ghat = this % wk_2d end subroutine zfft_2d subroutine zfft_3d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:,:) complex ( pfdp ), intent ( inout ) :: ghat (:,:,:) this % wk_3d = g call this % fftf () ghat = this % wk_3d end subroutine zfft_3d !++++++++++ Backward FFT complex to complex   ++++++++++++++++ subroutine izfft_1d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: g (:) complex ( pfdp ), intent ( in ) :: ghat (:) this % wk_1d = ghat call this % fftb () g = this % wk_1d end subroutine izfft_1d ! Take forward FFT subroutine izfft_2d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: g (:,:) complex ( pfdp ), intent ( in ) :: ghat (:,:) this % wk_2d = ghat call this % fftb () g = this % wk_2d end subroutine izfft_2d subroutine izfft_3d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: g (:,:,:) complex ( pfdp ), intent ( in ) :: ghat (:,:,:) this % wk_3d = ghat call this % fftb () g = this % wk_3d end subroutine izfft_3d ! Convolve g with spectral op and return in c subroutine conv_1d ( this , g , op , c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ) :: g (:) complex ( pfdp ), intent ( in ) :: op (:) real ( pfdp ), intent ( inout ) :: c (:) this % wk_1d = g call this % fftf () this % wk_1d = this % wk_1d * op call this % fftb () c = real ( this % wk_1d , pfdp ) end subroutine conv_1d ! Convolve g with spectral op and return in c subroutine conv_2d ( this , g , op , c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:,:) complex ( pfdp ), intent ( in ) :: op (:,:) real ( pfdp ), intent ( inout ) :: c (:,:) this % wk_2d = g ! Compute Convolution call this % fftf () this % wk_2d = this % wk_2d * op call this % fftb () c = real ( this % wk_2d , pfdp ) end subroutine conv_2d subroutine conv_3d ( this , g , op , c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:,:,:) complex ( pfdp ), intent ( in ) :: op (:,:,:) real ( pfdp ), intent ( inout ) :: c (:,:,:) this % wk_3d = g call this % fftf () this % wk_3d = this % wk_3d * op call this % fftb () c = real ( this % wk_3d , pfdp ) end subroutine conv_3d ! Compute in real space subroutine zconv_1d ( this , ghat , op , chat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: ghat (:), op (:) complex ( pfdp ), intent ( inout ) :: chat (:) this % wk_1d = ghat call this % fftb () this % wk_1d = this % wk_1d * op call this % fftf () chat = this % wk_1d end subroutine zconv_1d subroutine zconv_2d ( this , ghat , op , chat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: ghat (:,:), op (:,:) complex ( pfdp ), intent ( inout ) :: chat (:,:) this % wk_2d = ghat call this % fftb () this % wk_2d = this % wk_2d * op call this % fftf () chat = this % wk_2d end subroutine zconv_2d subroutine zconv_3d ( this , ghat , op , chat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: ghat (:,:,:), op (:,:,:) complex ( pfdp ), intent ( inout ) :: chat (:,:,:) this % wk_3d = ghat call this % fftb () this % wk_3d = this % wk_3d * op call this % fftf () chat = this % wk_3d end subroutine zconv_3d subroutine make_lap_1d ( this , lap ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:) integer :: i , nx real ( pfdp ) :: kx , Lx nx = this % nx Lx = this % Lx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i ) = - kx ** 2 end do end subroutine make_lap_1d subroutine make_deriv_1d ( this , ddx ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: ddx (:) integer :: i , nx real ( pfdp ) :: kx , Lx nx = this % nx Lx = this % Lx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if ddx ( i ) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do end subroutine make_deriv_1d subroutine make_lap_2d ( this , lap ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:) integer :: i , j , nx , ny real ( pfdp ) :: kx , ky , Lx , Ly nx = this % nx ny = this % ny Lx = this % Lx Ly = this % Ly do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i , j ) = - ( kx ** 2 + ky ** 2 ) end do end do end subroutine make_lap_2d subroutine make_deriv_2d ( this , deriv , dir ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:) integer , intent ( in ) :: dir integer :: i , j , nx , ny real ( pfdp ) :: kx , ky , Lx , Ly nx = this % nx ny = this % ny Lx = this % Lx Ly = this % Ly do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if if ( dir . eq . 1 ) then deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * kx else deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * ky endif end do end do end subroutine make_deriv_2d subroutine make_deriv_3d ( this , deriv , dir ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:,:) integer , intent ( in ) :: dir integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz , Lx , Ly , Lz nx = this % nx ny = this % ny nz = this % nz Lx = this % Lx Ly = this % Ly Lz = this % Lz select case ( dir ) case ( 1 ) do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if deriv ( i ,:,:) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do case ( 2 ) do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if deriv (:, j ,:) = ( 0.0_pfdp , 1.0_pfdp ) * ky end do case ( 3 ) do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / Lz * dble ( k - 1 ) else kz = two_pi / Lz * dble ( - nz + k - 1 ) end if deriv (:,:, k ) = ( 0.0_pfdp , 1.0_pfdp ) * kz end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , dir ) end select end subroutine make_deriv_3d subroutine make_lap_3d ( this , lap ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:,:) integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz , Lx , Ly , Lz nx = this % nx ny = this % ny nz = this % nz Lx = this % Lx Ly = this % Ly Lz = this % Lz do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / Lz * dble ( k - 1 ) else kz = two_pi / Lz * dble ( - nz + k - 1 ) end if do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i , j , k ) = - ( kx ** 2 + ky ** 2 + kz ** 2 ) end do end do end do end subroutine make_lap_3d !  Interp routines that take a coarse vector and produce a fine subroutine restrict_1d ( this , yvec_f , yvec_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), pointer :: yvec_f (:), yvec_c (:) integer :: nx_f , nx_c , irat nx_f = size ( yvec_f ) nx_c = size ( yvec_c ) irat = nx_f / nx_c yvec_c = yvec_f ( :: irat ) end subroutine restrict_1d subroutine restrict_2d ( this , yvec_f , yvec_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), pointer :: yvec_f (:,:), yvec_c (:,:) integer :: nx_f ( 2 ), nx_c ( 2 ), irat , jrat nx_f = shape ( yvec_f ) nx_c = shape ( yvec_c ) irat = nx_f ( 1 ) / nx_c ( 1 ) jrat = nx_f ( 2 ) / nx_c ( 2 ) yvec_c = yvec_f ( :: irat , :: jrat ) end subroutine restrict_2d subroutine restrict_3d ( this , yvec_f , yvec_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), pointer :: yvec_f (:,:,:), yvec_c (:,:,:) integer :: nx_f ( 3 ), nx_c ( 3 ) integer :: irat , jrat , krat nx_f = shape ( yvec_f ) nx_c = shape ( yvec_c ) irat = nx_f ( 1 ) / nx_c ( 1 ) jrat = nx_f ( 2 ) / nx_c ( 2 ) krat = nx_f ( 3 ) / nx_c ( 3 ) yvec_c = yvec_f ( :: irat , :: jrat , :: krat ) end subroutine restrict_3d subroutine zrestrict_1d ( this , yhat_f , yhat_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:), yhat_c (:) integer :: nx_f , nx_c nx_f = size ( yhat_f ) nx_c = size ( yhat_c ) yhat_c = 0.0_pfdp yhat_c ( 1 : nx_c / 2 ) = yhat_f ( 1 : nx_c / 2 ) yhat_c ( nx_c / 2 + 2 : nx_c ) = yhat_f ( nx_f - nx_c / 2 + 2 : nx_f ) end subroutine zrestrict_1d subroutine zrestrict_2d ( this , yhat_f , yhat_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:), yhat_c (:,:) integer :: nx_f ( 2 ), nx_c ( 2 ), nf1 , nf2 , nc1 , nc2 nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 yhat_c = 0.0_pfdp yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) = yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 ) = yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 ) yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 )) = yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 )) yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 )) = yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 )) end subroutine zrestrict_2d subroutine zrestrict_3d ( this , yhat_f , yhat_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:,:), yhat_c (:,:,:) integer :: nx_f ( 3 ), nx_c ( 3 ), nf1 , nf2 , nf3 , nc1 , nc2 , nc3 yhat_c = 0.0_pfdp nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nf3 = nx_f ( 3 ) - nx_c ( 3 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 nc3 = nx_c ( 3 ) / 2 + 2 yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) = yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) = yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) = yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) = yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) end subroutine zrestrict_3d end module pf_mod_fft_abs","tags":"","loc":"sourcefile/pf_fft.f90.html","title":"pf_fft.f90 – LibPFASST"},{"text":"High level routines for PFASST data type Contents Modules pf_mod_pfasst Source Code pf_pfasst.f90 Source Code !!  High level routines for PFASST data type ! ! This file is part of LIBPFASST. ! !>  Module containing the routines to create, setup, and destroy the main data structure in PFASST module pf_mod_pfasst use pf_mod_dtype use pf_mod_comm_mpi use pf_mod_utils use pf_mod_results implicit none contains !> Create a PFASST object subroutine pf_pfasst_create ( pf , comm , nlevels , fname , nocmd ) use pf_mod_hooks , only : PF_MAX_HOOK type ( pf_pfasst_t ), intent ( inout ) :: pf !! Main pfasst object type ( pf_comm_t ), intent ( inout ), target :: comm !! Communicator integer , intent ( in ), optional :: nlevels !! number of pfasst levels character ( len =* ), intent ( in ), optional :: fname !! Input file for pfasst parameters logical , intent ( in ), optional :: nocmd !! Determines if command line variables are to be read logical :: read_cmd !! Local version of nocmd integer :: ierr integer :: l !!  Loop variable for levels if ( present ( nlevels )) pf % nlevels = nlevels pf % outdir = \"dat/\" !> gather some input from a file and command line read_cmd = . true . if ( present ( nocmd )) then if ( nocmd ) read_cmd = . false . end if if ( present ( fname )) then !!  fname  present,  read inputs from a file (and maybe command line) call pf_read_opts ( pf , read_cmd , fname ) else !!  fname not present, only call read_opts if we want command line read if ( read_cmd ) call pf_read_opts ( pf , read_cmd ) end if !>  set communicator pf % comm => comm !>  Set up the mpi communicator call pf_mpi_setup ( pf % comm , pf , ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"ERROR: mpi_setup failed\" ) if ( pf % rank < 0 ) then call pf_stop ( __ FILE__ , __ LINE__ ,& \"Invalid PF rank: did you call setup correctly?\" ) end if !>  allocate level pointers allocate ( pf % levels ( pf % nlevels ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error\" , pf % nlevels ) !>  loop over levels to set parameters do l = 1 , pf % nlevels pf % levels ( l )% index = l pf % levels ( l )% nsweeps = pf % nsweeps ( l ) pf % levels ( l )% nsweeps_pred = pf % nsweeps_pred ( l ) pf % levels ( l )% nnodes = pf % nnodes ( l ) pf % levels ( l )% Finterp = pf % Finterp pf % levels ( l )% nsteps_rk = pf % nsteps_rk ( l ) end do !>  allocate hooks allocate ( pf % hooks ( pf % nlevels , PF_MAX_HOOK , PF_MAX_HOOKS ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error hooks\" ) allocate ( pf % nhooks ( pf % nlevels , PF_MAX_HOOK ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error nhooks\" ) pf % nhooks = 0 !>  allocate status allocate ( pf % state , stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error state\" ) pf % state % pstatus = 0 pf % state % status = 0 end subroutine pf_pfasst_create !> Helper routine to set the size and mpi buffer length for regular grids subroutine pf_level_set_size ( pf , level_index , shape_in , buflen_in ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  Main pfasst structure integer , intent ( in ) :: level_index integer , intent ( in ) :: shape_in (:) integer , intent ( in ), optional :: buflen_in integer :: buflen_local ! Allocate and set shape array for the level allocate ( pf % levels ( level_index )% shape ( size ( shape_in ))) pf % levels ( level_index )% shape = shape_in !  Set the size of mpi buffer buflen_local = product ( shape_in ) if ( present ( buflen_in )) buflen_local = buflen_in pf % levels ( level_index )% mpibuflen = buflen_local end subroutine pf_level_set_size !> Setup both the PFASST object and the comm object subroutine pf_pfasst_setup ( pf ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  Main pfasst structure class ( pf_level_t ), pointer :: lev_fine , lev_coarse !!  Pointers to level structures for brevity integer :: l !!  Level loop index integer :: ierr !!  error flag !>  loop over levels to set parameters do l = 1 , pf % nlevels call pf_level_setup ( pf , l ) end do !>  set default finest level pf % state % finest_level = pf % nlevels !>  Loop over levels setting interpolation and restriction matrices (in time) do l = pf % nlevels , 2 , - 1 lev_fine => pf % levels ( l ); lev_coarse => pf % levels ( l - 1 ) allocate ( lev_fine % tmat ( lev_fine % nnodes , lev_coarse % nnodes ), stat = ierr ) if ( ierr /= 0 ) & call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" , lev_fine % nnodes ) allocate ( lev_fine % rmat ( lev_coarse % nnodes , lev_fine % nnodes ), stat = ierr ) if ( ierr /= 0 ) & call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" , lev_fine % nnodes ) ! with the RK stepper, no need to interpolate and restrict in time ! we only copy the first node and last node betweem levels if ( pf % use_rk_stepper . eqv . . true .) then lev_fine % tmat = 0.0_pfdp lev_fine % rmat = 0.0_pfdp lev_fine % tmat ( 1 , 1 ) = 1.0_pfdp lev_fine % tmat ( lev_fine % nnodes , lev_coarse % nnodes ) = 1.0_pfdp lev_fine % rmat ( 1 , 1 ) = 1.0_pfdp lev_fine % rmat ( lev_coarse % nnodes , lev_fine % nnodes ) = 1.0_pfdp else ! else compute the interpolation matrix call pf_time_interpolation_matrix ( lev_fine % nodes , lev_fine % nnodes , lev_coarse % nodes , lev_coarse % nnodes , lev_fine % tmat ) call pf_time_interpolation_matrix ( lev_coarse % nodes , lev_coarse % nnodes , lev_fine % nodes , lev_fine % nnodes , lev_fine % rmat ) endif end do end subroutine pf_pfasst_setup !> Setup (allocate) PFASST level !! If the level is already setup, calling this again will allocate !! (or deallocate) tauQ appropriately. subroutine pf_level_setup ( pf , level_index ) use pf_mod_quadrature type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  Main pfasst structure integer , intent ( in ) :: level_index !!  level to set up class ( pf_level_t ), pointer :: lev !!  Level to set up integer :: mpibuflen , nnodes , npieces , nnodes0 integer :: i , ierr lev => pf % levels ( level_index ) !!  Assign level pointer !> do some sanity checks mpibuflen = lev % mpibuflen if ( mpibuflen <= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , 'allocate fail' , mpibuflen ) nnodes = lev % nnodes if ( nnodes <= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , 'allocate fail' , nnodes ) lev % residual = - 1.0_pfdp !> (re)allocate tauQ if (( lev % index < pf % nlevels ) . and . (. not . allocated ( lev % tauQ ))) then call lev % ulevel % factory % create_array ( lev % tauQ , nnodes - 1 , lev % index , lev % shape ) end if !> skip the rest if we're already allocated if ( lev % allocated ) return lev % allocated = . true . !> allocate flat buffers for send, and recv allocate ( lev % send ( mpibuflen ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) allocate ( lev % recv ( mpibuflen ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) !> allocate nodes, flags, and integration matrices allocate ( lev % nodes ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) allocate ( lev % nflags ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) lev % nflags = 0 !>  Allocate and compute all the matrices allocate ( lev % sdcmats , stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error sdcmats\" ) call pf_init_sdcmats ( pf , lev % sdcmats , nnodes , lev % nflags ) lev % nodes = lev % sdcmats % qnodes !>  initialize sweeper lev % ulevel % sweeper % use_LUq = pf % use_LUq call lev % ulevel % sweeper % initialize ( pf , level_index ) if ( pf % use_rk_stepper ) call lev % ulevel % stepper % initialize ( pf , level_index ) !> allocate solution and function arrays npieces = lev % ulevel % sweeper % npieces call lev % ulevel % factory % create_array ( lev % Q , nnodes , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( lev % Fflt , nnodes * npieces , lev % index , lev % shape ) do i = 1 , nnodes * npieces call lev % Fflt ( i )% setval ( 0.0_pfdp , 0 ) end do lev % F ( 1 : nnodes , 1 : npieces ) => lev % Fflt call lev % ulevel % factory % create_array ( lev % I , nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( lev % R , nnodes - 1 , lev % index , lev % shape ) !  Need space for old function values in im sweepers call lev % ulevel % factory % create_array ( lev % pFflt , nnodes * npieces , lev % index , lev % shape ) lev % pF ( 1 : nnodes , 1 : npieces ) => lev % pFflt if ( lev % index < pf % nlevels ) then call lev % ulevel % factory % create_array ( lev % pQ , nnodes , lev % index , lev % shape ) end if call lev % ulevel % factory % create_single ( lev % qend , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( lev % q0 , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( lev % q0_delta , lev % index , lev % shape ) end subroutine pf_level_setup !> Deallocate PFASST object subroutine pf_pfasst_destroy ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  Main pfasst structure integer :: l !>  destroy all levels do l = 1 , pf % nlevels call pf_level_destroy ( pf , l ) end do !>  deallocate pfasst pointer arrays deallocate ( pf % levels ) deallocate ( pf % hooks ) deallocate ( pf % nhooks ) deallocate ( pf % state ) call pf_mpi_destroy ( pf % comm ) end subroutine pf_pfasst_destroy !> Deallocate PFASST level subroutine pf_level_destroy ( pf , level_index ) use pf_mod_quadrature type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  Main pfasst structure integer , intent ( in ) :: level_index integer :: npieces !!  local copy of number of function pieces class ( pf_level_t ), pointer :: lev !!  points to current level lev => pf % levels ( level_index ) !!  Assign level pointer if (. not . lev % allocated ) return !> deallocate flat buffers for communcition deallocate ( lev % send ) deallocate ( lev % recv ) !> deallocate nodes, flags, and integration matrices deallocate ( lev % nodes ) deallocate ( lev % nflags ) call pf_destroy_sdcmats ( lev % sdcmats ) deallocate ( lev % sdcmats ) !> deallocate solution and function storage npieces = lev % ulevel % sweeper % npieces if (( lev % index < pf % nlevels ) . and . allocated ( lev % tauQ )) then call lev % ulevel % factory % destroy_array ( lev % tauQ ) end if call lev % ulevel % factory % destroy_array ( lev % Q ) call lev % ulevel % factory % destroy_array ( lev % Fflt ) call lev % ulevel % factory % destroy_array ( lev % I ) call lev % ulevel % factory % destroy_array ( lev % R ) call lev % ulevel % factory % destroy_array ( lev % pFflt ) if ( lev % index < pf % nlevels ) then call lev % ulevel % factory % destroy_array ( lev % pQ ) end if if ( lev % interp_workspace_allocated . eqv . . true .) then call lev % ulevel % factory % destroy_array ( lev % c_delta ) call lev % ulevel % factory % destroy_array ( lev % cf_delta ) lev % interp_workspace_allocated = . false . endif !> destroy the sweeper call lev % ulevel % sweeper % destroy ( pf , level_index ) !> deallocate misc. arrays if ( allocated ( lev % shape )) then deallocate ( lev % shape ) end if if ( allocated ( lev % tmat )) then deallocate ( lev % tmat ) end if if ( allocated ( lev % rmat )) then deallocate ( lev % rmat ) end if end subroutine pf_level_destroy !>  Subroutine to read pfasst options from file and command line subroutine pf_read_opts ( pf , read_cmd , fname ) type ( pf_pfasst_t ), intent ( inout ) :: pf logical , intent ( in ) :: read_cmd character ( len =* ), intent ( in ), optional :: fname ! local versions of pfasst parameters integer :: niters , nlevels , qtype integer :: nsweeps ( PF_MAXLEVS ) integer :: nsweeps_pred ( PF_MAXLEVS ) integer :: nnodes ( PF_MAXLEVS ) integer :: nsteps_rk ( PF_MAXLEVS ) real ( pfdp ) :: abs_res_tol , rel_res_tol logical :: PFASST_pred , RK_pred , pipeline_pred integer :: nsweeps_burn , q0_style , taui0 logical :: Vcycle , Finterp , use_LUq , use_Sform logical :: debug , use_rk_stepper logical :: save_timings , echo_timings , save_residuals , save_errors logical :: use_no_left_q , use_composite_nodes , use_proper_nodes ! stuff for reading the command line integer , parameter :: un = 9 integer :: i , ios , stat character ( len = 128 ) :: arg character ( len = 256 ) :: istring ! stores command line argument character ( len = 1024 ) :: message ! use for i/o error messages character ( len = 256 ) :: outdir !> define the namelist for reading namelist / pf_params / niters , nlevels , qtype , nsweeps , nsweeps_pred , nnodes , nsteps_rk , abs_res_tol , rel_res_tol namelist / pf_params / PFASST_pred , RK_pred , pipeline_pred , nsweeps_burn , q0_style , taui0 namelist / pf_params / Vcycle , Finterp , use_LUq , use_Sform , echo_timings , debug , save_timings , save_residuals , save_errors , use_rk_stepper namelist / pf_params / use_no_left_q , use_composite_nodes , use_proper_nodes , outdir !> set local variables to pf_pfasst defaults nlevels = pf % nlevels niters = pf % niters qtype = pf % qtype nsweeps = pf % nsweeps nsweeps_pred = pf % nsweeps_pred nnodes = pf % nnodes abs_res_tol = pf % abs_res_tol rel_res_tol = pf % rel_res_tol pfasst_pred = pf % pfasst_pred pipeline_pred = pf % pipeline_pred nsweeps_burn = pf % nsweeps_burn q0_style = pf % q0_style Vcycle = pf % Vcycle Finterp = pf % Finterp use_LUq = pf % use_LUq use_Sform = pf % use_Sform taui0 = pf % taui0 outdir = pf % outdir debug = pf % debug save_residuals = pf % save_residuals save_errors = pf % save_errors save_timings = pf % save_timings echo_timings = pf % echo_timings nsteps_rk = pf % nsteps_rk rk_pred = pf % rk_pred use_rk_stepper = pf % use_rk_stepper use_no_left_q = pf % use_no_left_q use_composite_nodes = pf % use_composite_nodes use_proper_nodes = pf % use_proper_nodes !> open the file \"fname\" and read the pfasst namelist if ( present ( fname )) then open ( unit = un , file = fname , status = 'old' , action = 'read' ) read ( unit = un , nml = pf_params ) close ( unit = un ) end if !> overwrite parameters defined on  command line if ( read_cmd ) then i = 0 do call get_command_argument ( i , arg , status = stat ) if ( len_trim ( arg ) == 0 ) exit if ( i > 1 ) then istring = \"&pf_params \" // trim ( arg ) // \" /\" read ( istring , nml = pf_params , iostat = ios , iomsg = message ) ! internal read of namelist end if i = i + 1 end do end if !> re-assign the pfasst internals pf % nlevels = nlevels pf % niters = niters pf % qtype = qtype pf % nsweeps = nsweeps pf % nsweeps_pred = nsweeps_pred pf % nnodes = nnodes pf % abs_res_tol = abs_res_tol pf % rel_res_tol = rel_res_tol pf % pfasst_pred = pfasst_pred pf % pipeline_pred = pipeline_pred pf % nsweeps_burn = nsweeps_burn pf % q0_style = q0_style pf % Vcycle = Vcycle pf % Finterp = Finterp pf % use_LUq = use_LUq pf % use_Sform = use_Sform pf % taui0 = taui0 pf % outdir = outdir pf % debug = debug pf % echo_timings = echo_timings pf % save_residuals = save_residuals pf % save_timings = save_timings pf % save_errors = save_errors pf % use_rk_stepper = use_rk_stepper pf % nsteps_rk = nsteps_rk pf % rk_pred = rk_pred pf % use_no_left_q = use_no_left_q pf % use_composite_nodes = use_composite_nodes pf % use_proper_nodes = use_proper_nodes !>  Sanity check if ( pf % nlevels < 1 ) then call pf_stop ( __ FILE__ , __ LINE__ , 'Bad specification for nlevels' , pf % nlevels ) endif end subroutine pf_read_opts !>  Subroutine to write out run parameters subroutine pf_print_options ( pf , un_opt , show_mats_opt ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ), optional :: un_opt logical , intent ( in ), optional :: show_mats_opt integer :: un = 6 logical :: show_mats = . FALSE . integer :: l , i character ( 8 ) :: date character ( 10 ) :: time if ( pf % rank /= 0 ) return if ( present ( un_opt )) un = un_opt write ( un , * ) '==================================================' write ( un , * ) 'PFASST Configuration' write ( un , * ) '--------------------' call date_and_time ( date = date , time = time ) write ( un , * ) 'date:        ' , date write ( un , * ) 'time:        ' , time write ( un , * ) 'double precision:   ' , pfdp , '  bytes' write ( un , * ) 'quad precision:   ' , pfqp , '  bytes' write ( un , * ) 'nlevels:     ' , pf % nlevels , '! number of pfasst levels' write ( un , * ) 'nprocs:      ' , pf % comm % nproc , '! number of pfasst \"time\" processors' if ( pf % comm % nproc == 1 ) then write ( un , * ) '            ' , '             ' , ' ! since 1 time proc is being used, this is a serial sdc run' else write ( un , * ) '            ' , '             ' , ' ! since >1 time procs are being used, this is a parallel pfasst run' end if write ( un , * ) 'niters:      ' , pf % niters , '! maximum number of sdc/pfasst iterations' select case ( pf % qtype ) case ( SDC_GAUSS_LEGENDRE ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Legendre nodes are used' case ( SDC_GAUSS_LOBATTO ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Lobatto nodes are used' case ( SDC_GAUSS_RADAU ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Radua nodes are used' case ( SDC_CLENSHAW_CURTIS ) write ( un , * ) 'qtype:' , pf % qtype , '! Clenshaw Curtis nodes are used' case ( SDC_UNIFORM ) write ( un , * ) 'qtype:' , pf % qtype , '! Uniform  nodes are used' case ( SDC_CHEBYSHEV ) write ( un , * ) 'qtype:' , pf % qtype , '! Chebyshev  nodes are used' case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , pf % qtype ) end select if ( pf % use_proper_nodes ) write ( un , * ) 'Using proper node nesting' if ( pf % use_composite_nodes ) write ( un , * ) 'Using composite node nesting' if ( pf % use_no_left_q ) write ( un , * ) ' Skipping left end point in quadruture rule ' write ( un , * ) 'nnodes:      ' , pf % levels ( 1 : pf % nlevels )% nnodes , '! number of sdc nodes per level' write ( un , * ) 'mpibuflen:   ' , pf % levels ( 1 : pf % nlevels )% mpibuflen , '! size of data send between time steps' write ( un , * ) 'nsweeps:     ' , pf % levels ( 1 : pf % nlevels )% nsweeps , '! number of sdc sweeps performed per visit to each level' write ( un , * ) 'nsweeps_pred:     ' , pf % levels ( 1 : pf % nlevels )% nsweeps_pred , '! number of sdc sweeps in predictor' write ( un , * ) 'taui0:     ' , pf % taui0 , '! cutoff for tau correction' write ( un , * ) 'abs_res_tol:' , pf % abs_res_tol , '! absolute residual tolerance: ' write ( un , * ) 'rel_res_tol:' , pf % rel_res_tol , '! relative residual tolerance: ' if ( pf % use_Luq ) then write ( un , * ) 'Implicit matrix is LU  ' else write ( un , * ) 'Implicit matrix is backward Euler  ' end if if ( pf % use_Sform ) then write ( un , * ) 'The Smat form of stepping is being done' else write ( un , * ) 'The Qmat form of stepping is being done' end if if ( pf % Vcycle ) then write ( un , * ) 'V-cycling is on' else write ( un , * ) 'V-cycling is off, fine level is pipelining' end if if ( pf % rk_pred ) then write ( un , * ) 'Runge-Kutta used for predictor' else if ( pf % pipeline_pred ) then write ( un , * ) 'Predictor pipelining is ON    ' else write ( un , * ) 'Predictor pipelining is OFF    ' end if if ( pf % PFASST_pred ) then write ( un , * ) 'PFASST Predictor style  ' else write ( un , * ) 'Serial Predictor style  ' end if endif if ( pf % debug ) write ( un , * ) 'Debug mode is on ' write ( un , * ) 'Output directory ' , pf % outdir write ( un , * ) '' if ( present ( show_mats_opt )) show_mats = show_mats_opt if ( show_mats ) then do l = 1 , pf % nlevels print * , \"Level\" , l print * , \"-----------------\" print * , \"  nodes\" print * , pf % levels ( l )% nodes print * , \"  Q\" do i = 1 , pf % levels ( l )% nnodes - 1 print * , pf % levels ( l )% sdcmats % qmat ( i ,:) end do end do end if end subroutine pf_print_options !> Subroutine to make the matrices for interpolation  between noodes subroutine pf_time_interpolation_matrix ( f_nodes , f_nnodes , c_nodes , c_nnodes , tmat ) integer , intent ( in ) :: f_nnodes !!  number of nodes on fine level integer , intent ( in ) :: c_nnodes !!  number of nodes on coarse  level real ( pfdp ), intent ( in ) :: f_nodes ( 0 : f_nnodes - 1 ) !!  quadrature nodes on fine  level real ( pfdp ), intent ( in ) :: c_nodes ( 0 : c_nnodes - 1 ) !!  quadrature nodes on coarse  level real ( pfdp ), intent ( out ) :: tmat ( 0 : f_nnodes - 1 , 0 : c_nnodes - 1 ) !!  Interpolation matrix to compute integer :: i , j , k real ( pfqp ) :: xi , num , den do i = 0 , f_nnodes - 1 xi = real ( f_nodes ( i ), pfqp ) do j = 0 , c_nnodes - 1 den = 1.0_pfqp num = 1.0_pfqp do k = 0 , c_nnodes - 1 if ( k == j ) cycle den = den * real ( c_nodes ( j ) - c_nodes ( k ), pfqp ) num = num * real ( xi - c_nodes ( k ), pfqp ) end do tmat ( i , j ) = real ( num / den , pfdp ) end do end do end subroutine pf_time_interpolation_matrix !>  Subroutine to write out run parameters subroutine pf_initialize_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: level_index ALLOCATE ( pf % results ( pf % nlevels )) do level_index = 1 , pf % nlevels call initialize_results ( pf % results ( level_index ), pf % state % nsteps , pf % niters , pf % comm % nproc , pf % nsweeps ( level_index ), pf % rank , level_index , pf % outdir , pf % save_residuals ) end do end subroutine pf_initialize_results !>  Subroutine to write out run parameters subroutine pf_dump_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: level_index if ( pf % save_residuals ) then do level_index = 1 , pf % nlevels call dump_resids ( pf % results ( level_index )) end do end if if ( pf % save_errors ) then do level_index = 1 , pf % nlevels call dump_errors ( pf % results ( level_index )) end do end if if ( pf % save_timings ) then call dump_timings ( pf ) end if end subroutine pf_dump_results !>  Subroutine to destroy the results subroutine pf_destroy_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: level_index do level_index = 1 , pf % nlevels call destroy_results ( pf % results ( level_index )) end do end subroutine pf_destroy_results end module pf_mod_pfasst","tags":"","loc":"sourcefile/pf_pfasst.f90.html","title":"pf_pfasst.f90 – LibPFASST"},{"text":"Module of FFT based routines using fftw Contents Modules pf_mod_fftpackage Source Code pf_fftw.f90 Source Code !!  Module of FFT based routines using fftw !! ! This file is part of LIBPFASST. ! !>  Module for providing FFTs based on fftw !!  To use this module, fftw must be installed. !!  This can be done by the libpfasst make system with the comment !!   > make fftw3 module pf_mod_fftpackage use pf_mod_dtype use pf_mod_utils use pf_mod_fft_abs implicit none !  include 'fftw3.f03' !>  Variables and storage for FFTW type , extends ( pf_fft_abs_t ) :: pf_fft_t type ( c_ptr ) :: ffftw , ifftw !! fftw pointers real ( pfdp ) :: normfact !! normalization factor contains procedure :: fft_setup procedure :: fft_destroy procedure :: fftf procedure :: fftb !  Interpolate in spectral space procedure , private :: interp_1d , interp_2d , interp_3d , zinterp_1d , zinterp_2d , zinterp_3d generic :: interp => interp_1d , interp_2d , interp_3d , zinterp_1d , zinterp_2d , zinterp_3d end type pf_fft_t contains !> Initialize the package subroutine fft_setup ( this , grid_shape , dim , grid_size ) class ( pf_fft_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) integer :: nx , ny , nz real ( pfdp ) :: kx , ky type ( c_ptr ) :: wk this % dim = dim nx = grid_shape ( 1 ) this % nx = nx ! Defaults for grid_size this % Lx = 1.0_pfdp this % Ly = 1.0_pfdp this % Lz = 1.0_pfdp select case ( dim ) case ( 1 ) if ( present ( grid_size )) this % Lx = grid_size ( 1 ) this % normfact = real ( nx , pfdp ) wk = fftw_alloc_complex ( int ( nx , c_size_t )) call c_f_pointer ( wk , this % wk_1d , [ nx ]) this % ffftw = fftw_plan_dft_1d ( nx , & this % wk_1d , this % wk_1d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifftw = fftw_plan_dft_1d ( nx , & this % wk_1d , this % wk_1d , FFTW_BACKWARD , FFTW_ESTIMATE ) case ( 2 ) if ( present ( grid_size )) then this % Lx = grid_size ( 1 ) this % Ly = grid_size ( 2 ) end if ny = grid_shape ( 2 ) this % ny = ny this % normfact = real ( nx * ny , pfdp ) ! create in-place, complex fft plans wk = fftw_alloc_complex ( int ( nx * ny , c_size_t )) call c_f_pointer ( wk , this % wk_2d , [ nx , ny ]) this % ffftw = fftw_plan_dft_2d ( nx , ny , & this % wk_2d , this % wk_2d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifftw = fftw_plan_dft_2d ( nx , ny , & this % wk_2d , this % wk_2d , FFTW_BACKWARD , FFTW_ESTIMATE ) case ( 3 ) if ( present ( grid_size )) then this % Lx = grid_size ( 1 ) this % Ly = grid_size ( 2 ) this % Lz = grid_size ( 3 ) end if ny = grid_shape ( 2 ) nz = grid_shape ( 3 ) this % ny = ny this % nz = nz this % normfact = real ( nx * ny * nz , pfdp ) wk = fftw_alloc_complex ( int ( nx * ny * nz , c_size_t )) call c_f_pointer ( wk , this % wk_3d , [ nx , ny , nz ]) this % ffftw = fftw_plan_dft_3d ( nx , ny , nz , & this % wk_3d , this % wk_3d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifftw = fftw_plan_dft_3d ( nx , ny , nz , & this % wk_3d , this % wk_3d , FFTW_BACKWARD , FFTW_ESTIMATE ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_setup !>  Destroy the package subroutine fft_destroy ( this ) class ( pf_fft_t ), intent ( inout ) :: this call fftw_destroy_plan ( this % ffftw ) call fftw_destroy_plan ( this % ifftw ) select case ( this % dim ) case ( 1 ) deallocate ( this % wk_1d ) case ( 2 ) deallocate ( this % wk_2d ) case ( 3 ) deallocate ( this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_destroy !>  Routine to take foreward FFT subroutine fftf ( this ) class ( pf_fft_t ), intent ( inout ) :: this select case ( this % dim ) case ( 1 ) this % wk_1d = this % wk_1d / this % normfact call fftw_execute_dft ( this % ffftw , this % wk_1d , this % wk_1d ) case ( 2 ) this % wk_2d = this % wk_2d / this % normfact call fftw_execute_dft ( this % ffftw , this % wk_2d , this % wk_2d ) case ( 3 ) this % wk_3d = this % wk_3d / this % normfact call fftw_execute_dft ( this % ffftw , this % wk_3d , this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftf !>  Routine to take inverse or backward FFT subroutine fftb ( this ) class ( pf_fft_t ), intent ( inout ) :: this !  Normalize the fft select case ( this % dim ) case ( 1 ) call fftw_execute_dft ( this % ifftw , this % wk_1d , this % wk_1d ) case ( 2 ) call fftw_execute_dft ( this % ifftw , this % wk_2d , this % wk_2d ) case ( 3 ) call fftw_execute_dft ( this % ifftw , this % wk_3d , this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftb subroutine interp_1d ( this , yvec_c , fft_f , yvec_f ) !      use pf_mod_fftpackage, only: pf_fft_t !        class(pf_fft_abs_t), intent(inout) :: this class ( pf_fft_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f integer :: nx_f , nx_c complex ( pfdp ), pointer :: wk_f (:), wk_c (:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_1d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f ) end subroutine interp_1d subroutine interp_2d ( this , yvec_c , fft_f , yvec_f ) class ( pf_fft_t ), intent ( inout ) :: this !    class(pf_fft_abs_t), intent(inout) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:,:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:,:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f complex ( pfdp ), pointer :: wk_f (:,:), wk_c (:,:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_2d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f ) end subroutine interp_2d subroutine interp_3d ( this , yvec_c , fft_f , yvec_f ) class ( pf_fft_t ), intent ( inout ) :: this !   class(pf_fft_abs_t), intent(inout) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:,:,:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:,:,:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f complex ( pfdp ), pointer :: wk_f (:,:,:), wk_c (:,:,:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_3d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f ) end subroutine interp_3d !>  Interpolate from coarse  level to fine subroutine zinterp_1d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:), yhat_c (:) integer :: nx_f , nx_c nx_f = size ( yhat_f ) nx_c = size ( yhat_c ) yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c / 2 ) = yhat_c ( 1 : nx_c / 2 ) yhat_f ( nx_f - nx_c / 2 + 2 : nx_f ) = yhat_c ( nx_c / 2 + 2 : nx_c ) end subroutine zinterp_1d !>  Interpolate from coarse  level to fine subroutine zinterp_2d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:), yhat_c (:,:) integer :: nx_f ( 2 ), nx_c ( 2 ), nf1 , nf2 , nc1 , nc2 nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 )) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 )) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 )) end subroutine zinterp_2d !>  Interpolate from coarse  level to fine subroutine zinterp_3d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:,:), yhat_c (:,:,:) integer :: nx_f ( 3 ), nx_c ( 3 ), nf1 , nf2 , nf3 , nc1 , nc2 , nc3 nx_f = size ( yhat_f ) nx_c = size ( yhat_c ) yhat_f = 0.0_pfdp nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nf3 = nx_f ( 3 ) - nx_c ( 3 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 nc3 = nx_c ( 3 ) / 2 + 2 yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) end subroutine zinterp_3d end module pf_mod_fftpackage","tags":"","loc":"sourcefile/pf_fftw.f90.html","title":"pf_fftw.f90 – LibPFASST"},{"text":"Verlet type sweeper for 2nd order problems module Contents Modules pf_mod_verlet Source Code pf_verlet_sweeper.f90 Source Code !! Verlet type sweeper for 2nd order problems module ! ! This file is part of LIBPFASST. ! !> Verlet type sweeper for 2nd order problems !! !!  This is intended for Hamiltonian problems of the form !! !!    q'=p, p'=f(q)  !! !! or !! !!     x'=v, x''=f(x)  !! !!  So p is not momentum here, but velocity module pf_mod_verlet use pf_mod_dtype use pf_mod_utils implicit none !>  Verlet SDC sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_verlet_t integer :: whichQQ = 0 integer :: doLU real ( pfdp ) :: Htol , H0 !  Matrices real ( pfdp ), ALLOCATABLE :: Qmat (:,:) !  Spectral matrix for v real ( pfdp ), ALLOCATABLE :: QQmat (:,:) !  Spectral matrix for x real ( pfdp ), ALLOCATABLE :: Qver (:,:) !  Verlet matrix for v (Trapezoid) real ( pfdp ), ALLOCATABLE :: QQver (:,:) !  Verlet matrix for x real ( pfdp ), ALLOCATABLE :: Qtil (:,:) !  Approximate matrix for v real ( pfdp ), ALLOCATABLE :: QQtil (:,:) !  Approximate matrix for x real ( pfdp ), ALLOCATABLE :: DQver (:,:) !  Qmat-Qver real ( pfdp ), ALLOCATABLE :: DQQver (:,:) !  QQmat-QQver real ( pfdp ), ALLOCATABLE :: DQtil (:,:) !  Qmat-Qtil real ( pfdp ), ALLOCATABLE :: DQQtil (:,:) !  QQmat-QQtil real ( pfdp ), ALLOCATABLE :: bvec (:) !  Quadrature rule for v real ( pfdp ), ALLOCATABLE :: bbarvec (:) !  Quadrature rule for x real ( pfdp ), allocatable :: dtsdc (:) !  SDC step sizes real ( pfdp ), allocatable :: tsdc (:) !  SDC times logical :: iqend !  Decide whether to set qend by another Picard class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver procedure ( pf_hamiltonian_p ), deferred :: hamiltonian !!  Hamiltonian !>  Set the generic functions procedure :: sweep => verlet_sweep procedure :: initialize => verlet_initialize procedure :: evaluate => verlet_evaluate procedure :: integrate => verlet_integrate procedure :: residual => verlet_residual procedure :: spreadq0 => verlet_spreadq0 procedure :: evaluate_all => verlet_evaluate_all procedure :: destroy => verlet_destroy end type pf_verlet_t interface !>  This is the interface for the routine to compute the RHS function values !>  Evaluate f_piece(y), where piece is one or two subroutine pf_f_eval_p ( this , y , t , level_index , f ) !>  Evaluate f_piece(y), where piece is one or two import pf_verlet_t , pf_encap_t , pfdp class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value !       integer,    intent(in   ) :: piece           !!  Which piece to evaluate end subroutine pf_f_eval_p !>  Solve the equation y - dtq*f_2(y) =rhs subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece ) import pf_verlet_t , pf_encap_t , pfdp class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_2 of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_comp_p function pf_hamiltonian_p ( this , y , t , level_index ) result ( H ) import pf_verlet_t , pf_encap_t , pfdp class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Variable real ( pfdp ), intent ( in ) :: t !!  Time of solve integer , intent ( in ) :: level_index !!  Level index real ( pfdp ) :: H end function pf_hamiltonian_p end interface contains !----------------------------------------------------------------------------- !> Perform one SDC sweep on level level_index and set qend appropriately subroutine verlet_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: k , m , n , nnodes real ( pfdp ) :: t , dtmhalf , dtsq real ( pfdp ) :: H lev => pf % levels ( level_index ) !!  Assign level pointer nnodes = lev % nnodes call start_timer ( pf , TLEVEL + lev % index - 1 ) ! ! check hamiltonian ! !    call this%hamiltonian(t0+dt, Lev%qend, encapctx%m,H) !    print *,'Ham=',H,this%Htol,this%H0 !    if ((pf%state%iter > 1) .and. (abs(H-this%H0) < this%Htol)) then !       call Lev%encap%copy(Lev%qend, Lev%Q(nnodes)) !          print *, 'Skipping SDC sweep' !       return !    end if ! ! compute integrals and add fas correction ! dtsq = dt * dt do k = 1 , nsweeps pf % state % sweep = k do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) if ( pf % state % iter . eq . 1 ) then !  Do verlet on the first iteration do n = 1 , nnodes call lev % I ( m )% axpy ( dt * this % DQver ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dtsq * this % DQQver ( m , n ), lev % F ( n , 1 ), 2 ) end do else do n = 1 , nnodes call lev % I ( m )% axpy ( dt * this % DQtil ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dtsq * this % DQQtil ( m , n ), lev % F ( n , 1 ), 2 ) end do end if if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) end if t = t0 ! do the sub-stepping in sweep do m = 1 , nnodes - 1 t = t + dt * this % dtsdc ( m ) dtmhalf = 0.5d0 * dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp ) !  Lower triangular verlet to  new piece if ( pf % state % iter . eq . 1 ) then do n = 1 , m call this % rhs % axpy ( dtsq * this % QQver ( m , n ), lev % F ( n , 1 ), 2 ) end do else do n = 1 , m call this % rhs % axpy ( dtsq * this % QQtil ( m , n ), lev % F ( n , 1 ), 2 ) end do endif !>  Add the integral term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) !>  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 2 ) !>  Add the dt*v_0 call this % rhs % axpy ( t - t0 , lev % Q ( 1 ), 12 ) !  Update position term call lev % Q ( m + 1 )% copy ( this % rhs , 2 ) !  update function values call this % f_eval ( Lev % Q ( m + 1 ), t , lev % index , Lev % F ( m + 1 , 1 )) !  Now do the v peice call this % rhs % setval ( 0.0_pfdp , 1 ) !  Lower triangular verlet to  new piece if ( pf % state % iter . eq . 1 ) then do n = 1 , m + 1 call this % rhs % axpy ( dt * this % Qver ( m , n ), Lev % F ( n , 1 ), 1 ) end do else do n = 1 , m + 1 call this % rhs % axpy ( dt * this % Qtil ( m , n ), Lev % F ( n , 1 ), 1 ) end do end if call this % rhs % axpy ( 1.0_pfdp , Lev % I ( m ), 1 ); call this % rhs % axpy ( 1.0_pfdp , Lev % Q ( 1 ), 1 ) !  Start m+1 with value from 1 call lev % Q ( m + 1 )% copy ( this % rhs , 1 ) end do !!  End substep loop !  Set the value of qend !  If Gauss nodes, we must do integration !  unless the sweep was an initial Verlet !  For Lobatto nodes, we have a choice of whether to just use the !  value at the last node, or recompute it. !       if (this%iqend .and. pf%state%iter .gt. 1) then !          call Lev%encap%copy(Lev%qend, Lev%Q(1)) !          call Lev%encap%axpy(Lev%qend, dt, Lev%Q(1), 12)  !  Add the dt*v_0 term !          m = nnodes !          do n = 1, nnodes !             call Lev%encap%axpy(Lev%qend, dt*this%Qmat(m,n), Lev%F(n,1),1) !             call Lev%encap%axpy(Lev%qend, dtsq*this%QQmat(m,n), Lev%F(n,1),2) !          end do !          if (associated(Lev%tauQ)) then !             call Lev%encap%axpy(Lev%qend, 1.0_pfdp, Lev%tauQ(nnodes-1)) !             !          print *,'XXXXXXXXXXX  need code in verlet.f90' !          end if !       else !          call Lev%encap%copy(Lev%qend, Lev%Q(nnodes)) !       end if call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! end loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine verlet_sweep !----------------------------------------------------------------------------- !> Initialize integration matrices subroutine verlet_initialize ( this , pf , level_index ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index integer :: i , j , nnodes , ierr real ( pfdp ), allocatable :: qtemp (:,:) real ( pfdp ), allocatable :: qtemp2 (:,:) type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer this % npieces = 1 nnodes = Lev % nnodes allocate ( this % Qmat ( nnodes - 1 , nnodes ), stat = ierr ) !  0  to node integral if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qmat\" allocate ( this % QQmat ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node double integral (like Qmat*Qmat) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQmat\" allocate ( this % Qtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0  to node integral  approximation of Qmat if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qtil\" allocate ( this % QQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node QQmat  aproximation if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQtil\" allocate ( this % Qver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node verlet  aproximation (trap) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qver\" allocate ( this % QQver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node verlet  aproximation if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQver\" allocate ( this % DQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node Qmat-Qtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQtil\" allocate ( this % DQQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  node to node QQmat-QQtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQQtil\" allocate ( this % DQver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node Qmat-Qtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQtil\" allocate ( this % DQQver ( nnodes - 1 , nnodes ), stat = ierr ) !  node to node QQmat-QQtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQQtil\" allocate ( this % bvec ( nnodes ), stat = ierr ) !  Integration rule for v if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DStil\" allocate ( this % bbarvec ( nnodes ), stat = ierr ) !  Integration rule for x if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DSStil\" allocate ( this % dtsdc ( nnodes - 1 ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for dtsdc\" allocate ( this % tsdc ( nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for tsdc\" !>  Array of substep sizes this % dtsdc = lev % sdcmats % qnodes ( 2 : nnodes ) - lev % sdcmats % qnodes ( 1 : nnodes - 1 ) this % tsdc = lev % sdcmats % qnodes - lev % sdcmats % qnodes ( 1 ) !  Build Q from qmat this % Qmat = lev % sdcmats % qmat !   I just use qmat now? !  The quadrature rule is the last row of Q this % bvec = this % Qmat ( nnodes - 1 ,:); allocate ( qtemp ( nnodes , nnodes ), stat = ierr ) allocate ( qtemp2 ( nnodes , nnodes ), stat = ierr ) !  form the QQ matrix depending on what you want select case ( this % whichQQ ) case ( 0 ) !  Collocation (make it the product) print * , 'Making QQ by collocation Q*Q' print * , size ( this % Qmat ) qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = lev % sdcmats % qmat qtemp = matmul ( qtemp , qtemp ) this % QQmat = qtemp ( 2 : nnodes ,:) print * , shape ( this % QQmat ) case ( 1 ) !  Make the pair like in Lobatto A/B pair print * , 'Making QQ by collocation Lobatto pair' qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = this % Qmat qtemp2 = 0.0_pfdp do i = 1 , nnodes do j = 1 , nnodes qtemp2 ( i , j ) = this % bvec ( j ) * ( 1.0_pfdp - qtemp ( j , i ) / this % bvec ( i )) end do end do qtemp2 = matmul ( qtemp , qtemp2 ) this % QQmat = 0.0_pfdp this % QQmat = qtemp2 ( 2 : nnodes ,:) this % bbarvec = this % QQmat ( nnodes - 1 ,:); case ( 2 ) !  Make the pair like in Lobatto B/A pair print * , 'Error Making QQ by collocation Lobatto pair' !!$       do i = 1,nnodes !!$          do j = 1,nnodes !!$             this%QQmat(i,j) =  this%bvec(j)*(1.0_pfdp-this%Qmat(j,i)/this%bvec(i)) !!$          end do !!$       end do !!$       this%QQmat = matmul(this%QQmat,this%Qmat) case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % whichQQ ) end select ! 0 to node this % Qver = lev % sdcmats % qmatTrap qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = lev % sdcmats % qmatFE qtemp2 ( 2 : nnodes ,:) = lev % sdcmats % qmatTrap qtemp = matmul ( qtemp , qtemp2 ) this % QQver = qtemp ( 2 : nnodes ,:) + 0.5_pfdp * lev % sdcmats % qmatFE * lev % sdcmats % qmatFE !  Get LU matrices if desired !    if (this%use_LUq .eq. 1) then !       print *,'Doing LU with doLU=',this%doLU !       call myLUq(SDCmats%qmat,SDCmats%qmatLU,nnodes,0) !       call pf_myLUexp(this%QQmat,L,U,nnodes,this%doLU) !      this%QQLU=U !      print *, 'U from LU',this%QQLU !   else this % Qtil = this % Qver !  Normal verlet all the time this % QQtil = this % QQver !  Normal verlet all the time !   end if this % Qver = 0.0d0 !  Normal verlet all the time this % QQver = 0.0d0 !  Normal verlet all the time this % Qtil = this % Qver !  Normal verlet all the time this % QQtil = this % QQver !  Normal verlet all the time ! !  Make differences this % DQtil = this % Qmat - this % Qtil this % DQQtil = this % QQmat - this % QQtil this % DQver = this % Qmat - this % Qver this % DQQver = this % QQmat - this % QQver deallocate ( qtemp ) deallocate ( qtemp2 ) !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine verlet_initialize !----------------------------------------------------------------------------- !> Integrate (t_n to node) subroutine verlet_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags integer :: n , m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) call fintSDC ( n )% axpy ( dt * this % tsdc ( n + 1 ), qSDC ( 1 ), 12 ) !  Add the dt*v_0 term do m = 1 , lev % nnodes call fintSDC ( n )% axpy ( dt * this % Qmat ( n , m ), fSDC ( m , 1 ), 1 ) call fintSDC ( n )% axpy ( dt * dt * this % QQmat ( n , m ), fSDC ( m , 1 ), 2 ) end do end do end subroutine verlet_integrate !----------------------------------------------------------------------------- !> Compute residual (t_n to node) subroutine verlet_residual ( this , pf , level_index , dt , flags ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags integer :: n , m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer call this % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I , flags ) ! add tau if ( level_index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine verlet_residual !----------------------------------------------------------------------------- ! Integrate to fill qend ! !  subroutine verlet_qend_integrate(Lev, dt) !    type(pf_level_t), intent(in) :: Lev !    real(pfdp),       intent(in) :: dt ! ! !    real(pfdp) :: dtsdc(1:Lev%nnodes-1) !    integer :: nnodes, m !    type(pf_verlet_t), pointer :: verlet !    call c_f_pointer(Lev%sweeper%sweeperctx, verlet) ! !    nnodes = Lev%nnodes ! !    dtsdc = dt * (Lev%nodes(2:Lev%nnodes) - Lev%nodes(1:Lev%nnodes-1)) !    call Lev%encap%copy(Lev%qend, Lev%Q(1)) !    call Lev%encap%axpy(Lev%qend, dt, Lev%Q(1), 12)  !  Add the dt*v_0 term !    do m = 1, Lev%nnodes !       call Lev%encap%axpy(Lev%qend, dt*Lev%qmat(nnodes,m), Lev%F(m,1),1) !       call Lev%encap%axpy(Lev%qend, dt*dt*thisSSmat(nnodes,m), Lev%F(m,1),2) !    end do !  end subroutine verlet_qend_integrate !----------------------------------------------------------------------------- !> Destroy Verlet sweeper matrices subroutine verlet_destroy ( this , pf , level_index ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer deallocate ( this % Qmat ) deallocate ( this % QQmat ) deallocate ( this % Qtil ) deallocate ( this % QQtil ) deallocate ( this % Qver ) deallocate ( this % QQver ) deallocate ( this % DQtil ) deallocate ( this % DQQtil ) deallocate ( this % DQver ) deallocate ( this % DQQver ) deallocate ( this % bvec ) deallocate ( this % bbarvec ) deallocate ( this % dtsdc ) deallocate ( this % tsdc ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine verlet_destroy !> Spread the intial data for Verlet sweepers subroutine verlet_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine verlet_spreadq0 !> Subroutine to evaluate function value at node m subroutine verlet_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine verlet_evaluate !> Subroutine to evaluate the function values at all nodes subroutine verlet_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine verlet_evaluate_all end module pf_mod_verlet","tags":"","loc":"sourcefile/pf_verlet_sweeper.f90.html","title":"pf_verlet_sweeper.f90 – LibPFASST"},{"text":"Magnus integrator sweeper module Contents Modules pf_mod_magnus_picard Source Code pf_magpicard_sweeper.f90 Source Code !!  Magnus integrator sweeper module ! ! This file is part of LIBPFASST. ! !>  This module implements fully implicit Magnus method using explicit Picard sweeping module pf_mod_magnus_picard use pf_mod_dtype use pf_mod_utils implicit none !>  Magnus Picard sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_magpicard_t real ( pfdp ), allocatable :: dtsdc (:) integer :: magnus_order , qtype real ( pfdp ) :: dt , commutator_coefs ( 9 , 3 , 4 ) complex ( pfdp ), allocatable :: commutators (:,:,:) class ( pf_encap_t ), allocatable :: omega (:), time_ev_op (:) contains procedure :: sweep => magpicard_sweep procedure :: initialize => magpicard_initialize procedure :: evaluate => magpicard_evaluate procedure :: integrate => magpicard_integrate procedure :: residual => magpicard_residual procedure :: spreadq0 => magpicard_spreadq0 procedure :: evaluate_all => magpicard_evaluate_all procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_compute_single_commutators_p ), deferred :: compute_single_commutators procedure ( pf_compute_omega_p ), deferred :: compute_omega procedure ( pf_propagate_solution_p ), deferred :: propagate_solution procedure :: destroy => magpicard_destroy procedure :: magpicard_destroy procedure :: magpicard_initialize end type pf_magpicard_t interface subroutine pf_f_eval_p ( this , y , t , level , f ) import pf_magpicard_t , pf_encap_t , pfdp class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: f end subroutine pf_f_eval_p subroutine pf_compute_single_commutators_p ( this , f ) import pf_magpicard_t , pf_encap_t , pfdp class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: f (:,:) end subroutine pf_compute_single_commutators_p subroutine pf_compute_omega_p ( this , omega , integrals , f , nodes , qmat , dt , this_node , coefs ) import pf_magpicard_t , pf_encap_t , pfdp class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: omega class ( pf_encap_t ), intent ( inout ) :: f (:,:), integrals (:) real ( pfdp ), intent ( in ) :: coefs (:,:), nodes (:), qmat (:,:), dt integer , intent ( in ) :: this_node end subroutine pf_compute_omega_p subroutine pf_propagate_solution_p ( this , sol_t0 , sol_tn , omega , level ) import pf_magpicard_t , pf_encap_t , pfdp class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: sol_t0 class ( pf_encap_t ), intent ( inout ) :: omega class ( pf_encap_t ), intent ( inout ) :: sol_tn integer , intent ( in ) :: level end subroutine pf_propagate_solution_p end interface contains ! Perform one SDC sweep on level Lev and set qend appropriately. subroutine magpicard_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt , t0 integer , intent ( in ) :: level_index integer , intent ( in ) :: nsweeps integer , optional , intent ( in ) :: flags class ( pf_level_t ), pointer :: lev integer :: m , nnodes , k real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call call_hooks ( pf , level_index , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 ) call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps pf % state % sweep = k ! Copy values into residual do m = 1 , nnodes - 1 call lev % R ( m )% copy ( lev % Q ( m + 1 )) end do t = t0 !$omp parallel do private(m, t) do m = 1 , nnodes !          t = t + dt*this%dtsdc(m) t = t0 + dt * lev % nodes ( m ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end do !$omp end parallel do !$omp barrier call magpicard_integrate ( this , pf , level_index , lev % Q , lev % F , dt , lev % I ) if ( this % magnus_order > 1 . and . nnodes > 2 ) then call start_timer ( pf , TAUX ) call this % compute_single_commutators ( lev % F ) call end_timer ( pf , TAUX ) endif !! this loop not OMP'd because the deferred procs are OMP'd do m = 1 , nnodes - 1 call start_timer ( pf , TAUX + 1 ) call this % compute_omega ( this % omega ( m ), lev % I , lev % F , & lev % nodes , lev % sdcmats % qmat , dt , m , this % commutator_coefs (:,:, m )) call end_timer ( pf , TAUX + 1 ) end do !$omp parallel do private(m) do m = 1 , nnodes - 1 call this % propagate_solution ( lev % Q ( 1 ), lev % Q ( m + 1 ), this % omega ( m ), lev % index ) end do !$omp end parallel do call pf_residual ( pf , level_index , dt ) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! Loop over sweeps call lev % qend % copy ( lev % Q ( nnodes )) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine magpicard_sweep subroutine magpicard_initialize ( this , pf , level_index ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize integer :: m , nnodes type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer this % commutator_coefs = 0.0_pfdp this % npieces = 1 nnodes = lev % nnodes allocate ( this % dtsdc ( nnodes - 1 )) this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) !  SDC time step size (unscaled) call get_commutator_coefs ( this % qtype , nnodes , this % dt , this % commutator_coefs ) call lev % ulevel % factory % create_array ( this % omega , nnodes - 1 , & lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % time_ev_op , nnodes - 1 , & lev % index , lev % shape ) do m = 1 , nnodes - 1 call this % omega ( m )% setval ( 0.0_pfdp ) call this % time_ev_op ( m )% setval ( 0.0_pfdp ) end do end subroutine magpicard_initialize !> Compute SDC integral !>  fintSDC = \\int_{t_n}&#94;{t_m} fSDC dt subroutine magpicard_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: j , m type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer do m = 1 , lev % nnodes - 1 call fintSDC ( m )% setval ( 0.0_pfdp ) do j = 1 , lev % nnodes call fintSDC ( m )% axpy ( dt * lev % sdcmats % qmat ( m , j ), fSDC ( j , 1 )) end do end do end subroutine magpicard_integrate ! Evaluate function values subroutine magpicard_evaluate ( this , pf , level_index , t , m , flags , step ) use pf_mod_dtype class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine magpicard_evaluate subroutine magpicard_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine magpicard_evaluate_all subroutine magpicard_residual ( this , pf , level_index , dt , flags ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer do m = 1 , lev % nnodes - 1 call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do lev % residual = lev % R ( lev % nnodes - 1 )% norm () end subroutine magpicard_residual subroutine magpicard_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine magpicard_spreadq0 ! Destroy the matrices subroutine magpicard_destroy ( this , pf , level_index ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % omega ) call lev % ulevel % factory % destroy_array ( this % time_ev_op ) end subroutine magpicard_destroy subroutine get_commutator_coefs ( qtype , nnodes , dt , coefs ) integer , intent ( in ) :: qtype , nnodes real ( pfdp ), intent ( in ) :: dt real ( pfdp ), intent ( inout ) :: coefs (:,:,:) ! coefs has the structure coefs(coefs, magnus_order, node) ! for a given node, pass subroutines the coefs for a magnus order, then ! loop over coefs if ( qtype == 1 ) then ! we're talking Lobatto nodes, where nnodes=3 includes, t0, t_1/2, tn ! need some way to differentiate whether you want full collocation or not ! coefs(1:3, 1, 1) = dt**2 * [real(8)::11/480., -1/480., 1/480.] ! coefs(1:3, 1, 2) = dt**2 * [real(8)::1/15., 1/60., 1/15.] coefs ( 1 , 1 , 1 ) = - 1 / 4 8.d0 * dt ** 2 coefs ( 2 , 1 , 2 ) = - 1 / 1 2.d0 * dt ** 2 elseif ( qtype == 5 ) then coefs ( 1 : 3 , 1 , 1 ) = 1.d-3 * [ real ( 8 ) :: - 0.708256232441739d0 , 0.201427439334681d0 , - 0.002608155816283d0 ] coefs ( 1 : 3 , 1 , 2 ) = [ real ( 8 ) :: - 0.035291589565775d0 , 0.004482619613666d0 , - 0.000569367343553d0 ] coefs ( 1 : 3 , 1 , 3 ) = [ real ( 8 ) :: - 0.078891497044705d0 , - 0.018131905893999d0 , - 0.035152700676886d0 ] coefs ( 1 : 3 , 1 , 4 ) = [ real ( 8 ) :: - 0.071721913818656d0 , - 0.035860956909328d0 , - 0.071721913818656d0 ] coefs (:, 1 ,:) = dt ** 2 * coefs (:, 1 ,:) coefs (:, 2 , 1 ) = & [ real ( 8 ) :: 1.466782892818107d-6 , - 2.546845448743404d-6 , 7.18855795894042d-7 , & - 3.065370250683271d-7 , 6.962336322868984d-7 , - 1.96845581200288d-7 , & - 2.262216360714434d-8 , - 2.72797194008496d-9 , 8.54843541920492d-10 ] coefs (:, 2 , 2 ) = & [ real ( 8 ) :: 0.001040114336531742d0 , - 0.001714330280871491d0 , 0.0001980882752518163d0 , & - 0.00006910549596945875d0 , 0.0002905401601450182d0 , - 0.00003465884693947625d0 , & 0.0000924518848932026d0 , 0.0000125950571649574d0 , - 2.4709074423913880d-6 ] coefs (:, 2 , 3 ) = & [ real ( 8 ) :: 0.004148295975360902d0 , - 0.006387421893168941d0 , - 0.003594231910817328d0 , & 0.000997378110327084d0 , 0.0001241530237557625d0 , - 0.0003805975423160699d0 , & 0.003718384934573079d0 , 0.001693514295056844d0 , - 0.001060408584538103d0 ] coefs (:, 2 , 4 ) = & [ real ( 8 ) :: 0.003453850676072909d0 , - 0.005584950029394391d0 , - 0.007128159905937654d0 , & 0.001653439153439147d0 , 0.0d0 , - 0.001653439153439143d0 , & 0.007128159905937675d0 , 0.005584950029394475d0 , - 0.003453850676072897d0 ] coefs (:, 2 ,:) = dt ** 3 * coefs (:, 2 ,:) coefs ( 1 , 3 , 4 ) = dt ** 4 / 6 0.d0 else stop 'oh no! unsupported qtype' endif end subroutine get_commutator_coefs end module pf_mod_magnus_picard","tags":"","loc":"sourcefile/pf_magpicard_sweeper.f90.html","title":"pf_magpicard_sweeper.f90 – LibPFASST"},{"text":"MPI communicator routines Contents Modules pf_mod_mpi pf_mod_comm_mpi Source Code pf_mpi.f90 Source Code !!  MPI communicator routines ! ! This file is part of LIBPFASST. ! !>  Module to hold include statement module pf_mod_mpi !  include \"mpif.h\" use mpi end module pf_mod_mpi !> Module to implement communication routines in  MPI. module pf_mod_comm_mpi use pf_mod_dtype use pf_mod_mpi , only : MPI_REAL16 , MPI_REAL8 implicit none !  For normal double precision integer , parameter :: myMPI_Datatype = MPI_REAL8 !  For  quadruple precision  (see top of pf_dtype.f90) ! integer, parameter :: myMPI_Datatype=MPI_REAL16 contains !> Subroutine to create an MPI based PFASST communicator using the MPI communicator *mpi_comm*. subroutine pf_mpi_create ( pf_comm , mpi_comm ) type ( pf_comm_t ), intent ( out ) :: pf_comm integer , intent ( in ) :: mpi_comm integer :: ierror pf_comm % comm = mpi_comm !! assign communicator !> assign number of processors call mpi_comm_size ( mpi_comm , pf_comm % nproc , ierror ) !>  assign procedure pointers pf_comm % post => pf_mpi_post pf_comm % recv => pf_mpi_recv pf_comm % send => pf_mpi_send pf_comm % wait => pf_mpi_wait pf_comm % broadcast => pf_mpi_broadcast pf_comm % recv_status => pf_mpi_recv_status pf_comm % send_status => pf_mpi_send_status end subroutine pf_mpi_create !> Subroutine to set up the PFASST communicator. !! This should be called soon after adding levels to the PFASST controller subroutine pf_mpi_setup ( pf_comm , pf , ierror ) use pf_mod_mpi , only : MPI_REQUEST_NULL type ( pf_comm_t ), intent ( inout ) :: pf_comm !!  communicator type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( inout ) :: ierror !!  error flag !>  set the rank call mpi_comm_rank ( pf_comm % comm , pf % rank , ierror ) !>  allocate arrarys for and and receive requests allocate ( pf_comm % recvreq ( pf % nlevels )) allocate ( pf_comm % sendreq ( pf % nlevels )) pf_comm % sendreq = MPI_REQUEST_NULL pf_comm % statreq = - 66 !Tells the first send_status not to wait for previous one to arrive end subroutine pf_mpi_setup !> Subroutine to destroy the PFASST communicator. subroutine pf_mpi_destroy ( pf_comm ) type ( pf_comm_t ), intent ( inout ) :: pf_comm deallocate ( pf_comm % recvreq ) deallocate ( pf_comm % sendreq ) end subroutine pf_mpi_destroy !>  Subroutine to post receive requests. subroutine pf_mpi_post ( pf , level , tag , ierror , source ) type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level !!  level to send from integer , intent ( in ) :: tag !!  message tag integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source call mpi_irecv ( level % recv , level % mpibuflen , myMPI_Datatype , & source , tag , pf % comm % comm , pf % comm % recvreq ( level % index ), ierror ) end subroutine pf_mpi_post !> Subroutine to send convergence status information subroutine pf_mpi_send_status ( pf , tag , istatus , ierror , dest ) use pf_mod_mpi , only : MPI_INTEGER , MPI_STATUS_SIZE , MPI_REQUEST_NULL type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: tag !!  message tag integer , intent ( in ) :: istatus !!  status flag to send integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: dest integer :: stat ( MPI_STATUS_SIZE ) integer :: message message = istatus if ( pf % comm % statreq /= - 66 ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'waiting in send_status with statreq' , pf % comm % statreq call mpi_wait ( pf % comm % statreq , stat , ierror ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'done waiting in send_status' end if call mpi_issend ( message , 1 , MPI_INTEGER , & dest , tag , pf % comm % comm , pf % comm % statreq , ierror ) end subroutine pf_mpi_send_status !> Subroutine to receive convergence status information subroutine pf_mpi_recv_status ( pf , tag , istatus , ierror , source ) use pf_mod_mpi , only : MPI_INTEGER , MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: tag !!  message tag integer , intent ( inout ) :: istatus !!  status flag to receive integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source integer :: stat ( MPI_STATUS_SIZE ) integer :: message ! Get the message call mpi_recv ( message , 1 , MPI_INTEGER , source , tag , pf % comm % comm , stat , ierror ) istatus = message end subroutine pf_mpi_recv_status !> Subroutine to send solutions subroutine pf_mpi_send ( pf , level , tag , blocking , ierror , dest ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: level !!  level to send from integer , intent ( in ) :: tag !!  message tag logical , intent ( in ) :: blocking !!  true if send is blocking integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: dest integer :: stat ( MPI_STATUS_SIZE ) if ( blocking ) then call mpi_send ( level % send , level % mpibuflen , myMPI_Datatype , & dest , tag , pf % comm % comm , stat , ierror ) else call mpi_isend ( level % send , level % mpibuflen , myMPI_Datatype , & dest , tag , pf % comm % comm , pf % comm % sendreq ( level % index ), ierror ) end if end subroutine pf_mpi_send !> Subroutine to receive solutions !! Note when blocking == .false. this is actually a wait because the !! nonblocking receive  should have already been posted subroutine pf_mpi_recv ( pf , level , tag , blocking , ierror , source ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: level !!  level to recieve into integer , intent ( in ) :: tag !!  message tag logical , intent ( in ) :: blocking !!  true if receive is blocking integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source integer :: stat ( MPI_STATUS_SIZE ) if ( blocking ) then call mpi_recv ( level % recv , level % mpibuflen , myMPI_Datatype , & source , tag , pf % comm % comm , stat , ierror ) else call mpi_wait ( pf % comm % recvreq ( level % index ), stat , ierror ) end if end subroutine pf_mpi_recv ! ! Misc ! subroutine pf_mpi_wait ( pf , level , ierror ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( in ) :: pf !!  main pfasst structure integer , intent ( in ) :: level !!  level on which to wait integer , intent ( inout ) :: ierror !!  error flag integer :: stat ( MPI_STATUS_SIZE ) call mpi_wait ( pf % comm % sendreq ( level ), stat , ierror ) end subroutine pf_mpi_wait subroutine pf_mpi_broadcast ( pf , y , nvar , root , ierror ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: nvar !!  size of data to broadcast real ( pfdp ), intent ( in ) :: y ( nvar ) !!  data to broadcast integer , intent ( in ) :: root !!  rank of broadcaster integer , intent ( inout ) :: ierror !!  error flag call mpi_bcast ( y , nvar , myMPI_Datatype , root , pf % comm % comm , ierror ) end subroutine pf_mpi_broadcast end module pf_mod_comm_mpi","tags":"","loc":"sourcefile/pf_mpi.f90.html","title":"pf_mpi.f90 – LibPFASST"},{"text":"Implicit Munthe-Kass Runge-Kutta sweeper module Contents Modules pf_mod_imk Source Code pf_imk_sweeper.f90 Source Code !!  Implicit Munthe-Kass Runge-Kutta sweeper module ! ! This file is part of LIBPFASST. ! !>  This module implements fully implicit Munthe-Kaas Runge Kutta methods using explicit SDC sweeping !! !!  The equation to be solved is !! !!  y'=A(y,t)y   !! !! where A is a matrix and y)\\ is  a vector or matrix or if Lax_pair = true !! !! Y'=[A(Y,t),Y] where both A and Y are matrices !! !!  We solve this by finding the solution to !! !!  Q' = dexpinv_Q(A) !! !!  Using PFASST module pf_mod_imk use pf_mod_dtype use pf_mod_utils implicit none !>  Implicit Munthe-Kaas Runge-Kutta sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_imk_t class ( pf_encap_t ), allocatable :: A (:) real ( pfdp ), allocatable :: QtilE (:,:) !!  Aproximate quadrature matric real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: dtsdc (:) !!  SDC substep size real ( pfdp ), allocatable :: tsdc (:) real ( pfdp ) :: bernoullis ( 20 ) !!  Bernoulli numbers real ( pfdp ) :: t0 !!  Time at beginning of time step real ( pfdp ) :: dt !!  Time step size integer :: qtype , nterms logical :: Lax_pair , use_SDC , debug , mkrk , rk contains procedure :: sweep => imk_sweep procedure :: initialize => imk_initialize procedure :: evaluate => imk_evaluate procedure :: integrate => imk_integrate procedure :: residual => imk_residual procedure :: spreadq0 => imk_spreadq0 procedure :: evaluate_all => imk_evaluate_all procedure :: destroy => imk_destroy procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_dexpinv_p ), deferred :: dexpinv procedure ( pf_propagate_p ), deferred :: propagate procedure ( pf_commutator_p ), deferred :: commutator_p end type pf_imk_t interface !>  Subroutine f_eval computes A(y,t) subroutine pf_f_eval_p ( this , y , t , level , f ) import pf_imk_t , pf_encap_t , c_int , pfdp class ( pf_imk_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y , f real ( pfdp ), intent ( in ) :: t integer ( c_int ), intent ( in ) :: level end subroutine pf_f_eval_p !>  Subroutine dexpinv computes Om'=F=dexpinv_Om(A) subroutine pf_dexpinv_p ( this , a , omega , f ) import pf_imk_t , pf_encap_t , c_int , pfdp class ( pf_imk_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: a class ( pf_encap_t ), intent ( inout ) :: omega class ( pf_encap_t ), intent ( inout ) :: f !!  The result end subroutine pf_dexpinv_p !>  Subroutine propagate   computes y_m=expm(Om_m)y_0(expm(Om_m))-1 or (expm(Om_m))y_0 or subroutine pf_propagate_p ( this , q0 , q ) import pf_imk_t , pf_encap_t , c_int , pfdp class ( pf_imk_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: q , q0 end subroutine pf_propagate_p subroutine pf_commutator_p ( this , a , b , out , flags ) import pf_imk_t , pf_encap_t , c_int , pfdp class ( pf_imk_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: a , b , out integer , intent ( in ), optional :: flags end subroutine pf_commutator_p end interface contains !> Perform nsweep  sweeps on level  and set qend appropriately. ! with the two-array encap, things are a little tricky ! copy default behavior : copy the solution only ! copy flagged behavior : copy the name of the encap ! setval default behavior : set the value of the name of the encap ! setval flagged behavior : set the value of the solution subroutine imk_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level this % t0 = t0 this % dt = dt if ( this % rk ) then call rk_step ( this , pf , t0 , dt ) else if ( this % mkrk ) then call mkrk_step ( this , pf , t0 , dt ) else call imk_actually_sweep ( this , pf , level_index , t0 , dt , nsweeps ) end if end subroutine imk_sweep subroutine rk_step ( this , pf , t0 , dt ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level integer :: level_index !!  Level to work on integer :: m !!  Loop variables real ( pfdp ) :: t !!  Time at nodes t = t0 + dt level_index = 1 lev => pf % levels ( level_index ) do m = 1 , 5 call lev % Q ( m )% setval ( 0.0_pfdp ) end do call call_hooks ( pf , 1 , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) ! commutator_p flags=1 hack copies Q(1)%y -> Q(1)%array ! all subsequent RK stages are done on Q(m)%array call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 1 ) call lev % Q ( 2 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) ! commutator_p flags=2 hack copies Q(m)%array -> Q(m)%y ! only the Q argument in this case matters ! in order to get solution back to qend call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 5 ), lev % Q ( 5 ), lev % F ( 1 , 1 ), flags = 2 ) call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) call call_hooks ( pf , 1 , PF_POST_SWEEP ) end subroutine rk_step subroutine mkrk_step ( this , pf , t0 , dt ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level integer :: level_index !!  Level we are working on integer :: m !!  Loop variables real ( pfdp ) :: t !!  Time at nodes level_index = 1 lev => pf % levels ( level_index ) t = t0 + dt do m = 1 , 5 call lev % Q ( m )% setval ( 0.0_pfdp ) end do call call_hooks ( pf , 1 , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) call this % dexpinv ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 2 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % dexpinv ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 3 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % dexpinv ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 4 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % dexpinv ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 5 )) call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) call call_hooks ( pf , 1 , PF_POST_SWEEP ) end subroutine mkrk_step subroutine imk_actually_sweep ( this , pf , level_index , t0 , dt , nsweeps ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level integer :: m , n , k !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( level_index ) !  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) end do if ( level_index < pf % nlevels ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% setval ( 0.0_pfdp ) ! likely an unnecessary setting of Omega=0 call this % evaluate ( pf , level_index , t0 , 1 ) end if t = t0 ! do the sub-stepping in sweep do m = 1 , lev % nnodes - 1 !!  Loop over substeps t = t + dt * this % dtsdc ( m ) !>  Accumulate rhs call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) do n = 1 , m call lev % Q ( m + 1 )% axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) end do !>  Add the tau term call lev % Q ( m + 1 )% axpy ( 1.0_pfdp , lev % I ( m )) !>  Compute explicit function on new value call this % evaluate ( pf , level_index , t , m + 1 ) end do !!  End substep loop call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imk_actually_sweep subroutine imk_initialize ( this , pf , level_index ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize integer :: m , nnodes type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 1 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes ), this % QtilE ( nnodes - 1 , nnodes )) allocate ( this % dtsdc ( nnodes - 1 )) allocate ( this % tsdc ( nnodes )) this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) this % bernoullis = 0.0_pfdp this % bernoullis ( 1 ) = - 1.0_pfdp / 2.0_pfdp this % bernoullis ( 2 ) = 1.0_pfdp / 6.0_pfdp this % bernoullis ( 4 ) = - 1.0_pfdp / 3.0e1_pfdp this % bernoullis ( 6 ) = 1.0_pfdp / 4.2e1_pfdp this % bernoullis ( 8 ) = - 1.0_pfdp / 3.0e1_pfdp this % bernoullis ( 10 ) = 5.0_pfdp / 6.6e1_pfdp this % bernoullis ( 12 ) = - 69 1.0_pfdp / 2.73e3_pfdp this % bernoullis ( 14 ) = 7.0_pfdp / 6.0_pfdp this % bernoullis ( 16 ) = - 361 7.0_pfdp / 5.10e2_pfdp this % bernoullis ( 18 ) = 4386 7.0_pfdp / 7.98e2_pfdp this % bernoullis ( 20 ) = - 17461 1.0_pfdp / 33 0.0_pfdp !>  Assign explicit approximate quadrature rule this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE !>  Make space for temporary variables call lev % ulevel % factory % create_array ( this % A , nnodes , & lev % index , lev % shape ) do m = 1 , nnodes call this % A ( m )% setval ( 0.0_pfdp ) end do end subroutine imk_initialize subroutine imk_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: j , m type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer do m = 1 , lev % nnodes - 1 call fintSDC ( m )% setval ( 0.0_pfdp ) do j = 1 , lev % nnodes call fintSDC ( m )% axpy ( dt * lev % sdcmats % qmat ( m , j ), fSDC ( j , 1 )) end do end do end subroutine imk_integrate subroutine imk_evaluate ( this , pf , level_index , t , m , flags , step ) use pf_mod_dtype class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , optional , intent ( in ) :: flags , step integer :: i real ( pfdp ) :: dt type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer !  Propagate to get y=exp(Om) !prop needs e&#94;{Q (omega)} and apply to Y if ( this % debug ) & print * , 'level' , lev % index , 'in evaluate ' , m , '------------------' if ( this % rk ) then ! 't' in f_evals are meaningless since i have a time-independent matrix, A dt = this % dt do i = 1 , 5 call lev % Q ( i )% setval ( 0.0_pfdp ) end do call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) ! commutator_p flags=1 hack copies Q(1)%y -> Q(1)%array ! all subsequent RK stages are done on Q(m)%array call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 1 ) call lev % Q ( 2 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) ! commutator_p flags=2 hack copies Q(m)%array -> Q(m)%y ! only the Q argument in this case matters ! in order to get solution back to qend call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 5 ), lev % Q ( 5 ), lev % F ( 1 , 1 ), flags = 2 ) else if ( this % debug ) then endif if ( m > 1 ) then if ( this % debug ) print * , 'propagating' call this % propagate ( lev % q0 , lev % Q ( m )) else if ( this % debug ) print * , 'copying' call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) end if if ( this % debug ) print * , 'Q' if ( this % debug ) call lev % Q ( m )% eprint () !  Compute A(y,t) call this % f_eval ( lev % Q ( m ), t , lev % index , this % A ( m )) if ( this % debug ) print * , 'A' if ( this % debug ) call this % A ( m )% eprint () !  Compute the series expansion for dexpinv if ( m > 1 ) then call this % dexpinv ( this % A ( m ), lev % Q ( m ), lev % F ( m , 1 )) else call lev % F ( 1 , 1 )% copy ( this % A ( 1 )) endif if ( this % debug ) print * , 'depxinv' if ( this % debug ) call lev % F ( m , 1 )% eprint () endif if ( this % debug ) print * , 'end evaluate ------------' end subroutine imk_evaluate subroutine imk_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step integer :: m type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer if ( this % rk ) then call lev % ulevel % sweeper % evaluate ( pf , level_index , t ( 1 ), 1 ) else do m = 1 , lev % nnodes call lev % ulevel % sweeper % evaluate ( pf , level_index , t ( m ), m ) end do end if end subroutine imk_evaluate_all subroutine imk_residual ( this , pf , level_index , dt , flags ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call lev % ulevel % sweeper % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I ) ! add tau (which is 'node to node') if ( level_index < pf % nlevels ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end do end if ! subtract out Q  (not initial condition is zero do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine imk_residual subroutine imk_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer m , p type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) ! set initial omega to 0 call lev % Q ( 1 )% setval ( 0.0_pfdp ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , 1 ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), flags = 1 ) call lev % Q ( m )% copy ( lev % Q ( 1 )) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p )) end do end do end subroutine imk_spreadq0 !>  Save function values so that difference can be computed subroutine imk_save ( lev ) type ( pf_level_t ), intent ( inout ) :: lev !!  Level to save on integer :: m do m = 1 , lev % nnodes call lev % pF ( m , 1 )% copy ( lev % F ( m , 1 )) end do end subroutine imk_save subroutine imk_destroy ( this , pf , level_index ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % QtilE , this % QdiffE ) deallocate ( this % dtsdc ) deallocate ( this % tsdc ) call lev % ulevel % factory % destroy_array ( this % A ) end subroutine imk_destroy end module pf_mod_imk","tags":"","loc":"sourcefile/pf_imk_sweeper.f90.html","title":"pf_imk_sweeper.f90 – LibPFASST"},{"text":"Files taken from http://www.netlib.org/fftpack/ Contents Subroutines CFFTB1 CFFTF1 CFFTI1 PASSB2 PASSB3 PASSB4 PASSB5 PASSB PASSF2 PASSF3 PASSF4 PASSF5 PASSF RADB2 RADB3 RADB4 RADB5 RADBG RADF2 RADF3 RADF4 RADF5 RADFG RFFTB1 RFFTF1 RFFTI1 ZFFTB ZFFTF ZFFTI Source Code dfftpack.f Source Code !! Files taken from http://www.netlib.org/fftpack/ C     file\tdp.tgz C     for\tdouble precision clone of fftpack C     by\tHugh C. Pumphrey <hcp@met.ed.ac.uk> C     prec\tdouble C     lang\tFortran C     gams\tJ1a SUBROUTINE CFFTB1 ( N , C , CH , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( * ) , C ( * ) , WA ( * ) , IFAC ( * ) NF = IFAC ( 2 ) NA = 0 L1 = 1 IW = 1 DO 116 K1 = 1 , NF IP = IFAC ( K1 + 2 ) L2 = IP * L1 IDO = N / L2 IDOT = IDO + IDO IDL1 = IDOT * L1 IF ( IP . NE . 4 ) GO TO 103 IX2 = IW + IDOT IX3 = IX2 + IDOT IF ( NA . NE . 0 ) GO TO 101 CALL PASSB4 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 102 101 CALL PASSB4 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 )) 102 NA = 1 - NA GO TO 115 103 IF ( IP . NE . 2 ) GO TO 106 IF ( NA . NE . 0 ) GO TO 104 CALL PASSB2 ( IDOT , L1 , C , CH , WA ( IW )) GO TO 105 104 CALL PASSB2 ( IDOT , L1 , CH , C , WA ( IW )) 105 NA = 1 - NA GO TO 115 106 IF ( IP . NE . 3 ) GO TO 109 IX2 = IW + IDOT IF ( NA . NE . 0 ) GO TO 107 CALL PASSB3 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 )) GO TO 108 107 CALL PASSB3 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 )) 108 NA = 1 - NA GO TO 115 109 IF ( IP . NE . 5 ) GO TO 112 IX2 = IW + IDOT IX3 = IX2 + IDOT IX4 = IX3 + IDOT IF ( NA . NE . 0 ) GO TO 110 CALL PASSB5 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 111 110 CALL PASSB5 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) 111 NA = 1 - NA GO TO 115 112 IF ( NA . NE . 0 ) GO TO 113 CALL PASSB ( NAC , IDOT , IP , L1 , IDL1 , C , C , C , CH , CH , WA ( IW )) GO TO 114 113 CALL PASSB ( NAC , IDOT , IP , L1 , IDL1 , CH , CH , CH , C , C , WA ( IW )) 114 IF ( NAC . NE . 0 ) NA = 1 - NA 115 L1 = L2 IW = IW + ( IP - 1 ) * IDOT 116 CONTINUE IF ( NA . EQ . 0 ) RETURN N2 = N + N DO 117 I = 1 , N2 C ( I ) = CH ( I ) 117 CONTINUE RETURN END SUBROUTINE CFFTF1 ( N , C , CH , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( * ) , C ( * ) , WA ( * ) , IFAC ( * ) NF = IFAC ( 2 ) NA = 0 L1 = 1 IW = 1 DO 116 K1 = 1 , NF IP = IFAC ( K1 + 2 ) L2 = IP * L1 IDO = N / L2 IDOT = IDO + IDO IDL1 = IDOT * L1 IF ( IP . NE . 4 ) GO TO 103 IX2 = IW + IDOT IX3 = IX2 + IDOT IF ( NA . NE . 0 ) GO TO 101 CALL PASSF4 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 102 101 CALL PASSF4 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 )) 102 NA = 1 - NA GO TO 115 103 IF ( IP . NE . 2 ) GO TO 106 IF ( NA . NE . 0 ) GO TO 104 CALL PASSF2 ( IDOT , L1 , C , CH , WA ( IW )) GO TO 105 104 CALL PASSF2 ( IDOT , L1 , CH , C , WA ( IW )) 105 NA = 1 - NA GO TO 115 106 IF ( IP . NE . 3 ) GO TO 109 IX2 = IW + IDOT IF ( NA . NE . 0 ) GO TO 107 CALL PASSF3 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 )) GO TO 108 107 CALL PASSF3 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 )) 108 NA = 1 - NA GO TO 115 109 IF ( IP . NE . 5 ) GO TO 112 IX2 = IW + IDOT IX3 = IX2 + IDOT IX4 = IX3 + IDOT IF ( NA . NE . 0 ) GO TO 110 CALL PASSF5 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 111 110 CALL PASSF5 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) 111 NA = 1 - NA GO TO 115 112 IF ( NA . NE . 0 ) GO TO 113 CALL PASSF ( NAC , IDOT , IP , L1 , IDL1 , C , C , C , CH , CH , WA ( IW )) GO TO 114 113 CALL PASSF ( NAC , IDOT , IP , L1 , IDL1 , CH , CH , CH , C , C , WA ( IW )) 114 IF ( NAC . NE . 0 ) NA = 1 - NA 115 L1 = L2 IW = IW + ( IP - 1 ) * IDOT 116 CONTINUE IF ( NA . EQ . 0 ) RETURN N2 = N + N DO 117 I = 1 , N2 C ( I ) = CH ( I ) 117 CONTINUE RETURN END SUBROUTINE CFFTI1 ( N , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION WA ( * ) , IFAC ( * ) , NTRYH ( 4 ) DATA NTRYH ( 1 ), NTRYH ( 2 ), NTRYH ( 3 ), NTRYH ( 4 ) / 3 , 4 , 2 , 5 / NL = N NF = 0 J = 0 101 J = J + 1 IF ( J - 4 ) 102 , 102 , 103 102 NTRY = NTRYH ( J ) GO TO 104 103 NTRY = NTRY + 2 104 NQ = NL / NTRY NR = NL - NTRY * NQ IF ( NR ) 101 , 105 , 101 105 NF = NF + 1 IFAC ( NF + 2 ) = NTRY NL = NQ IF ( NTRY . NE . 2 ) GO TO 107 IF ( NF . EQ . 1 ) GO TO 107 DO 106 I = 2 , NF IB = NF - I + 2 IFAC ( IB + 2 ) = IFAC ( IB + 1 ) 106 CONTINUE IFAC ( 3 ) = 2 107 IF ( NL . NE . 1 ) GO TO 104 IFAC ( 1 ) = N IFAC ( 2 ) = NF TPI = 6.28318530717958647692D0 ARGH = TPI / FLOAT ( N ) I = 2 L1 = 1 DO 110 K1 = 1 , NF IP = IFAC ( K1 + 2 ) LD = 0 L2 = L1 * IP IDO = N / L2 IDOT = IDO + IDO + 2 IPM = IP - 1 DO 109 J = 1 , IPM I1 = I WA ( I - 1 ) = 1.0D0 WA ( I ) = 0.0D0 LD = LD + L1 FI = 0.0D0 ARGLD = FLOAT ( LD ) * ARGH DO 108 II = 4 , IDOT , 2 I = I + 2 FI = FI + 1.D0 ARG = FI * ARGLD WA ( I - 1 ) = COS ( ARG ) WA ( I ) = SIN ( ARG ) 108 CONTINUE IF ( IP . LE . 5 ) GO TO 109 WA ( I1 - 1 ) = WA ( I - 1 ) WA ( I1 ) = WA ( I ) 109 CONTINUE L1 = L2 110 CONTINUE RETURN END SUBROUTINE PASSB2 ( IDO , L1 , CC , CH , WA1 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 2 , L1 ) , CH ( IDO , L1 , 2 ) , 1 WA1 ( 1 ) IF ( IDO . GT . 2 ) GO TO 102 DO 101 K = 1 , L1 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + CC ( 1 , 2 , K ) CH ( 1 , K , 2 ) = CC ( 1 , 1 , K ) - CC ( 1 , 2 , K ) CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + CC ( 2 , 2 , K ) CH ( 2 , K , 2 ) = CC ( 2 , 1 , K ) - CC ( 2 , 2 , K ) 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + CC ( I - 1 , 2 , K ) TR2 = CC ( I - 1 , 1 , K ) - CC ( I - 1 , 2 , K ) CH ( I , K , 1 ) = CC ( I , 1 , K ) + CC ( I , 2 , K ) TI2 = CC ( I , 1 , K ) - CC ( I , 2 , K ) CH ( I , K , 2 ) = WA1 ( I - 1 ) * TI2 + WA1 ( I ) * TR2 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * TR2 - WA1 ( I ) * TI2 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSB3 ( IDO , L1 , CC , CH , WA1 , WA2 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 3 , L1 ) , CH ( IDO , L1 , 3 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) C     *** TAUI IS SQRT(3)/2 *** DATA TAUR , TAUI /- 0.5D0 , 0.86602540378443864676D0 / IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TR2 = CC ( 1 , 2 , K ) + CC ( 1 , 3 , K ) CR2 = CC ( 1 , 1 , K ) + TAUR * TR2 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 TI2 = CC ( 2 , 2 , K ) + CC ( 2 , 3 , K ) CI2 = CC ( 2 , 1 , K ) + TAUR * TI2 CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + TI2 CR3 = TAUI * ( CC ( 1 , 2 , K ) - CC ( 1 , 3 , K )) CI3 = TAUI * ( CC ( 2 , 2 , K ) - CC ( 2 , 3 , K )) CH ( 1 , K , 2 ) = CR2 - CI3 CH ( 1 , K , 3 ) = CR2 + CI3 CH ( 2 , K , 2 ) = CI2 + CR3 CH ( 2 , K , 3 ) = CI2 - CR3 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TR2 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 3 , K ) CR2 = CC ( I - 1 , 1 , K ) + TAUR * TR2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 TI2 = CC ( I , 2 , K ) + CC ( I , 3 , K ) CI2 = CC ( I , 1 , K ) + TAUR * TI2 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 CR3 = TAUI * ( CC ( I - 1 , 2 , K ) - CC ( I - 1 , 3 , K )) CI3 = TAUI * ( CC ( I , 2 , K ) - CC ( I , 3 , K )) DR2 = CR2 - CI3 DR3 = CR2 + CI3 DI2 = CI2 + CR3 DI3 = CI2 - CR3 CH ( I , K , 2 ) = WA1 ( I - 1 ) * DI2 + WA1 ( I ) * DR2 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * DR2 - WA1 ( I ) * DI2 CH ( I , K , 3 ) = WA2 ( I - 1 ) * DI3 + WA2 ( I ) * DR3 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * DR3 - WA2 ( I ) * DI3 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSB4 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 4 , L1 ) , CH ( IDO , L1 , 4 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TI1 = CC ( 2 , 1 , K ) - CC ( 2 , 3 , K ) TI2 = CC ( 2 , 1 , K ) + CC ( 2 , 3 , K ) TR4 = CC ( 2 , 4 , K ) - CC ( 2 , 2 , K ) TI3 = CC ( 2 , 2 , K ) + CC ( 2 , 4 , K ) TR1 = CC ( 1 , 1 , K ) - CC ( 1 , 3 , K ) TR2 = CC ( 1 , 1 , K ) + CC ( 1 , 3 , K ) TI4 = CC ( 1 , 2 , K ) - CC ( 1 , 4 , K ) TR3 = CC ( 1 , 2 , K ) + CC ( 1 , 4 , K ) CH ( 1 , K , 1 ) = TR2 + TR3 CH ( 1 , K , 3 ) = TR2 - TR3 CH ( 2 , K , 1 ) = TI2 + TI3 CH ( 2 , K , 3 ) = TI2 - TI3 CH ( 1 , K , 2 ) = TR1 + TR4 CH ( 1 , K , 4 ) = TR1 - TR4 CH ( 2 , K , 2 ) = TI1 + TI4 CH ( 2 , K , 4 ) = TI1 - TI4 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TI1 = CC ( I , 1 , K ) - CC ( I , 3 , K ) TI2 = CC ( I , 1 , K ) + CC ( I , 3 , K ) TI3 = CC ( I , 2 , K ) + CC ( I , 4 , K ) TR4 = CC ( I , 4 , K ) - CC ( I , 2 , K ) TR1 = CC ( I - 1 , 1 , K ) - CC ( I - 1 , 3 , K ) TR2 = CC ( I - 1 , 1 , K ) + CC ( I - 1 , 3 , K ) TI4 = CC ( I - 1 , 2 , K ) - CC ( I - 1 , 4 , K ) TR3 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = TR2 + TR3 CR3 = TR2 - TR3 CH ( I , K , 1 ) = TI2 + TI3 CI3 = TI2 - TI3 CR2 = TR1 + TR4 CR4 = TR1 - TR4 CI2 = TI1 + TI4 CI4 = TI1 - TI4 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * CR2 - WA1 ( I ) * CI2 CH ( I , K , 2 ) = WA1 ( I - 1 ) * CI2 + WA1 ( I ) * CR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * CR3 - WA2 ( I ) * CI3 CH ( I , K , 3 ) = WA2 ( I - 1 ) * CI3 + WA2 ( I ) * CR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 1 ) * CR4 - WA3 ( I ) * CI4 CH ( I , K , 4 ) = WA3 ( I - 1 ) * CI4 + WA3 ( I ) * CR4 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSB5 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 , WA4 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 5 , L1 ) , CH ( IDO , L1 , 5 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) , WA4 ( 1 ) C     *** TR11=COS(2*PI/5), TI11=SIN(2*PI/5) C     *** TR12=COS(4*PI/5), TI12=SIN(4*PI/5) DATA TR11 , TI11 , TR12 , TI12 / 0.3090169943749474241D0 , + 0.95105651629515357212D0 , + - 0.8090169943749474241D0 , 0.58778525229247312917D0 / IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TI5 = CC ( 2 , 2 , K ) - CC ( 2 , 5 , K ) TI2 = CC ( 2 , 2 , K ) + CC ( 2 , 5 , K ) TI4 = CC ( 2 , 3 , K ) - CC ( 2 , 4 , K ) TI3 = CC ( 2 , 3 , K ) + CC ( 2 , 4 , K ) TR5 = CC ( 1 , 2 , K ) - CC ( 1 , 5 , K ) TR2 = CC ( 1 , 2 , K ) + CC ( 1 , 5 , K ) TR4 = CC ( 1 , 3 , K ) - CC ( 1 , 4 , K ) TR3 = CC ( 1 , 3 , K ) + CC ( 1 , 4 , K ) CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 + TR3 CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + TI2 + TI3 CR2 = CC ( 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( 2 , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( 2 , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 CH ( 1 , K , 2 ) = CR2 - CI5 CH ( 1 , K , 5 ) = CR2 + CI5 CH ( 2 , K , 2 ) = CI2 + CR5 CH ( 2 , K , 3 ) = CI3 + CR4 CH ( 1 , K , 3 ) = CR3 - CI4 CH ( 1 , K , 4 ) = CR3 + CI4 CH ( 2 , K , 4 ) = CI3 - CR4 CH ( 2 , K , 5 ) = CI2 - CR5 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TI5 = CC ( I , 2 , K ) - CC ( I , 5 , K ) TI2 = CC ( I , 2 , K ) + CC ( I , 5 , K ) TI4 = CC ( I , 3 , K ) - CC ( I , 4 , K ) TI3 = CC ( I , 3 , K ) + CC ( I , 4 , K ) TR5 = CC ( I - 1 , 2 , K ) - CC ( I - 1 , 5 , K ) TR2 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 5 , K ) TR4 = CC ( I - 1 , 3 , K ) - CC ( I - 1 , 4 , K ) TR3 = CC ( I - 1 , 3 , K ) + CC ( I - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 + TR3 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 + TI3 CR2 = CC ( I - 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( I , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( I - 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( I , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 DR3 = CR3 - CI4 DR4 = CR3 + CI4 DI3 = CI3 + CR4 DI4 = CI3 - CR4 DR5 = CR2 + CI5 DR2 = CR2 - CI5 DI5 = CI2 - CR5 DI2 = CI2 + CR5 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * DR2 - WA1 ( I ) * DI2 CH ( I , K , 2 ) = WA1 ( I - 1 ) * DI2 + WA1 ( I ) * DR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * DR3 - WA2 ( I ) * DI3 CH ( I , K , 3 ) = WA2 ( I - 1 ) * DI3 + WA2 ( I ) * DR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 1 ) * DR4 - WA3 ( I ) * DI4 CH ( I , K , 4 ) = WA3 ( I - 1 ) * DI4 + WA3 ( I ) * DR4 CH ( I - 1 , K , 5 ) = WA4 ( I - 1 ) * DR5 - WA4 ( I ) * DI5 CH ( I , K , 5 ) = WA4 ( I - 1 ) * DI5 + WA4 ( I ) * DR5 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSB ( NAC , IDO , IP , L1 , IDL1 , CC , C1 , C2 , CH , CH2 , WA ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , L1 , IP ) , CC ( IDO , IP , L1 ) , 1 C1 ( IDO , L1 , IP ) , WA ( 1 ) , C2 ( IDL1 , IP ), 2 CH2 ( IDL1 , IP ) IDOT = IDO / 2 NT = IP * IDL1 IPP2 = IP + 2 IPPH = ( IP + 1 ) / 2 IDP = IP * IDO C IF ( IDO . LT . L1 ) GO TO 106 DO 103 J = 2 , IPPH JC = IPP2 - J DO 102 K = 1 , L1 DO 101 I = 1 , IDO CH ( I , K , J ) = CC ( I , J , K ) + CC ( I , JC , K ) CH ( I , K , JC ) = CC ( I , J , K ) - CC ( I , JC , K ) 101 CONTINUE 102 CONTINUE 103 CONTINUE DO 105 K = 1 , L1 DO 104 I = 1 , IDO CH ( I , K , 1 ) = CC ( I , 1 , K ) 104 CONTINUE 105 CONTINUE GO TO 112 106 DO 109 J = 2 , IPPH JC = IPP2 - J DO 108 I = 1 , IDO DO 107 K = 1 , L1 CH ( I , K , J ) = CC ( I , J , K ) + CC ( I , JC , K ) CH ( I , K , JC ) = CC ( I , J , K ) - CC ( I , JC , K ) 107 CONTINUE 108 CONTINUE 109 CONTINUE DO 111 I = 1 , IDO DO 110 K = 1 , L1 CH ( I , K , 1 ) = CC ( I , 1 , K ) 110 CONTINUE 111 CONTINUE 112 IDL = 2 - IDO INC = 0 DO 116 L = 2 , IPPH LC = IPP2 - L IDL = IDL + IDO DO 113 IK = 1 , IDL1 C2 ( IK , L ) = CH2 ( IK , 1 ) + WA ( IDL - 1 ) * CH2 ( IK , 2 ) C2 ( IK , LC ) = WA ( IDL ) * CH2 ( IK , IP ) 113 CONTINUE IDLJ = IDL INC = INC + IDO DO 115 J = 3 , IPPH JC = IPP2 - J IDLJ = IDLJ + INC IF ( IDLJ . GT . IDP ) IDLJ = IDLJ - IDP WAR = WA ( IDLJ - 1 ) WAI = WA ( IDLJ ) DO 114 IK = 1 , IDL1 C2 ( IK , L ) = C2 ( IK , L ) + WAR * CH2 ( IK , J ) C2 ( IK , LC ) = C2 ( IK , LC ) + WAI * CH2 ( IK , JC ) 114 CONTINUE 115 CONTINUE 116 CONTINUE DO 118 J = 2 , IPPH DO 117 IK = 1 , IDL1 CH2 ( IK , 1 ) = CH2 ( IK , 1 ) + CH2 ( IK , J ) 117 CONTINUE 118 CONTINUE DO 120 J = 2 , IPPH JC = IPP2 - J DO 119 IK = 2 , IDL1 , 2 CH2 ( IK - 1 , J ) = C2 ( IK - 1 , J ) - C2 ( IK , JC ) CH2 ( IK - 1 , JC ) = C2 ( IK - 1 , J ) + C2 ( IK , JC ) CH2 ( IK , J ) = C2 ( IK , J ) + C2 ( IK - 1 , JC ) CH2 ( IK , JC ) = C2 ( IK , J ) - C2 ( IK - 1 , JC ) 119 CONTINUE 120 CONTINUE NAC = 1 IF ( IDO . EQ . 2 ) RETURN NAC = 0 DO 121 IK = 1 , IDL1 C2 ( IK , 1 ) = CH2 ( IK , 1 ) 121 CONTINUE DO 123 J = 2 , IP DO 122 K = 1 , L1 C1 ( 1 , K , J ) = CH ( 1 , K , J ) C1 ( 2 , K , J ) = CH ( 2 , K , J ) 122 CONTINUE 123 CONTINUE IF ( IDOT . GT . L1 ) GO TO 127 IDIJ = 0 DO 126 J = 2 , IP IDIJ = IDIJ + 2 DO 125 I = 4 , IDO , 2 IDIJ = IDIJ + 2 DO 124 K = 1 , L1 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) - WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) + WA ( IDIJ ) * CH ( I - 1 , K , J ) 124 CONTINUE 125 CONTINUE 126 CONTINUE RETURN 127 IDJ = 2 - IDO DO 130 J = 2 , IP IDJ = IDJ + IDO DO 129 K = 1 , L1 IDIJ = IDJ DO 128 I = 4 , IDO , 2 IDIJ = IDIJ + 2 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) - WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) + WA ( IDIJ ) * CH ( I - 1 , K , J ) 128 CONTINUE 129 CONTINUE 130 CONTINUE RETURN END SUBROUTINE PASSF2 ( IDO , L1 , CC , CH , WA1 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 2 , L1 ) , CH ( IDO , L1 , 2 ) , 1 WA1 ( 1 ) IF ( IDO . GT . 2 ) GO TO 102 DO 101 K = 1 , L1 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + CC ( 1 , 2 , K ) CH ( 1 , K , 2 ) = CC ( 1 , 1 , K ) - CC ( 1 , 2 , K ) CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + CC ( 2 , 2 , K ) CH ( 2 , K , 2 ) = CC ( 2 , 1 , K ) - CC ( 2 , 2 , K ) 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + CC ( I - 1 , 2 , K ) TR2 = CC ( I - 1 , 1 , K ) - CC ( I - 1 , 2 , K ) CH ( I , K , 1 ) = CC ( I , 1 , K ) + CC ( I , 2 , K ) TI2 = CC ( I , 1 , K ) - CC ( I , 2 , K ) CH ( I , K , 2 ) = WA1 ( I - 1 ) * TI2 - WA1 ( I ) * TR2 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * TR2 + WA1 ( I ) * TI2 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSF3 ( IDO , L1 , CC , CH , WA1 , WA2 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 3 , L1 ) , CH ( IDO , L1 , 3 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) C     *** TAUI IS -SQRT(3)/2 *** DATA TAUR , TAUI /- 0.5D0 , - 0.86602540378443864676D0 / IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TR2 = CC ( 1 , 2 , K ) + CC ( 1 , 3 , K ) CR2 = CC ( 1 , 1 , K ) + TAUR * TR2 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 TI2 = CC ( 2 , 2 , K ) + CC ( 2 , 3 , K ) CI2 = CC ( 2 , 1 , K ) + TAUR * TI2 CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + TI2 CR3 = TAUI * ( CC ( 1 , 2 , K ) - CC ( 1 , 3 , K )) CI3 = TAUI * ( CC ( 2 , 2 , K ) - CC ( 2 , 3 , K )) CH ( 1 , K , 2 ) = CR2 - CI3 CH ( 1 , K , 3 ) = CR2 + CI3 CH ( 2 , K , 2 ) = CI2 + CR3 CH ( 2 , K , 3 ) = CI2 - CR3 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TR2 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 3 , K ) CR2 = CC ( I - 1 , 1 , K ) + TAUR * TR2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 TI2 = CC ( I , 2 , K ) + CC ( I , 3 , K ) CI2 = CC ( I , 1 , K ) + TAUR * TI2 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 CR3 = TAUI * ( CC ( I - 1 , 2 , K ) - CC ( I - 1 , 3 , K )) CI3 = TAUI * ( CC ( I , 2 , K ) - CC ( I , 3 , K )) DR2 = CR2 - CI3 DR3 = CR2 + CI3 DI2 = CI2 + CR3 DI3 = CI2 - CR3 CH ( I , K , 2 ) = WA1 ( I - 1 ) * DI2 - WA1 ( I ) * DR2 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * DR2 + WA1 ( I ) * DI2 CH ( I , K , 3 ) = WA2 ( I - 1 ) * DI3 - WA2 ( I ) * DR3 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * DR3 + WA2 ( I ) * DI3 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSF4 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 4 , L1 ) , CH ( IDO , L1 , 4 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TI1 = CC ( 2 , 1 , K ) - CC ( 2 , 3 , K ) TI2 = CC ( 2 , 1 , K ) + CC ( 2 , 3 , K ) TR4 = CC ( 2 , 2 , K ) - CC ( 2 , 4 , K ) TI3 = CC ( 2 , 2 , K ) + CC ( 2 , 4 , K ) TR1 = CC ( 1 , 1 , K ) - CC ( 1 , 3 , K ) TR2 = CC ( 1 , 1 , K ) + CC ( 1 , 3 , K ) TI4 = CC ( 1 , 4 , K ) - CC ( 1 , 2 , K ) TR3 = CC ( 1 , 2 , K ) + CC ( 1 , 4 , K ) CH ( 1 , K , 1 ) = TR2 + TR3 CH ( 1 , K , 3 ) = TR2 - TR3 CH ( 2 , K , 1 ) = TI2 + TI3 CH ( 2 , K , 3 ) = TI2 - TI3 CH ( 1 , K , 2 ) = TR1 + TR4 CH ( 1 , K , 4 ) = TR1 - TR4 CH ( 2 , K , 2 ) = TI1 + TI4 CH ( 2 , K , 4 ) = TI1 - TI4 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TI1 = CC ( I , 1 , K ) - CC ( I , 3 , K ) TI2 = CC ( I , 1 , K ) + CC ( I , 3 , K ) TI3 = CC ( I , 2 , K ) + CC ( I , 4 , K ) TR4 = CC ( I , 2 , K ) - CC ( I , 4 , K ) TR1 = CC ( I - 1 , 1 , K ) - CC ( I - 1 , 3 , K ) TR2 = CC ( I - 1 , 1 , K ) + CC ( I - 1 , 3 , K ) TI4 = CC ( I - 1 , 4 , K ) - CC ( I - 1 , 2 , K ) TR3 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = TR2 + TR3 CR3 = TR2 - TR3 CH ( I , K , 1 ) = TI2 + TI3 CI3 = TI2 - TI3 CR2 = TR1 + TR4 CR4 = TR1 - TR4 CI2 = TI1 + TI4 CI4 = TI1 - TI4 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * CR2 + WA1 ( I ) * CI2 CH ( I , K , 2 ) = WA1 ( I - 1 ) * CI2 - WA1 ( I ) * CR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * CR3 + WA2 ( I ) * CI3 CH ( I , K , 3 ) = WA2 ( I - 1 ) * CI3 - WA2 ( I ) * CR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 1 ) * CR4 + WA3 ( I ) * CI4 CH ( I , K , 4 ) = WA3 ( I - 1 ) * CI4 - WA3 ( I ) * CR4 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSF5 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 , WA4 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 5 , L1 ) , CH ( IDO , L1 , 5 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) , WA4 ( 1 ) C     *** TR11=COS(2*PI/5), TI11=-SIN(2*PI/5) C     *** TR12=-COS(4*PI/5), TI12=-SIN(4*PI/5) DATA TR11 , TI11 , TR12 , TI12 / 0.3090169943749474241D0 , + - 0.95105651629515357212D0 , 1 - 0.8090169943749474241D0 , - 0.58778525229247312917D0 / IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TI5 = CC ( 2 , 2 , K ) - CC ( 2 , 5 , K ) TI2 = CC ( 2 , 2 , K ) + CC ( 2 , 5 , K ) TI4 = CC ( 2 , 3 , K ) - CC ( 2 , 4 , K ) TI3 = CC ( 2 , 3 , K ) + CC ( 2 , 4 , K ) TR5 = CC ( 1 , 2 , K ) - CC ( 1 , 5 , K ) TR2 = CC ( 1 , 2 , K ) + CC ( 1 , 5 , K ) TR4 = CC ( 1 , 3 , K ) - CC ( 1 , 4 , K ) TR3 = CC ( 1 , 3 , K ) + CC ( 1 , 4 , K ) CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 + TR3 CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + TI2 + TI3 CR2 = CC ( 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( 2 , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( 2 , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 CH ( 1 , K , 2 ) = CR2 - CI5 CH ( 1 , K , 5 ) = CR2 + CI5 CH ( 2 , K , 2 ) = CI2 + CR5 CH ( 2 , K , 3 ) = CI3 + CR4 CH ( 1 , K , 3 ) = CR3 - CI4 CH ( 1 , K , 4 ) = CR3 + CI4 CH ( 2 , K , 4 ) = CI3 - CR4 CH ( 2 , K , 5 ) = CI2 - CR5 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TI5 = CC ( I , 2 , K ) - CC ( I , 5 , K ) TI2 = CC ( I , 2 , K ) + CC ( I , 5 , K ) TI4 = CC ( I , 3 , K ) - CC ( I , 4 , K ) TI3 = CC ( I , 3 , K ) + CC ( I , 4 , K ) TR5 = CC ( I - 1 , 2 , K ) - CC ( I - 1 , 5 , K ) TR2 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 5 , K ) TR4 = CC ( I - 1 , 3 , K ) - CC ( I - 1 , 4 , K ) TR3 = CC ( I - 1 , 3 , K ) + CC ( I - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 + TR3 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 + TI3 CR2 = CC ( I - 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( I , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( I - 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( I , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 DR3 = CR3 - CI4 DR4 = CR3 + CI4 DI3 = CI3 + CR4 DI4 = CI3 - CR4 DR5 = CR2 + CI5 DR2 = CR2 - CI5 DI5 = CI2 - CR5 DI2 = CI2 + CR5 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * DR2 + WA1 ( I ) * DI2 CH ( I , K , 2 ) = WA1 ( I - 1 ) * DI2 - WA1 ( I ) * DR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * DR3 + WA2 ( I ) * DI3 CH ( I , K , 3 ) = WA2 ( I - 1 ) * DI3 - WA2 ( I ) * DR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 1 ) * DR4 + WA3 ( I ) * DI4 CH ( I , K , 4 ) = WA3 ( I - 1 ) * DI4 - WA3 ( I ) * DR4 CH ( I - 1 , K , 5 ) = WA4 ( I - 1 ) * DR5 + WA4 ( I ) * DI5 CH ( I , K , 5 ) = WA4 ( I - 1 ) * DI5 - WA4 ( I ) * DR5 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSF ( NAC , IDO , IP , L1 , IDL1 , CC , C1 , C2 , CH , CH2 , WA ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , L1 , IP ) , CC ( IDO , IP , L1 ) , 1 C1 ( IDO , L1 , IP ) , WA ( 1 ) , C2 ( IDL1 , IP ), 2 CH2 ( IDL1 , IP ) IDOT = IDO / 2 NT = IP * IDL1 IPP2 = IP + 2 IPPH = ( IP + 1 ) / 2 IDP = IP * IDO C IF ( IDO . LT . L1 ) GO TO 106 DO 103 J = 2 , IPPH JC = IPP2 - J DO 102 K = 1 , L1 DO 101 I = 1 , IDO CH ( I , K , J ) = CC ( I , J , K ) + CC ( I , JC , K ) CH ( I , K , JC ) = CC ( I , J , K ) - CC ( I , JC , K ) 101 CONTINUE 102 CONTINUE 103 CONTINUE DO 105 K = 1 , L1 DO 104 I = 1 , IDO CH ( I , K , 1 ) = CC ( I , 1 , K ) 104 CONTINUE 105 CONTINUE GO TO 112 106 DO 109 J = 2 , IPPH JC = IPP2 - J DO 108 I = 1 , IDO DO 107 K = 1 , L1 CH ( I , K , J ) = CC ( I , J , K ) + CC ( I , JC , K ) CH ( I , K , JC ) = CC ( I , J , K ) - CC ( I , JC , K ) 107 CONTINUE 108 CONTINUE 109 CONTINUE DO 111 I = 1 , IDO DO 110 K = 1 , L1 CH ( I , K , 1 ) = CC ( I , 1 , K ) 110 CONTINUE 111 CONTINUE 112 IDL = 2 - IDO INC = 0 DO 116 L = 2 , IPPH LC = IPP2 - L IDL = IDL + IDO DO 113 IK = 1 , IDL1 C2 ( IK , L ) = CH2 ( IK , 1 ) + WA ( IDL - 1 ) * CH2 ( IK , 2 ) C2 ( IK , LC ) = - WA ( IDL ) * CH2 ( IK , IP ) 113 CONTINUE IDLJ = IDL INC = INC + IDO DO 115 J = 3 , IPPH JC = IPP2 - J IDLJ = IDLJ + INC IF ( IDLJ . GT . IDP ) IDLJ = IDLJ - IDP WAR = WA ( IDLJ - 1 ) WAI = WA ( IDLJ ) DO 114 IK = 1 , IDL1 C2 ( IK , L ) = C2 ( IK , L ) + WAR * CH2 ( IK , J ) C2 ( IK , LC ) = C2 ( IK , LC ) - WAI * CH2 ( IK , JC ) 114 CONTINUE 115 CONTINUE 116 CONTINUE DO 118 J = 2 , IPPH DO 117 IK = 1 , IDL1 CH2 ( IK , 1 ) = CH2 ( IK , 1 ) + CH2 ( IK , J ) 117 CONTINUE 118 CONTINUE DO 120 J = 2 , IPPH JC = IPP2 - J DO 119 IK = 2 , IDL1 , 2 CH2 ( IK - 1 , J ) = C2 ( IK - 1 , J ) - C2 ( IK , JC ) CH2 ( IK - 1 , JC ) = C2 ( IK - 1 , J ) + C2 ( IK , JC ) CH2 ( IK , J ) = C2 ( IK , J ) + C2 ( IK - 1 , JC ) CH2 ( IK , JC ) = C2 ( IK , J ) - C2 ( IK - 1 , JC ) 119 CONTINUE 120 CONTINUE NAC = 1 IF ( IDO . EQ . 2 ) RETURN NAC = 0 DO 121 IK = 1 , IDL1 C2 ( IK , 1 ) = CH2 ( IK , 1 ) 121 CONTINUE DO 123 J = 2 , IP DO 122 K = 1 , L1 C1 ( 1 , K , J ) = CH ( 1 , K , J ) C1 ( 2 , K , J ) = CH ( 2 , K , J ) 122 CONTINUE 123 CONTINUE IF ( IDOT . GT . L1 ) GO TO 127 IDIJ = 0 DO 126 J = 2 , IP IDIJ = IDIJ + 2 DO 125 I = 4 , IDO , 2 IDIJ = IDIJ + 2 DO 124 K = 1 , L1 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) + WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) - WA ( IDIJ ) * CH ( I - 1 , K , J ) 124 CONTINUE 125 CONTINUE 126 CONTINUE RETURN 127 IDJ = 2 - IDO DO 130 J = 2 , IP IDJ = IDJ + IDO DO 129 K = 1 , L1 IDIJ = IDJ DO 128 I = 4 , IDO , 2 IDIJ = IDIJ + 2 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) + WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) - WA ( IDIJ ) * CH ( I - 1 , K , J ) 128 CONTINUE 129 CONTINUE 130 CONTINUE RETURN END SUBROUTINE RADB2 ( IDO , L1 , CC , CH , WA1 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 2 , L1 ) , CH ( IDO , L1 , 2 ) , 1 WA1 ( 1 ) DO 101 K = 1 , L1 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + CC ( IDO , 2 , K ) CH ( 1 , K , 2 ) = CC ( 1 , 1 , K ) - CC ( IDO , 2 , K ) 101 CONTINUE IF ( IDO - 2 ) 107 , 105 , 102 102 IDP2 = IDO + 2 DO 104 K = 1 , L1 DO 103 I = 3 , IDO , 2 IC = IDP2 - I CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + CC ( IC - 1 , 2 , K ) TR2 = CC ( I - 1 , 1 , K ) - CC ( IC - 1 , 2 , K ) CH ( I , K , 1 ) = CC ( I , 1 , K ) - CC ( IC , 2 , K ) TI2 = CC ( I , 1 , K ) + CC ( IC , 2 , K ) CH ( I - 1 , K , 2 ) = WA1 ( I - 2 ) * TR2 - WA1 ( I - 1 ) * TI2 CH ( I , K , 2 ) = WA1 ( I - 2 ) * TI2 + WA1 ( I - 1 ) * TR2 103 CONTINUE 104 CONTINUE IF ( MOD ( IDO , 2 ) . EQ . 1 ) RETURN 105 DO 106 K = 1 , L1 CH ( IDO , K , 1 ) = CC ( IDO , 1 , K ) + CC ( IDO , 1 , K ) CH ( IDO , K , 2 ) = - ( CC ( 1 , 2 , K ) + CC ( 1 , 2 , K )) 106 CONTINUE 107 RETURN END SUBROUTINE RADB3 ( IDO , L1 , CC , CH , WA1 , WA2 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 3 , L1 ) , CH ( IDO , L1 , 3 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) C     *** TAUI IS SQRT(3)/2 *** DATA TAUR , TAUI /- 0.5D0 , 0.86602540378443864676D0 / DO 101 K = 1 , L1 TR2 = CC ( IDO , 2 , K ) + CC ( IDO , 2 , K ) CR2 = CC ( 1 , 1 , K ) + TAUR * TR2 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 CI3 = TAUI * ( CC ( 1 , 3 , K ) + CC ( 1 , 3 , K )) CH ( 1 , K , 2 ) = CR2 - CI3 CH ( 1 , K , 3 ) = CR2 + CI3 101 CONTINUE IF ( IDO . EQ . 1 ) RETURN IDP2 = IDO + 2 DO 103 K = 1 , L1 DO 102 I = 3 , IDO , 2 IC = IDP2 - I TR2 = CC ( I - 1 , 3 , K ) + CC ( IC - 1 , 2 , K ) CR2 = CC ( I - 1 , 1 , K ) + TAUR * TR2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 TI2 = CC ( I , 3 , K ) - CC ( IC , 2 , K ) CI2 = CC ( I , 1 , K ) + TAUR * TI2 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 CR3 = TAUI * ( CC ( I - 1 , 3 , K ) - CC ( IC - 1 , 2 , K )) CI3 = TAUI * ( CC ( I , 3 , K ) + CC ( IC , 2 , K )) DR2 = CR2 - CI3 DR3 = CR2 + CI3 DI2 = CI2 + CR3 DI3 = CI2 - CR3 CH ( I - 1 , K , 2 ) = WA1 ( I - 2 ) * DR2 - WA1 ( I - 1 ) * DI2 CH ( I , K , 2 ) = WA1 ( I - 2 ) * DI2 + WA1 ( I - 1 ) * DR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 2 ) * DR3 - WA2 ( I - 1 ) * DI3 CH ( I , K , 3 ) = WA2 ( I - 2 ) * DI3 + WA2 ( I - 1 ) * DR3 102 CONTINUE 103 CONTINUE RETURN END SUBROUTINE RADB4 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 4 , L1 ) , CH ( IDO , L1 , 4 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) DATA SQRT2 / 1.41421356237309504880D0 / DO 101 K = 1 , L1 TR1 = CC ( 1 , 1 , K ) - CC ( IDO , 4 , K ) TR2 = CC ( 1 , 1 , K ) + CC ( IDO , 4 , K ) TR3 = CC ( IDO , 2 , K ) + CC ( IDO , 2 , K ) TR4 = CC ( 1 , 3 , K ) + CC ( 1 , 3 , K ) CH ( 1 , K , 1 ) = TR2 + TR3 CH ( 1 , K , 2 ) = TR1 - TR4 CH ( 1 , K , 3 ) = TR2 - TR3 CH ( 1 , K , 4 ) = TR1 + TR4 101 CONTINUE IF ( IDO - 2 ) 107 , 105 , 102 102 IDP2 = IDO + 2 DO 104 K = 1 , L1 DO 103 I = 3 , IDO , 2 IC = IDP2 - I TI1 = CC ( I , 1 , K ) + CC ( IC , 4 , K ) TI2 = CC ( I , 1 , K ) - CC ( IC , 4 , K ) TI3 = CC ( I , 3 , K ) - CC ( IC , 2 , K ) TR4 = CC ( I , 3 , K ) + CC ( IC , 2 , K ) TR1 = CC ( I - 1 , 1 , K ) - CC ( IC - 1 , 4 , K ) TR2 = CC ( I - 1 , 1 , K ) + CC ( IC - 1 , 4 , K ) TI4 = CC ( I - 1 , 3 , K ) - CC ( IC - 1 , 2 , K ) TR3 = CC ( I - 1 , 3 , K ) + CC ( IC - 1 , 2 , K ) CH ( I - 1 , K , 1 ) = TR2 + TR3 CR3 = TR2 - TR3 CH ( I , K , 1 ) = TI2 + TI3 CI3 = TI2 - TI3 CR2 = TR1 - TR4 CR4 = TR1 + TR4 CI2 = TI1 + TI4 CI4 = TI1 - TI4 CH ( I - 1 , K , 2 ) = WA1 ( I - 2 ) * CR2 - WA1 ( I - 1 ) * CI2 CH ( I , K , 2 ) = WA1 ( I - 2 ) * CI2 + WA1 ( I - 1 ) * CR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 2 ) * CR3 - WA2 ( I - 1 ) * CI3 CH ( I , K , 3 ) = WA2 ( I - 2 ) * CI3 + WA2 ( I - 1 ) * CR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 2 ) * CR4 - WA3 ( I - 1 ) * CI4 CH ( I , K , 4 ) = WA3 ( I - 2 ) * CI4 + WA3 ( I - 1 ) * CR4 103 CONTINUE 104 CONTINUE IF ( MOD ( IDO , 2 ) . EQ . 1 ) RETURN 105 CONTINUE DO 106 K = 1 , L1 TI1 = CC ( 1 , 2 , K ) + CC ( 1 , 4 , K ) TI2 = CC ( 1 , 4 , K ) - CC ( 1 , 2 , K ) TR1 = CC ( IDO , 1 , K ) - CC ( IDO , 3 , K ) TR2 = CC ( IDO , 1 , K ) + CC ( IDO , 3 , K ) CH ( IDO , K , 1 ) = TR2 + TR2 CH ( IDO , K , 2 ) = SQRT2 * ( TR1 - TI1 ) CH ( IDO , K , 3 ) = TI2 + TI2 CH ( IDO , K , 4 ) = - SQRT2 * ( TR1 + TI1 ) 106 CONTINUE 107 RETURN END SUBROUTINE RADB5 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 , WA4 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 5 , L1 ) , CH ( IDO , L1 , 5 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) , WA4 ( 1 ) C     *** TR11=COS(2*PI/5), TI11=SIN(2*PI/5) C     *** TR12=COS(4*PI/5), TI12=SIN(4*PI/5) DATA TR11 , TI11 , TR12 , TI12 / 0.3090169943749474241D0 , + 0.95105651629515357212D0 , + - 0.8090169943749474241D0 , 0.58778525229247312917D0 / DO 101 K = 1 , L1 TI5 = CC ( 1 , 3 , K ) + CC ( 1 , 3 , K ) TI4 = CC ( 1 , 5 , K ) + CC ( 1 , 5 , K ) TR2 = CC ( IDO , 2 , K ) + CC ( IDO , 2 , K ) TR3 = CC ( IDO , 4 , K ) + CC ( IDO , 4 , K ) CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 + TR3 CR2 = CC ( 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CR3 = CC ( 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI5 = TI11 * TI5 + TI12 * TI4 CI4 = TI12 * TI5 - TI11 * TI4 CH ( 1 , K , 2 ) = CR2 - CI5 CH ( 1 , K , 3 ) = CR3 - CI4 CH ( 1 , K , 4 ) = CR3 + CI4 CH ( 1 , K , 5 ) = CR2 + CI5 101 CONTINUE IF ( IDO . EQ . 1 ) RETURN IDP2 = IDO + 2 DO 103 K = 1 , L1 DO 102 I = 3 , IDO , 2 IC = IDP2 - I TI5 = CC ( I , 3 , K ) + CC ( IC , 2 , K ) TI2 = CC ( I , 3 , K ) - CC ( IC , 2 , K ) TI4 = CC ( I , 5 , K ) + CC ( IC , 4 , K ) TI3 = CC ( I , 5 , K ) - CC ( IC , 4 , K ) TR5 = CC ( I - 1 , 3 , K ) - CC ( IC - 1 , 2 , K ) TR2 = CC ( I - 1 , 3 , K ) + CC ( IC - 1 , 2 , K ) TR4 = CC ( I - 1 , 5 , K ) - CC ( IC - 1 , 4 , K ) TR3 = CC ( I - 1 , 5 , K ) + CC ( IC - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 + TR3 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 + TI3 CR2 = CC ( I - 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( I , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( I - 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( I , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 DR3 = CR3 - CI4 DR4 = CR3 + CI4 DI3 = CI3 + CR4 DI4 = CI3 - CR4 DR5 = CR2 + CI5 DR2 = CR2 - CI5 DI5 = CI2 - CR5 DI2 = CI2 + CR5 CH ( I - 1 , K , 2 ) = WA1 ( I - 2 ) * DR2 - WA1 ( I - 1 ) * DI2 CH ( I , K , 2 ) = WA1 ( I - 2 ) * DI2 + WA1 ( I - 1 ) * DR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 2 ) * DR3 - WA2 ( I - 1 ) * DI3 CH ( I , K , 3 ) = WA2 ( I - 2 ) * DI3 + WA2 ( I - 1 ) * DR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 2 ) * DR4 - WA3 ( I - 1 ) * DI4 CH ( I , K , 4 ) = WA3 ( I - 2 ) * DI4 + WA3 ( I - 1 ) * DR4 CH ( I - 1 , K , 5 ) = WA4 ( I - 2 ) * DR5 - WA4 ( I - 1 ) * DI5 CH ( I , K , 5 ) = WA4 ( I - 2 ) * DI5 + WA4 ( I - 1 ) * DR5 102 CONTINUE 103 CONTINUE RETURN END SUBROUTINE RADBG ( IDO , IP , L1 , IDL1 , CC , C1 , C2 , CH , CH2 , WA ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , L1 , IP ) , CC ( IDO , IP , L1 ) , 1 C1 ( IDO , L1 , IP ) , C2 ( IDL1 , IP ), 2 CH2 ( IDL1 , IP ) , WA ( 1 ) DATA TPI / 6.28318530717958647692D0 / ARG = TPI / FLOAT ( IP ) DCP = COS ( ARG ) DSP = SIN ( ARG ) IDP2 = IDO + 2 NBD = ( IDO - 1 ) / 2 IPP2 = IP + 2 IPPH = ( IP + 1 ) / 2 IF ( IDO . LT . L1 ) GO TO 103 DO 102 K = 1 , L1 DO 101 I = 1 , IDO CH ( I , K , 1 ) = CC ( I , 1 , K ) 101 CONTINUE 102 CONTINUE GO TO 106 103 DO 105 I = 1 , IDO DO 104 K = 1 , L1 CH ( I , K , 1 ) = CC ( I , 1 , K ) 104 CONTINUE 105 CONTINUE 106 DO 108 J = 2 , IPPH JC = IPP2 - J J2 = J + J DO 107 K = 1 , L1 CH ( 1 , K , J ) = CC ( IDO , J2 - 2 , K ) + CC ( IDO , J2 - 2 , K ) CH ( 1 , K , JC ) = CC ( 1 , J2 - 1 , K ) + CC ( 1 , J2 - 1 , K ) 107 CONTINUE 108 CONTINUE IF ( IDO . EQ . 1 ) GO TO 116 IF ( NBD . LT . L1 ) GO TO 112 DO 111 J = 2 , IPPH JC = IPP2 - J DO 110 K = 1 , L1 DO 109 I = 3 , IDO , 2 IC = IDP2 - I CH ( I - 1 , K , J ) = CC ( I - 1 , 2 * J - 1 , K ) + CC ( IC - 1 , 2 * J - 2 , K ) CH ( I - 1 , K , JC ) = CC ( I - 1 , 2 * J - 1 , K ) - CC ( IC - 1 , 2 * J - 2 , K ) CH ( I , K , J ) = CC ( I , 2 * J - 1 , K ) - CC ( IC , 2 * J - 2 , K ) CH ( I , K , JC ) = CC ( I , 2 * J - 1 , K ) + CC ( IC , 2 * J - 2 , K ) 109 CONTINUE 110 CONTINUE 111 CONTINUE GO TO 116 112 DO 115 J = 2 , IPPH JC = IPP2 - J DO 114 I = 3 , IDO , 2 IC = IDP2 - I DO 113 K = 1 , L1 CH ( I - 1 , K , J ) = CC ( I - 1 , 2 * J - 1 , K ) + CC ( IC - 1 , 2 * J - 2 , K ) CH ( I - 1 , K , JC ) = CC ( I - 1 , 2 * J - 1 , K ) - CC ( IC - 1 , 2 * J - 2 , K ) CH ( I , K , J ) = CC ( I , 2 * J - 1 , K ) - CC ( IC , 2 * J - 2 , K ) CH ( I , K , JC ) = CC ( I , 2 * J - 1 , K ) + CC ( IC , 2 * J - 2 , K ) 113 CONTINUE 114 CONTINUE 115 CONTINUE 116 AR1 = 1.0D0 AI1 = 0.0D0 DO 120 L = 2 , IPPH LC = IPP2 - L AR1H = DCP * AR1 - DSP * AI1 AI1 = DCP * AI1 + DSP * AR1 AR1 = AR1H DO 117 IK = 1 , IDL1 C2 ( IK , L ) = CH2 ( IK , 1 ) + AR1 * CH2 ( IK , 2 ) C2 ( IK , LC ) = AI1 * CH2 ( IK , IP ) 117 CONTINUE DC2 = AR1 DS2 = AI1 AR2 = AR1 AI2 = AI1 DO 119 J = 3 , IPPH JC = IPP2 - J AR2H = DC2 * AR2 - DS2 * AI2 AI2 = DC2 * AI2 + DS2 * AR2 AR2 = AR2H DO 118 IK = 1 , IDL1 C2 ( IK , L ) = C2 ( IK , L ) + AR2 * CH2 ( IK , J ) C2 ( IK , LC ) = C2 ( IK , LC ) + AI2 * CH2 ( IK , JC ) 118 CONTINUE 119 CONTINUE 120 CONTINUE DO 122 J = 2 , IPPH DO 121 IK = 1 , IDL1 CH2 ( IK , 1 ) = CH2 ( IK , 1 ) + CH2 ( IK , J ) 121 CONTINUE 122 CONTINUE DO 124 J = 2 , IPPH JC = IPP2 - J DO 123 K = 1 , L1 CH ( 1 , K , J ) = C1 ( 1 , K , J ) - C1 ( 1 , K , JC ) CH ( 1 , K , JC ) = C1 ( 1 , K , J ) + C1 ( 1 , K , JC ) 123 CONTINUE 124 CONTINUE IF ( IDO . EQ . 1 ) GO TO 132 IF ( NBD . LT . L1 ) GO TO 128 DO 127 J = 2 , IPPH JC = IPP2 - J DO 126 K = 1 , L1 DO 125 I = 3 , IDO , 2 CH ( I - 1 , K , J ) = C1 ( I - 1 , K , J ) - C1 ( I , K , JC ) CH ( I - 1 , K , JC ) = C1 ( I - 1 , K , J ) + C1 ( I , K , JC ) CH ( I , K , J ) = C1 ( I , K , J ) + C1 ( I - 1 , K , JC ) CH ( I , K , JC ) = C1 ( I , K , J ) - C1 ( I - 1 , K , JC ) 125 CONTINUE 126 CONTINUE 127 CONTINUE GO TO 132 128 DO 131 J = 2 , IPPH JC = IPP2 - J DO 130 I = 3 , IDO , 2 DO 129 K = 1 , L1 CH ( I - 1 , K , J ) = C1 ( I - 1 , K , J ) - C1 ( I , K , JC ) CH ( I - 1 , K , JC ) = C1 ( I - 1 , K , J ) + C1 ( I , K , JC ) CH ( I , K , J ) = C1 ( I , K , J ) + C1 ( I - 1 , K , JC ) CH ( I , K , JC ) = C1 ( I , K , J ) - C1 ( I - 1 , K , JC ) 129 CONTINUE 130 CONTINUE 131 CONTINUE 132 CONTINUE IF ( IDO . EQ . 1 ) RETURN DO 133 IK = 1 , IDL1 C2 ( IK , 1 ) = CH2 ( IK , 1 ) 133 CONTINUE DO 135 J = 2 , IP DO 134 K = 1 , L1 C1 ( 1 , K , J ) = CH ( 1 , K , J ) 134 CONTINUE 135 CONTINUE IF ( NBD . GT . L1 ) GO TO 139 IS = - IDO DO 138 J = 2 , IP IS = IS + IDO IDIJ = IS DO 137 I = 3 , IDO , 2 IDIJ = IDIJ + 2 DO 136 K = 1 , L1 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) - WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) + WA ( IDIJ ) * CH ( I - 1 , K , J ) 136 CONTINUE 137 CONTINUE 138 CONTINUE GO TO 143 139 IS = - IDO DO 142 J = 2 , IP IS = IS + IDO DO 141 K = 1 , L1 IDIJ = IS DO 140 I = 3 , IDO , 2 IDIJ = IDIJ + 2 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) - WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) + WA ( IDIJ ) * CH ( I - 1 , K , J ) 140 CONTINUE 141 CONTINUE 142 CONTINUE 143 RETURN END SUBROUTINE RADF2 ( IDO , L1 , CC , CH , WA1 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , 2 , L1 ) , CC ( IDO , L1 , 2 ) , 1 WA1 ( 1 ) DO 101 K = 1 , L1 CH ( 1 , 1 , K ) = CC ( 1 , K , 1 ) + CC ( 1 , K , 2 ) CH ( IDO , 2 , K ) = CC ( 1 , K , 1 ) - CC ( 1 , K , 2 ) 101 CONTINUE IF ( IDO - 2 ) 107 , 105 , 102 102 IDP2 = IDO + 2 DO 104 K = 1 , L1 DO 103 I = 3 , IDO , 2 IC = IDP2 - I TR2 = WA1 ( I - 2 ) * CC ( I - 1 , K , 2 ) + WA1 ( I - 1 ) * CC ( I , K , 2 ) TI2 = WA1 ( I - 2 ) * CC ( I , K , 2 ) - WA1 ( I - 1 ) * CC ( I - 1 , K , 2 ) CH ( I , 1 , K ) = CC ( I , K , 1 ) + TI2 CH ( IC , 2 , K ) = TI2 - CC ( I , K , 1 ) CH ( I - 1 , 1 , K ) = CC ( I - 1 , K , 1 ) + TR2 CH ( IC - 1 , 2 , K ) = CC ( I - 1 , K , 1 ) - TR2 103 CONTINUE 104 CONTINUE IF ( MOD ( IDO , 2 ) . EQ . 1 ) RETURN 105 DO 106 K = 1 , L1 CH ( 1 , 2 , K ) = - CC ( IDO , K , 2 ) CH ( IDO , 1 , K ) = CC ( IDO , K , 1 ) 106 CONTINUE 107 RETURN END SUBROUTINE RADF3 ( IDO , L1 , CC , CH , WA1 , WA2 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , 3 , L1 ) , CC ( IDO , L1 , 3 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) C     *** TAUI IS -SQRT(3)/2 *** DATA TAUR , TAUI /- 0.5D0 , 0.86602540378443864676D0 / DO 101 K = 1 , L1 CR2 = CC ( 1 , K , 2 ) + CC ( 1 , K , 3 ) CH ( 1 , 1 , K ) = CC ( 1 , K , 1 ) + CR2 CH ( 1 , 3 , K ) = TAUI * ( CC ( 1 , K , 3 ) - CC ( 1 , K , 2 )) CH ( IDO , 2 , K ) = CC ( 1 , K , 1 ) + TAUR * CR2 101 CONTINUE IF ( IDO . EQ . 1 ) RETURN IDP2 = IDO + 2 DO 103 K = 1 , L1 DO 102 I = 3 , IDO , 2 IC = IDP2 - I DR2 = WA1 ( I - 2 ) * CC ( I - 1 , K , 2 ) + WA1 ( I - 1 ) * CC ( I , K , 2 ) DI2 = WA1 ( I - 2 ) * CC ( I , K , 2 ) - WA1 ( I - 1 ) * CC ( I - 1 , K , 2 ) DR3 = WA2 ( I - 2 ) * CC ( I - 1 , K , 3 ) + WA2 ( I - 1 ) * CC ( I , K , 3 ) DI3 = WA2 ( I - 2 ) * CC ( I , K , 3 ) - WA2 ( I - 1 ) * CC ( I - 1 , K , 3 ) CR2 = DR2 + DR3 CI2 = DI2 + DI3 CH ( I - 1 , 1 , K ) = CC ( I - 1 , K , 1 ) + CR2 CH ( I , 1 , K ) = CC ( I , K , 1 ) + CI2 TR2 = CC ( I - 1 , K , 1 ) + TAUR * CR2 TI2 = CC ( I , K , 1 ) + TAUR * CI2 TR3 = TAUI * ( DI2 - DI3 ) TI3 = TAUI * ( DR3 - DR2 ) CH ( I - 1 , 3 , K ) = TR2 + TR3 CH ( IC - 1 , 2 , K ) = TR2 - TR3 CH ( I , 3 , K ) = TI2 + TI3 CH ( IC , 2 , K ) = TI3 - TI2 102 CONTINUE 103 CONTINUE RETURN END SUBROUTINE RADF4 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , L1 , 4 ) , CH ( IDO , 4 , L1 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) DATA HSQT2 / 0.70710678118654752440D0 / DO 101 K = 1 , L1 TR1 = CC ( 1 , K , 2 ) + CC ( 1 , K , 4 ) TR2 = CC ( 1 , K , 1 ) + CC ( 1 , K , 3 ) CH ( 1 , 1 , K ) = TR1 + TR2 CH ( IDO , 4 , K ) = TR2 - TR1 CH ( IDO , 2 , K ) = CC ( 1 , K , 1 ) - CC ( 1 , K , 3 ) CH ( 1 , 3 , K ) = CC ( 1 , K , 4 ) - CC ( 1 , K , 2 ) 101 CONTINUE IF ( IDO - 2 ) 107 , 105 , 102 102 IDP2 = IDO + 2 DO 104 K = 1 , L1 DO 103 I = 3 , IDO , 2 IC = IDP2 - I CR2 = WA1 ( I - 2 ) * CC ( I - 1 , K , 2 ) + WA1 ( I - 1 ) * CC ( I , K , 2 ) CI2 = WA1 ( I - 2 ) * CC ( I , K , 2 ) - WA1 ( I - 1 ) * CC ( I - 1 , K , 2 ) CR3 = WA2 ( I - 2 ) * CC ( I - 1 , K , 3 ) + WA2 ( I - 1 ) * CC ( I , K , 3 ) CI3 = WA2 ( I - 2 ) * CC ( I , K , 3 ) - WA2 ( I - 1 ) * CC ( I - 1 , K , 3 ) CR4 = WA3 ( I - 2 ) * CC ( I - 1 , K , 4 ) + WA3 ( I - 1 ) * CC ( I , K , 4 ) CI4 = WA3 ( I - 2 ) * CC ( I , K , 4 ) - WA3 ( I - 1 ) * CC ( I - 1 , K , 4 ) TR1 = CR2 + CR4 TR4 = CR4 - CR2 TI1 = CI2 + CI4 TI4 = CI2 - CI4 TI2 = CC ( I , K , 1 ) + CI3 TI3 = CC ( I , K , 1 ) - CI3 TR2 = CC ( I - 1 , K , 1 ) + CR3 TR3 = CC ( I - 1 , K , 1 ) - CR3 CH ( I - 1 , 1 , K ) = TR1 + TR2 CH ( IC - 1 , 4 , K ) = TR2 - TR1 CH ( I , 1 , K ) = TI1 + TI2 CH ( IC , 4 , K ) = TI1 - TI2 CH ( I - 1 , 3 , K ) = TI4 + TR3 CH ( IC - 1 , 2 , K ) = TR3 - TI4 CH ( I , 3 , K ) = TR4 + TI3 CH ( IC , 2 , K ) = TR4 - TI3 103 CONTINUE 104 CONTINUE IF ( MOD ( IDO , 2 ) . EQ . 1 ) RETURN 105 CONTINUE DO 106 K = 1 , L1 TI1 = - HSQT2 * ( CC ( IDO , K , 2 ) + CC ( IDO , K , 4 )) TR1 = HSQT2 * ( CC ( IDO , K , 2 ) - CC ( IDO , K , 4 )) CH ( IDO , 1 , K ) = TR1 + CC ( IDO , K , 1 ) CH ( IDO , 3 , K ) = CC ( IDO , K , 1 ) - TR1 CH ( 1 , 2 , K ) = TI1 - CC ( IDO , K , 3 ) CH ( 1 , 4 , K ) = TI1 + CC ( IDO , K , 3 ) 106 CONTINUE 107 RETURN END SUBROUTINE RADF5 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 , WA4 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , L1 , 5 ) , CH ( IDO , 5 , L1 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) , WA4 ( 1 ) DATA TR11 , TI11 , TR12 , TI12 / 0.3090169943749474241D0 , + 0.95105651629515357212D0 , 1 - 0.8090169943749474241D0 , 0.58778525229247312917D0 / DO 101 K = 1 , L1 CR2 = CC ( 1 , K , 5 ) + CC ( 1 , K , 2 ) CI5 = CC ( 1 , K , 5 ) - CC ( 1 , K , 2 ) CR3 = CC ( 1 , K , 4 ) + CC ( 1 , K , 3 ) CI4 = CC ( 1 , K , 4 ) - CC ( 1 , K , 3 ) CH ( 1 , 1 , K ) = CC ( 1 , K , 1 ) + CR2 + CR3 CH ( IDO , 2 , K ) = CC ( 1 , K , 1 ) + TR11 * CR2 + TR12 * CR3 CH ( 1 , 3 , K ) = TI11 * CI5 + TI12 * CI4 CH ( IDO , 4 , K ) = CC ( 1 , K , 1 ) + TR12 * CR2 + TR11 * CR3 CH ( 1 , 5 , K ) = TI12 * CI5 - TI11 * CI4 101 CONTINUE IF ( IDO . EQ . 1 ) RETURN IDP2 = IDO + 2 DO 103 K = 1 , L1 DO 102 I = 3 , IDO , 2 IC = IDP2 - I DR2 = WA1 ( I - 2 ) * CC ( I - 1 , K , 2 ) + WA1 ( I - 1 ) * CC ( I , K , 2 ) DI2 = WA1 ( I - 2 ) * CC ( I , K , 2 ) - WA1 ( I - 1 ) * CC ( I - 1 , K , 2 ) DR3 = WA2 ( I - 2 ) * CC ( I - 1 , K , 3 ) + WA2 ( I - 1 ) * CC ( I , K , 3 ) DI3 = WA2 ( I - 2 ) * CC ( I , K , 3 ) - WA2 ( I - 1 ) * CC ( I - 1 , K , 3 ) DR4 = WA3 ( I - 2 ) * CC ( I - 1 , K , 4 ) + WA3 ( I - 1 ) * CC ( I , K , 4 ) DI4 = WA3 ( I - 2 ) * CC ( I , K , 4 ) - WA3 ( I - 1 ) * CC ( I - 1 , K , 4 ) DR5 = WA4 ( I - 2 ) * CC ( I - 1 , K , 5 ) + WA4 ( I - 1 ) * CC ( I , K , 5 ) DI5 = WA4 ( I - 2 ) * CC ( I , K , 5 ) - WA4 ( I - 1 ) * CC ( I - 1 , K , 5 ) CR2 = DR2 + DR5 CI5 = DR5 - DR2 CR5 = DI2 - DI5 CI2 = DI2 + DI5 CR3 = DR3 + DR4 CI4 = DR4 - DR3 CR4 = DI3 - DI4 CI3 = DI3 + DI4 CH ( I - 1 , 1 , K ) = CC ( I - 1 , K , 1 ) + CR2 + CR3 CH ( I , 1 , K ) = CC ( I , K , 1 ) + CI2 + CI3 TR2 = CC ( I - 1 , K , 1 ) + TR11 * CR2 + TR12 * CR3 TI2 = CC ( I , K , 1 ) + TR11 * CI2 + TR12 * CI3 TR3 = CC ( I - 1 , K , 1 ) + TR12 * CR2 + TR11 * CR3 TI3 = CC ( I , K , 1 ) + TR12 * CI2 + TR11 * CI3 TR5 = TI11 * CR5 + TI12 * CR4 TI5 = TI11 * CI5 + TI12 * CI4 TR4 = TI12 * CR5 - TI11 * CR4 TI4 = TI12 * CI5 - TI11 * CI4 CH ( I - 1 , 3 , K ) = TR2 + TR5 CH ( IC - 1 , 2 , K ) = TR2 - TR5 CH ( I , 3 , K ) = TI2 + TI5 CH ( IC , 2 , K ) = TI5 - TI2 CH ( I - 1 , 5 , K ) = TR3 + TR4 CH ( IC - 1 , 4 , K ) = TR3 - TR4 CH ( I , 5 , K ) = TI3 + TI4 CH ( IC , 4 , K ) = TI4 - TI3 102 CONTINUE 103 CONTINUE RETURN END SUBROUTINE RADFG ( IDO , IP , L1 , IDL1 , CC , C1 , C2 , CH , CH2 , WA ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , L1 , IP ) , CC ( IDO , IP , L1 ) , 1 C1 ( IDO , L1 , IP ) , C2 ( IDL1 , IP ), 2 CH2 ( IDL1 , IP ) , WA ( 1 ) DATA TPI / 6.28318530717958647692D0 / ARG = TPI / FLOAT ( IP ) DCP = COS ( ARG ) DSP = SIN ( ARG ) IPPH = ( IP + 1 ) / 2 IPP2 = IP + 2 IDP2 = IDO + 2 NBD = ( IDO - 1 ) / 2 IF ( IDO . EQ . 1 ) GO TO 119 DO 101 IK = 1 , IDL1 CH2 ( IK , 1 ) = C2 ( IK , 1 ) 101 CONTINUE DO 103 J = 2 , IP DO 102 K = 1 , L1 CH ( 1 , K , J ) = C1 ( 1 , K , J ) 102 CONTINUE 103 CONTINUE IF ( NBD . GT . L1 ) GO TO 107 IS = - IDO DO 106 J = 2 , IP IS = IS + IDO IDIJ = IS DO 105 I = 3 , IDO , 2 IDIJ = IDIJ + 2 DO 104 K = 1 , L1 CH ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * C1 ( I - 1 , K , J ) + WA ( IDIJ ) * C1 ( I , K , J ) CH ( I , K , J ) = WA ( IDIJ - 1 ) * C1 ( I , K , J ) - WA ( IDIJ ) * C1 ( I - 1 , K , J ) 104 CONTINUE 105 CONTINUE 106 CONTINUE GO TO 111 107 IS = - IDO DO 110 J = 2 , IP IS = IS + IDO DO 109 K = 1 , L1 IDIJ = IS DO 108 I = 3 , IDO , 2 IDIJ = IDIJ + 2 CH ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * C1 ( I - 1 , K , J ) + WA ( IDIJ ) * C1 ( I , K , J ) CH ( I , K , J ) = WA ( IDIJ - 1 ) * C1 ( I , K , J ) - WA ( IDIJ ) * C1 ( I - 1 , K , J ) 108 CONTINUE 109 CONTINUE 110 CONTINUE 111 IF ( NBD . LT . L1 ) GO TO 115 DO 114 J = 2 , IPPH JC = IPP2 - J DO 113 K = 1 , L1 DO 112 I = 3 , IDO , 2 C1 ( I - 1 , K , J ) = CH ( I - 1 , K , J ) + CH ( I - 1 , K , JC ) C1 ( I - 1 , K , JC ) = CH ( I , K , J ) - CH ( I , K , JC ) C1 ( I , K , J ) = CH ( I , K , J ) + CH ( I , K , JC ) C1 ( I , K , JC ) = CH ( I - 1 , K , JC ) - CH ( I - 1 , K , J ) 112 CONTINUE 113 CONTINUE 114 CONTINUE GO TO 121 115 DO 118 J = 2 , IPPH JC = IPP2 - J DO 117 I = 3 , IDO , 2 DO 116 K = 1 , L1 C1 ( I - 1 , K , J ) = CH ( I - 1 , K , J ) + CH ( I - 1 , K , JC ) C1 ( I - 1 , K , JC ) = CH ( I , K , J ) - CH ( I , K , JC ) C1 ( I , K , J ) = CH ( I , K , J ) + CH ( I , K , JC ) C1 ( I , K , JC ) = CH ( I - 1 , K , JC ) - CH ( I - 1 , K , J ) 116 CONTINUE 117 CONTINUE 118 CONTINUE GO TO 121 119 DO 120 IK = 1 , IDL1 C2 ( IK , 1 ) = CH2 ( IK , 1 ) 120 CONTINUE 121 DO 123 J = 2 , IPPH JC = IPP2 - J DO 122 K = 1 , L1 C1 ( 1 , K , J ) = CH ( 1 , K , J ) + CH ( 1 , K , JC ) C1 ( 1 , K , JC ) = CH ( 1 , K , JC ) - CH ( 1 , K , J ) 122 CONTINUE 123 CONTINUE C AR1 = 1.0D0 AI1 = 0.0D0 DO 127 L = 2 , IPPH LC = IPP2 - L AR1H = DCP * AR1 - DSP * AI1 AI1 = DCP * AI1 + DSP * AR1 AR1 = AR1H DO 124 IK = 1 , IDL1 CH2 ( IK , L ) = C2 ( IK , 1 ) + AR1 * C2 ( IK , 2 ) CH2 ( IK , LC ) = AI1 * C2 ( IK , IP ) 124 CONTINUE DC2 = AR1 DS2 = AI1 AR2 = AR1 AI2 = AI1 DO 126 J = 3 , IPPH JC = IPP2 - J AR2H = DC2 * AR2 - DS2 * AI2 AI2 = DC2 * AI2 + DS2 * AR2 AR2 = AR2H DO 125 IK = 1 , IDL1 CH2 ( IK , L ) = CH2 ( IK , L ) + AR2 * C2 ( IK , J ) CH2 ( IK , LC ) = CH2 ( IK , LC ) + AI2 * C2 ( IK , JC ) 125 CONTINUE 126 CONTINUE 127 CONTINUE DO 129 J = 2 , IPPH DO 128 IK = 1 , IDL1 CH2 ( IK , 1 ) = CH2 ( IK , 1 ) + C2 ( IK , J ) 128 CONTINUE 129 CONTINUE C IF ( IDO . LT . L1 ) GO TO 132 DO 131 K = 1 , L1 DO 130 I = 1 , IDO CC ( I , 1 , K ) = CH ( I , K , 1 ) 130 CONTINUE 131 CONTINUE GO TO 135 132 DO 134 I = 1 , IDO DO 133 K = 1 , L1 CC ( I , 1 , K ) = CH ( I , K , 1 ) 133 CONTINUE 134 CONTINUE 135 DO 137 J = 2 , IPPH JC = IPP2 - J J2 = J + J DO 136 K = 1 , L1 CC ( IDO , J2 - 2 , K ) = CH ( 1 , K , J ) CC ( 1 , J2 - 1 , K ) = CH ( 1 , K , JC ) 136 CONTINUE 137 CONTINUE IF ( IDO . EQ . 1 ) RETURN IF ( NBD . LT . L1 ) GO TO 141 DO 140 J = 2 , IPPH JC = IPP2 - J J2 = J + J DO 139 K = 1 , L1 DO 138 I = 3 , IDO , 2 IC = IDP2 - I CC ( I - 1 , J2 - 1 , K ) = CH ( I - 1 , K , J ) + CH ( I - 1 , K , JC ) CC ( IC - 1 , J2 - 2 , K ) = CH ( I - 1 , K , J ) - CH ( I - 1 , K , JC ) CC ( I , J2 - 1 , K ) = CH ( I , K , J ) + CH ( I , K , JC ) CC ( IC , J2 - 2 , K ) = CH ( I , K , JC ) - CH ( I , K , J ) 138 CONTINUE 139 CONTINUE 140 CONTINUE RETURN 141 DO 144 J = 2 , IPPH JC = IPP2 - J J2 = J + J DO 143 I = 3 , IDO , 2 IC = IDP2 - I DO 142 K = 1 , L1 CC ( I - 1 , J2 - 1 , K ) = CH ( I - 1 , K , J ) + CH ( I - 1 , K , JC ) CC ( IC - 1 , J2 - 2 , K ) = CH ( I - 1 , K , J ) - CH ( I - 1 , K , JC ) CC ( I , J2 - 1 , K ) = CH ( I , K , J ) + CH ( I , K , JC ) CC ( IC , J2 - 2 , K ) = CH ( I , K , JC ) - CH ( I , K , J ) 142 CONTINUE 143 CONTINUE 144 CONTINUE RETURN END SUBROUTINE RFFTB1 ( N , C , CH , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( * ) , C ( * ) , WA ( * ) , IFAC ( * ) NF = IFAC ( 2 ) NA = 0 L1 = 1 IW = 1 DO 116 K1 = 1 , NF IP = IFAC ( K1 + 2 ) L2 = IP * L1 IDO = N / L2 IDL1 = IDO * L1 IF ( IP . NE . 4 ) GO TO 103 IX2 = IW + IDO IX3 = IX2 + IDO IF ( NA . NE . 0 ) GO TO 101 CALL RADB4 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 102 101 CALL RADB4 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 )) 102 NA = 1 - NA GO TO 115 103 IF ( IP . NE . 2 ) GO TO 106 IF ( NA . NE . 0 ) GO TO 104 CALL RADB2 ( IDO , L1 , C , CH , WA ( IW )) GO TO 105 104 CALL RADB2 ( IDO , L1 , CH , C , WA ( IW )) 105 NA = 1 - NA GO TO 115 106 IF ( IP . NE . 3 ) GO TO 109 IX2 = IW + IDO IF ( NA . NE . 0 ) GO TO 107 CALL RADB3 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 )) GO TO 108 107 CALL RADB3 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 )) 108 NA = 1 - NA GO TO 115 109 IF ( IP . NE . 5 ) GO TO 112 IX2 = IW + IDO IX3 = IX2 + IDO IX4 = IX3 + IDO IF ( NA . NE . 0 ) GO TO 110 CALL RADB5 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 111 110 CALL RADB5 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) 111 NA = 1 - NA GO TO 115 112 IF ( NA . NE . 0 ) GO TO 113 CALL RADBG ( IDO , IP , L1 , IDL1 , C , C , C , CH , CH , WA ( IW )) GO TO 114 113 CALL RADBG ( IDO , IP , L1 , IDL1 , CH , CH , CH , C , C , WA ( IW )) 114 IF ( IDO . EQ . 1 ) NA = 1 - NA 115 L1 = L2 IW = IW + ( IP - 1 ) * IDO 116 CONTINUE IF ( NA . EQ . 0 ) RETURN DO 117 I = 1 , N C ( I ) = CH ( I ) 117 CONTINUE RETURN END SUBROUTINE RFFTF1 ( N , C , CH , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( * ) , C ( * ) , WA ( * ) , IFAC ( * ) NF = IFAC ( 2 ) NA = 1 L2 = N IW = N DO 111 K1 = 1 , NF KH = NF - K1 IP = IFAC ( KH + 3 ) L1 = L2 / IP IDO = N / L2 IDL1 = IDO * L1 IW = IW - ( IP - 1 ) * IDO NA = 1 - NA IF ( IP . NE . 4 ) GO TO 102 IX2 = IW + IDO IX3 = IX2 + IDO IF ( NA . NE . 0 ) GO TO 101 CALL RADF4 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 110 101 CALL RADF4 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 110 102 IF ( IP . NE . 2 ) GO TO 104 IF ( NA . NE . 0 ) GO TO 103 CALL RADF2 ( IDO , L1 , C , CH , WA ( IW )) GO TO 110 103 CALL RADF2 ( IDO , L1 , CH , C , WA ( IW )) GO TO 110 104 IF ( IP . NE . 3 ) GO TO 106 IX2 = IW + IDO IF ( NA . NE . 0 ) GO TO 105 CALL RADF3 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 )) GO TO 110 105 CALL RADF3 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 )) GO TO 110 106 IF ( IP . NE . 5 ) GO TO 108 IX2 = IW + IDO IX3 = IX2 + IDO IX4 = IX3 + IDO IF ( NA . NE . 0 ) GO TO 107 CALL RADF5 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 110 107 CALL RADF5 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 110 108 IF ( IDO . EQ . 1 ) NA = 1 - NA IF ( NA . NE . 0 ) GO TO 109 CALL RADFG ( IDO , IP , L1 , IDL1 , C , C , C , CH , CH , WA ( IW )) NA = 1 GO TO 110 109 CALL RADFG ( IDO , IP , L1 , IDL1 , CH , CH , CH , C , C , WA ( IW )) NA = 0 110 L2 = L1 111 CONTINUE IF ( NA . EQ . 1 ) RETURN DO 112 I = 1 , N C ( I ) = CH ( I ) 112 CONTINUE RETURN END SUBROUTINE RFFTI1 ( N , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION WA ( * ) , IFAC ( * ) , NTRYH ( 4 ) DATA NTRYH ( 1 ), NTRYH ( 2 ), NTRYH ( 3 ), NTRYH ( 4 ) / 4 , 2 , 3 , 5 / NL = N NF = 0 J = 0 101 J = J + 1 IF ( J - 4 ) 102 , 102 , 103 102 NTRY = NTRYH ( J ) GO TO 104 103 NTRY = NTRY + 2 104 NQ = NL / NTRY NR = NL - NTRY * NQ IF ( NR ) 101 , 105 , 101 105 NF = NF + 1 IFAC ( NF + 2 ) = NTRY NL = NQ IF ( NTRY . NE . 2 ) GO TO 107 IF ( NF . EQ . 1 ) GO TO 107 DO 106 I = 2 , NF IB = NF - I + 2 IFAC ( IB + 2 ) = IFAC ( IB + 1 ) 106 CONTINUE IFAC ( 3 ) = 2 107 IF ( NL . NE . 1 ) GO TO 104 IFAC ( 1 ) = N IFAC ( 2 ) = NF TPI = 6.28318530717958647692D0 ARGH = TPI / FLOAT ( N ) IS = 0 NFM1 = NF - 1 L1 = 1 IF ( NFM1 . EQ . 0 ) RETURN DO 110 K1 = 1 , NFM1 IP = IFAC ( K1 + 2 ) LD = 0 L2 = L1 * IP IDO = N / L2 IPM = IP - 1 DO 109 J = 1 , IPM LD = LD + L1 I = IS ARGLD = FLOAT ( LD ) * ARGH FI = 0.0D0 DO 108 II = 3 , IDO , 2 I = I + 2 FI = FI + 1.0D0 ARG = FI * ARGLD WA ( I - 1 ) = COS ( ARG ) WA ( I ) = SIN ( ARG ) 108 CONTINUE IS = IS + IDO 109 CONTINUE L1 = L2 110 CONTINUE RETURN END SUBROUTINE ZFFTB ( N , C , WSAVE ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION C ( 1 ) , WSAVE ( 1 ) IF ( N . EQ . 1 ) RETURN IW1 = N + N + 1 IW2 = IW1 + N + N CALL CFFTB1 ( N , C , WSAVE , WSAVE ( IW1 ), WSAVE ( IW2 )) RETURN END SUBROUTINE ZFFTF ( N , C , WSAVE ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION C ( 1 ) , WSAVE ( 1 ) IF ( N . EQ . 1 ) RETURN IW1 = N + N + 1 IW2 = IW1 + N + N CALL CFFTF1 ( N , C , WSAVE , WSAVE ( IW1 ), WSAVE ( IW2 )) RETURN END SUBROUTINE ZFFTI ( N , WSAVE ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION WSAVE ( 1 ) IF ( N . EQ . 1 ) RETURN IW1 = N + N + 1 IW2 = IW1 + N + N CALL CFFTI1 ( N , WSAVE ( IW1 ), WSAVE ( IW2 )) RETURN END","tags":"","loc":"sourcefile/dfftpack.f.html","title":"dfftpack.f – LibPFASST"},{"text":"N-dimensional complex array encapsulation Contents Modules pf_mod_zndarray Source Code pf_zndarray_encap.f90 Source Code !!  N-dimensional complex array encapsulation ! ! This file is part of LIBPFASST. ! !> N-dimensional complex array encapsulation. !! !! When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'shape' attribute to create a new array with that !! shape.  Thus, the 'shape' attributes of the PFASST levels should be !! set appropriately.  For example, before calling pf_pfasst_run we can !! set the shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%shape(2)) !!   pf%levels(1)%shape = [ 3, 10 ] !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to the encapsulated array  without !! performing any copies. !! module pf_mod_zndarray use iso_c_binding use pf_mod_dtype use pf_mod_utils implicit none !>  Factory for making zndarray type , extends ( pf_factory_t ) :: zndarray_factory contains procedure :: create_single => zndarray_create_single procedure :: create_array => zndarray_create_array procedure :: destroy_single => zndarray_destroy_single procedure :: destroy_array => zndarray_destroy_array end type zndarray_factory !>  Complex ndarray type , extends ( pf_encap_t ) :: zndarray integer :: dim integer , allocatable :: shape (:) complex ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => zndarray_setval procedure :: copy => zndarray_copy procedure :: norm => zndarray_norm procedure :: pack => zndarray_pack procedure :: unpack => zndarray_unpack procedure :: axpy => zndarray_axpy procedure :: eprint => zndarray_eprint procedure :: write_to_disk end type zndarray contains function cast_as_zndarray ( encap_polymorph ) result ( zndarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( zndarray ), pointer :: zndarray_obj select type ( encap_polymorph ) type is ( zndarray ) zndarray_obj => encap_polymorph end select end function cast_as_zndarray !> Allocates complex ndarray subroutine zndarray_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) type ( zndarray ), pointer :: zndarray_obj select type ( q ) class is ( zndarray ) allocate ( q % shape ( size ( shape ))) allocate ( q % flatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape q % flatarray = cmplx ( 0.0 , 0.0 , pfdp ) end select nullify ( zndarray_obj ) end subroutine zndarray_build subroutine zndarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( zndarray ), pointer :: zndarray_obj zndarray_obj => cast_as_zndarray ( encap ) deallocate ( zndarray_obj % shape ) deallocate ( zndarray_obj % flatarray ) nullify ( zndarray_obj ) end subroutine zndarray_destroy !> Wrapper routine for allocation of a single zndarray type array subroutine zndarray_create_single ( this , x , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( zndarray :: x ) call zndarray_build ( x , shape ) end subroutine zndarray_create_single !> Wrapper routine for looped allocation of many zndarray type arrays subroutine zndarray_create_array ( this , x , n , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( zndarray :: x ( n )) do i = 1 , n call zndarray_build ( x ( i ), shape ) end do end subroutine zndarray_create_array subroutine zndarray_destroy_single ( this , x ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( zndarray ) deallocate ( x % shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine zndarray_destroy_single !> Wrapper routine for looped allocation of many zndarray type arrays subroutine zndarray_destroy_array ( this , x ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( zndarray ) do i = 1 , size ( x ) deallocate ( x ( i )% shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine zndarray_destroy_array !> Set solution value. subroutine zndarray_setval ( this , val , flags ) class ( zndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags complex ( pfdp ) :: zval zval = cmplx ( val , 0.0 , pfdp ) this % flatarray = zval end subroutine zndarray_setval !> Copy solution value. subroutine zndarray_copy ( this , src , flags ) class ( zndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags class ( zndarray ), pointer :: zndarray_src zndarray_src => cast_as_zndarray ( src ) this % flatarray = zndarray_src % flatarray end subroutine zndarray_copy !> Pack solution q into a flat array. subroutine zndarray_pack ( this , z , flags ) class ( zndarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: i do i = 1 , product ( this % shape ) z ( 2 * i - 1 ) = real ( this % flatarray ( i )) z ( 2 * i ) = aimag ( this % flatarray ( i )) end do end subroutine zndarray_pack ! Unpack solution from a flat array. subroutine zndarray_unpack ( this , z , flags ) class ( zndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: i do i = 1 , product ( this % shape ) this % flatarray ( i ) = cmplx ( z ( 2 * i - 1 ), z ( 2 * i ), pfdp ) enddo end subroutine zndarray_unpack ! Compute norm of solution function zndarray_norm ( this , flags ) result ( norm ) class ( zndarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function zndarray_norm ! Compute y = a x + y where a is a scalar and x and y are solutions. subroutine zndarray_axpy ( this , a , x , flags ) class ( zndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags class ( zndarray ), pointer :: zndarray_obj zndarray_obj => cast_as_zndarray ( x ) this % flatarray = a * zndarray_obj % flatarray + this % flatarray end subroutine zndarray_axpy subroutine zndarray_eprint ( this , flags ) class ( zndarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags print * , this % flatarray ( 1 : 2 ) end subroutine zndarray_eprint subroutine write_to_disk ( this , filename ) class ( zndarray ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename complex ( pfdp ), pointer :: z_array (:,:) open ( unit = 1 , file = trim ( filename ), form = 'unformatted' ) write ( 1 ) this % flatarray !z_array=>get_array2d(this) !write(1) z_array close ( 1 ) end subroutine write_to_disk !>  Helper function to return the array part function get_array1d ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:) select type ( x ) type is ( zndarray ) r => x % flatarray end select end function get_array1d function get_array2d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( zndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % flatarray end select end function get_array2d function get_array3d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( zndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % flatarray end select end function get_array3d end module pf_mod_zndarray","tags":"","loc":"sourcefile/pf_zndarray_encap.f90.html","title":"pf_zndarray_encap.f90 – LibPFASST"},{"text":"Data types and interfaces Contents Modules pf_mod_dtype Source Code pf_dtype.f90 Source Code !!  Data types and interfaces ! ! This file is part of LIBPFASST. ! !>  Module to define the main parameters, data types, and interfaces in pfasst module pf_mod_dtype use iso_c_binding implicit none !>  pfasst static  paramters integer , parameter :: pfdp = selected_real_kind ( 15 , 307 ) !!  Defines double precision type for all real and complex variables !  integer, parameter :: pfdp = selected_real_kind(33, 4931)  !! For quad precision everywhere (use at your risk and see top of pf_mpi.f90) integer , parameter :: pfqp = selected_real_kind ( 33 , 4931 ) !!  Defines quad precision type for all real and complex variables real ( pfdp ), parameter :: ZERO = 0.0_pfdp real ( pfdp ), parameter :: ONE = 1.0_pfdp real ( pfdp ), parameter :: TWO = 2.0_pfdp real ( pfdp ), parameter :: THREE = 3.0_pfdp real ( pfdp ), parameter :: HALF = 0.5_pfdp complex ( pfdp ), parameter :: ZI = cmplx ( 0.0 , 1.0 , pfdp ) complex ( pfdp ), parameter :: Z0 = cmplx ( 0.0 , 0.0 , pfdp ) real ( pfdp ), parameter :: two_pi = 6.2831853071795862_pfdp integer , parameter :: PF_MAXLEVS = 4 integer , parameter :: PF_MAX_HOOKS = 32 !> Quadrature node varieties integer , parameter :: SDC_GAUSS_LOBATTO = 1 integer , parameter :: SDC_GAUSS_RADAU = 2 integer , parameter :: SDC_CLENSHAW_CURTIS = 3 integer , parameter :: SDC_UNIFORM = 4 integer , parameter :: SDC_GAUSS_LEGENDRE = 5 integer , parameter :: SDC_CHEBYSHEV = 6 !> States of operation integer , parameter :: PF_STATUS_ITERATING = 1 integer , parameter :: PF_STATUS_CONVERGED = 2 integer , parameter :: PF_STATUS_PREDICTOR = 3 !>  The type that holds the state of the system type , bind ( c ) :: pf_state_t real ( pfdp ) :: t0 !!  Time at beginning of this time step real ( pfdp ) :: dt !!  Time step size integer :: nsteps !! total number of time steps integer :: pfblock !! pfasst block being worked on integer :: iter !! current iteration number integer :: step !! current time step number assigned to processor integer :: level !! which level is currently being operated on integer :: finest_level !! the current finest level (for variable depth V cycles) integer :: hook !! which hook integer :: proc !! which processor integer :: sweep !! sweep number integer :: status !! status (iterating, converged etc) integer :: pstatus !! previous rank's status integer :: itcnt !! total iterations by this processor integer :: skippedy !! skipped sweeps for state (for mixed integration) integer :: mysteps !! steps I did end type pf_state_t !>  Abstract hook type: hooks call diagnostic routines from various places in code type :: pf_hook_t procedure ( pf_hook_p ), pointer , nopass :: proc end type pf_hook_t !>  The abstract SDC sweeper type (must be extended) type , abstract :: pf_sweeper_t integer :: npieces logical :: use_LUq contains procedure ( pf_sweep_p ), deferred :: sweep procedure ( pf_initialize_p ), deferred :: initialize procedure ( pf_evaluate_p ), deferred :: evaluate procedure ( pf_integrate_p ), deferred :: integrate procedure ( pf_evaluate_all_p ), deferred :: evaluate_all procedure ( pf_residual_p ), deferred :: residual procedure ( pf_spreadq0_p ), deferred :: spreadq0 procedure ( pf_destroy_sweeper_p ), deferred :: destroy end type pf_sweeper_t !>  The abstract time stepper type (must be extended) type , abstract :: pf_stepper_t integer :: npieces !  Number of pieces of rhs integer :: order !  Method order integer :: nsteps !  Number of steps per big time step contains procedure ( pf_do_n_steps_p ), deferred :: do_n_steps procedure ( pf_initialize_stepper_p ), deferred :: initialize procedure ( pf_destroy_stepper_p ), deferred :: destroy end type pf_stepper_t !>  The abstract data type of the solution (must be extended) type , abstract :: pf_encap_t contains procedure ( pf_encap_setval_p ), deferred :: setval procedure ( pf_encap_copy_p ), deferred :: copy procedure ( pf_encap_norm_p ), deferred :: norm procedure ( pf_encap_pack_p ), deferred :: pack procedure ( pf_encap_unpack_p ), deferred :: unpack procedure ( pf_encap_axpy_p ), deferred :: axpy procedure ( pf_encap_eprint_p ), deferred :: eprint end type pf_encap_t !>  Abstract type for creation and destruction of objects type , abstract :: pf_factory_t contains procedure ( pf_encap_create_single_p ), deferred :: create_single procedure ( pf_encap_create_array_p ), deferred :: create_array procedure ( pf_encap_destroy_single_p ), deferred :: destroy_single procedure ( pf_encap_destroy_array_p ), deferred :: destroy_array end type pf_factory_t !>  The absract definition of level which is inherited  to include problem dependent stuff type , abstract :: pf_user_level_t class ( pf_factory_t ), allocatable :: factory class ( pf_sweeper_t ), allocatable :: sweeper class ( pf_stepper_t ), allocatable :: stepper contains procedure ( pf_transfer_p ), deferred :: restrict procedure ( pf_transfer_p ), deferred :: interpolate end type pf_user_level_t !>  The type to store quadrature matrices type :: pf_sdcmats_t integer :: nnodes !  Number of nodes integer :: qtype !  Type of nodes real ( pfdp ), allocatable :: qnodes (:) !  The quadrature nodes real ( pfdp ), allocatable :: Qmat (:,:) !  Collocation matrix real ( pfdp ), allocatable :: QmatFE (:,:) !  Forward Euler matrix real ( pfdp ), allocatable :: QmatBE (:,:) !  Backward Euler matrix real ( pfdp ), allocatable :: QmatTrap (:,:) ! Trapezoid rule matrix real ( pfdp ), allocatable :: QmatVer (:,:) ! Verlet Matrix real ( pfdp ), allocatable :: QmatLU (:,:) !  LU of Wmat real ( pfdp ), allocatable :: Smat (:,:) !  The node to node version of Qmat logical :: use_proper_nodes = . false . !  If true use gauss nodes in coarsening logical :: use_composite_nodes = . false . ! If true, finer nodes are composite logical :: use_no_left_q = . false . ! If true don't use left endpoint in rule end type pf_sdcmats_t !>  Data type of a PFASST level type :: pf_level_t !  ===Mandatory level parameters=== integer :: mpibuflen = - 1 !! size of solution in pfdp units !  level parameters set by the pfasst_t values integer :: index = - 1 !! level number (1 is the coarsest) integer :: nnodes = - 1 !! number of sdc nodes integer :: nsteps_rk = - 1 !! number of rk steps to perform integer :: nsweeps = - 1 !! number of sdc sweeps to perform integer :: nsweeps_pred = - 1 !! number of coarse sdc sweeps to perform predictor in predictor logical :: Finterp = . false . !! interpolate functions instead of solutions !  Diagnostics real ( pfdp ) :: error !! holds the user defined error real ( pfdp ) :: residual !! holds the user defined residual real ( pfdp ) :: residual_rel !! holds the user defined relative residual (scaled by solution magnitude) class ( pf_user_level_t ), allocatable :: ulevel !!  user customized level info !>  Simple data storage at each level real ( pfdp ), allocatable :: & send (:), & !! send buffer recv (:), & !! recv buffer nodes (:), & !! list of SDC nodes rmat (:,:), & !! time restriction matrix tmat (:,:) !! time interpolation matrix integer , allocatable :: & nflags (:) !! sdc node flags !>  Solution variable storage class ( pf_encap_t ), allocatable :: & Q (:), & !! solution at sdc nodes pQ (:), & !! unknowns at sdc nodes, previous sweep R (:), & !! full residuals I (:), & !! 0 to node integrals Fflt (:), & !! functions values at sdc nodes (flat) Frkflt (:), & !!  Stage Function values tauQ (:), & !! fas correction in Q form pFflt (:), & !! functions at sdc nodes, previous sweep (flat) q0 , & !! initial condition q0_delta , & !! Space for interpolating q0, qend qend !! solution at end time !>  Function  storage class ( pf_encap_t ), pointer :: & F (:,:), & !! functions values at sdc nodes pF (:,:) !! functions at sdc nodes, previous sweep !>  Interpolation and restriction data structures logical :: interp_workspace_allocated = . false . class ( pf_encap_t ), allocatable :: & cf_delta (:), & ! delta fine in space and coarse in time c_delta (:) ! delta on the coarse level integer , allocatable :: shape (:) !! user defined shape array type ( pf_sdcmats_t ), allocatable :: sdcmats logical :: allocated = . false . end type pf_level_t !>  Data type to define the communicator type :: pf_comm_t integer :: nproc = - 1 ! total number of processors integer :: comm = - 1 ! communicator integer , pointer :: & recvreq (:), & ! receive requests (indexed by level) sendreq (:) ! send requests (indexed by level) integer :: statreq ! status send request ! fakie, needs modernization !type(c_ptr), pointer :: pfs(:)     ! pfasst objects (indexed by rank) !type(c_ptr), pointer :: pfpth(:,:) !> Procedure interfaces procedure ( pf_post_p ), pointer , nopass :: post procedure ( pf_recv_p ), pointer , nopass :: recv procedure ( pf_recv_status_p ), pointer , nopass :: recv_status procedure ( pf_send_p ), pointer , nopass :: send procedure ( pf_send_status_p ), pointer , nopass :: send_status procedure ( pf_wait_p ), pointer , nopass :: wait procedure ( pf_broadcast_p ), pointer , nopass :: broadcast end type pf_comm_t !>  Type for storing results for later output type :: pf_results_t real ( pfdp ), allocatable :: errors (:,:,:) real ( pfdp ), allocatable :: residuals (:,:,:) !  (block,iter,sweep) integer :: nsteps integer :: niters integer :: nprocs integer :: p_index integer :: nblocks integer :: nsweeps integer :: rank integer :: level character ( len = 128 ) :: datpath procedure ( pf_results_p ), pointer , nopass :: destroy end type pf_results_t !>  The main PFASST data type which includes pretty much everythingl type :: pf_pfasst_t !> === Mandatory pfasst parameters (must be set on command line or input file)  === integer :: nlevels = - 1 !! number of pfasst levels !>  ===  Optional pfasst parameters ==== integer :: niters = 5 !! number of PFASST iterations to do integer :: qtype = SDC_GAUSS_LOBATTO !! type of nodes logical :: use_proper_nodes = . false . logical :: use_composite_nodes = . false . logical :: use_no_left_q = . false . ! --  level dependent parameters integer :: nsweeps ( PF_MAXLEVS ) = 1 !!  number of sweeps at each levels integer :: nsweeps_pred ( PF_MAXLEVS ) = 1 !!  number of sweeps during predictor integer :: nnodes ( PF_MAXLEVS ) = 3 !! number of nodes ! --  tolerances real ( pfdp ) :: abs_res_tol = 0.d0 !!  absolute convergence tolerance real ( pfdp ) :: rel_res_tol = 0.d0 !!  relative convergence tolerance ! --  predictor options  (should be set before pfasst_run is called) logical :: PFASST_pred = . true . !!  true if the PFASST type predictor is used logical :: pipeline_pred = . false . !!  true if coarse sweeps after burn in are pipelined  (if nsweeps_pred>1 on coarse level) integer :: nsweeps_burn = 1 !!  number of sdc sweeps to perform during coarse level burn in integer :: q0_style = 0 !!  q0 can take 3 values !!  0:  Only the q0 at t=0 is valid  (default) !!  1:  The q0 at each processor is valid !!  2:  q0 and all nodes at each processor is valid ! --  run options  (should be set before pfasst_run is called) logical :: Vcycle = . true . !!  decides if Vcycles are done logical :: Finterp = . false . !!  True if transfer functions operate on rhs logical :: use_LUq = . true . !!  True if LU type implicit matrix is used logical :: use_Sform = . false . !!  True if Qmat type of stepping is used integer :: taui0 = - 999999 !! iteration cutoff for tau inclusion ! -- RK and Parareal options logical :: use_rk_stepper = . false . !! decides if RK steps are used instead of the sweeps integer :: nsteps_rk ( PF_MAXLEVS ) = 3 !! number of runge-kutta steps per time step logical :: RK_pred = . false . !!  true if the coarse level is initialized with Runge-Kutta instead of PFASST ! -- misc logical :: debug = . false . !!  If true, debug diagnostics are printed ! -- controller for the results logical :: save_residuals = . false . !!  If true, residuals are saved and output logical :: save_timings = . false . !!  If true, timings are saved and  output logical :: echo_timings = . false . !!  If true, timings are  output to screen logical :: save_errors = . false . !!  If true, errors  are saved and output integer :: rank = - 1 !! rank of current processor !> pf objects type ( pf_state_t ), allocatable :: state !!  Describes where in the algorithm proc is type ( pf_level_t ), allocatable :: levels (:) !! Holds the levels type ( pf_comm_t ), pointer :: comm !! Points to communicator type ( pf_results_t ), allocatable :: results (:) !!  Hold results for each level !> hooks variables type ( pf_hook_t ), allocatable :: hooks (:,:,:) !!  Holds the hooks integer , allocatable :: nhooks (:,:) !!  Holds the number hooks !> timing variables double precision :: timers ( 100 ) = 0.0d0 double precision :: runtimes ( 100 ) = 0.0d0 !> output directory character ( len = 256 ) :: outdir end type pf_pfasst_t !> Interfaces for subroutines interface !> hooks subroutines subroutine pf_hook_p ( pf , level_index ) use iso_c_binding import pf_pfasst_t type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index end subroutine pf_hook_p !> SDC sweeper subroutines subroutine pf_sweep_p ( this , pf , level_index , t0 , dt , nsweeps , flags ) import pf_sweeper_t , pf_pfasst_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsweeps integer , optional , intent ( in ) :: flags end subroutine pf_sweep_p subroutine pf_evaluate_p ( this , pf , level_index , t , m , flags , step ) import pf_sweeper_t , pf_pfasst_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , optional , intent ( in ) :: flags , step end subroutine pf_evaluate_p subroutine pf_evaluate_all_p ( this , pf , level_index , t , flags , step ) import pf_sweeper_t , pf_pfasst_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step end subroutine pf_evaluate_all_p subroutine pf_initialize_p ( this , pf , level_index ) import pf_sweeper_t , pf_pfasst_t class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index end subroutine pf_initialize_p subroutine pf_destroy_sweeper_p ( this , pf , level_index ) import pf_sweeper_t , pf_pfasst_t class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index end subroutine pf_destroy_sweeper_p subroutine pf_integrate_p ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) import pf_sweeper_t , pf_pfasst_t , pf_encap_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt !!  Time step size class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags end subroutine pf_integrate_p subroutine pf_residual_p ( this , pf , level_index , dt , flags ) import pf_sweeper_t , pf_pfasst_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt !!  Time step size integer , optional , intent ( in ) :: flags end subroutine pf_residual_p subroutine pf_spreadq0_p ( this , pf , level_index , t0 , flags , step ) import pf_sweeper_t , pf_pfasst_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of step; if flags == 2, time at end of step integer , optional , intent ( in ) :: flags , step end subroutine pf_spreadq0_p subroutine pf_destroy_p ( this , pf , level_index ) import pf_sweeper_t , pf_pfasst_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index end subroutine pf_destroy_p !>  time stepper interfaces subroutine pf_do_n_steps_p ( this , pf , level_index , t0 , q0 , qend , big_dt , nsteps_rk ) import pf_pfasst_t , pf_stepper_t , pf_level_t , pfdp , pf_encap_t class ( pf_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: big_dt !!  Time step size real ( pfdp ), intent ( in ) :: t0 class ( pf_encap_t ), intent ( in ) :: q0 !!  Starting value class ( pf_encap_t ), intent ( inout ) :: qend !!  Final value integer , intent ( in ) :: level_index integer , intent ( in ) :: nsteps_rk end subroutine pf_do_n_steps_p subroutine pf_initialize_stepper_p ( this , pf , level_index ) import pf_stepper_t , pf_pfasst_t class ( pf_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index end subroutine pf_initialize_stepper_p subroutine pf_destroy_stepper_p ( this , pf , level_index ) import pf_stepper_t , pf_pfasst_t class ( pf_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index end subroutine pf_destroy_stepper_p !> transfer interfaces used for restriction and interpolation subroutine pf_transfer_p ( this , f_lev , c_lev , f_vec , c_vec , t , flags ) import pf_user_level_t , pf_level_t , pf_encap_t , pfdp class ( pf_user_level_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: f_lev , c_lev !  fine and coarse levels class ( pf_encap_t ), intent ( inout ) :: f_vec , c_vec !  fine and coarse vectors real ( pfdp ), intent ( in ) :: t integer , optional , intent ( in ) :: flags end subroutine pf_transfer_p !> encapsulation interfaces subroutine pf_encap_create_single_p ( this , x , level , shape ) import pf_factory_t , pf_encap_t class ( pf_factory_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) end subroutine pf_encap_create_single_p subroutine pf_encap_create_array_p ( this , x , n , level , shape ) import pf_factory_t , pf_encap_t class ( pf_factory_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) end subroutine pf_encap_create_array_p subroutine pf_encap_destroy_single_p ( this , x ) import pf_factory_t , pf_encap_t class ( pf_factory_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x end subroutine pf_encap_destroy_single_p subroutine pf_encap_destroy_array_p ( this , x ) import pf_factory_t , pf_encap_t class ( pf_factory_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) end subroutine pf_encap_destroy_array_p subroutine pf_encap_setval_p ( this , val , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags end subroutine pf_encap_setval_p subroutine pf_encap_copy_p ( this , src , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags end subroutine pf_encap_copy_p function pf_encap_norm_p ( this , flags ) result ( norm ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm end function pf_encap_norm_p subroutine pf_encap_pack_p ( this , z , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , optional , intent ( in ) :: flags end subroutine pf_encap_pack_p subroutine pf_encap_unpack_p ( this , z , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , optional , intent ( in ) :: flags end subroutine pf_encap_unpack_p subroutine pf_encap_axpy_p ( this , a , x , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags end subroutine pf_encap_axpy_p subroutine pf_encap_eprint_p ( this , flags ) import pf_encap_t class ( pf_encap_t ), intent ( inout ) :: this integer , intent ( in ), optional :: flags end subroutine pf_encap_eprint_p !> communicator interfaces subroutine pf_post_p ( pf , level , tag , ierror , source ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag integer , intent ( inout ) :: ierror integer , intent ( in ) :: source end subroutine pf_post_p subroutine pf_recv_p ( pf , level , tag , blocking , ierror , source ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , intent ( inout ) :: ierror integer , intent ( in ) :: source end subroutine pf_recv_p subroutine pf_recv_status_p ( pf , tag , istatus , ierror , source ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , intent ( inout ) :: istatus integer , intent ( inout ) :: ierror integer , intent ( in ) :: source end subroutine pf_recv_status_p subroutine pf_send_p ( pf , level , tag , blocking , ierror , dest ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , intent ( inout ) :: ierror integer , intent ( in ) :: dest end subroutine pf_send_p subroutine pf_send_status_p ( pf , tag , istatus , ierror , dest ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , intent ( in ) :: istatus integer , intent ( inout ) :: ierror integer , intent ( in ) :: dest end subroutine pf_send_status_p subroutine pf_wait_p ( pf , level , ierror ) import pf_pfasst_t type ( pf_pfasst_t ), intent ( in ) :: pf integer , intent ( in ) :: level integer , intent ( inout ) :: ierror end subroutine pf_wait_p subroutine pf_broadcast_p ( pf , y , nvar , root , ierror ) import pf_pfasst_t , pfdp type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: nvar , root real ( pfdp ) , intent ( in ) :: y ( nvar ) integer , intent ( inout ) :: ierror end subroutine pf_broadcast_p subroutine pf_results_p ( this ) import pf_results_t type ( pf_results_t ), intent ( inout ) :: this end subroutine pf_results_p end interface end module pf_mod_dtype","tags":"","loc":"sourcefile/pf_dtype.f90.html","title":"pf_dtype.f90 – LibPFASST"},{"text":"N-dimensional complex system of arrays encapsulation Contents Modules pf_mod_zndsysarray Source Code pf_zndsysarray_encap.f90 Source Code !!  N-dimensional complex system of arrays encapsulation ! ! This file is part of LIBPFASST. ! !> System of complex N-dimensional arrays encapsulation. !! !! When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'arr_shape' attribute to create a new multi-component array with that !! shape.  Thus, the 'arr_shape' attributes of the PFASST levels should be !! set appropriately.  The last component of arr_shape is the number of components in the system !! !! For example, before calling pf_pfasst_run we can !! set the arr_shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%arr_shape(3)) !!   pf%levels(1)%arr_shape = [ nx, ny, 3 ] !! !! Which would imply that a 3 component system of two-dimensional solutions. !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to a component of  encapsulated system !! performing any copies. !! module pf_mod_zndsysarray use iso_c_binding use pf_mod_dtype implicit none !>  Type to create and destroy the arrays type , extends ( pf_factory_t ) :: zndsysarray_factory contains procedure :: create_single => zndsysarray_create_single procedure :: create_array => zndsysarray_create_array procedure :: destroy_single => zndsysarray_destroy_single procedure :: destroy_array => zndsysarray_destroy_array end type zndsysarray_factory !>  Type to extend the abstract encap and set procedure pointers type , extends ( pf_encap_t ) :: zndsysarray integer :: dim !  The spatial dimension of each component in system integer :: ncomp !  The number of components in the system integer :: ndof !  The number of variables in each component integer , allocatable :: arr_shape (:) complex ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => zndsysarray_setval procedure :: copy => zndsysarray_copy procedure :: norm => zndsysarray_norm procedure :: pack => zndsysarray_pack procedure :: unpack => zndsysarray_unpack procedure :: axpy => zndsysarray_axpy procedure :: eprint => zndsysarray_eprint end type zndsysarray !> Interfaces to output routines in pf_numpy.c interface !>  Subroutine to write an the array to a file subroutine zndsysarray_dump_numpy ( dname , fname , endian , dim , mpibuflen , arr_shape , array ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname , fname , endian ( 5 ) integer , intent ( in ), value :: dim , mpibuflen integer , intent ( in ) :: arr_shape ( dim ) real ( c_double ), intent ( in ) :: array ( mpibuflen ) end subroutine zndsysarray_dump_numpy end interface contains !>  Subroutine to allocate the array and set the size parameters subroutine zndsysarray_build ( q , arr_shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: arr_shape (:) select type ( q ) class is ( zndsysarray ) allocate ( q % arr_shape ( size ( arr_shape ))) q % dim = size ( arr_shape ) - 1 q % ncomp = arr_shape ( q % dim + 1 ) q % ndof = product ( arr_shape ( 1 : q % dim )) q % arr_shape = arr_shape allocate ( q % flatarray ( product ( arr_shape ))) end select end subroutine zndsysarray_build !> Subroutine to  create a single array subroutine zndsysarray_create_single ( this , x , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) integer :: i allocate ( zndsysarray :: x ) call zndsysarray_build ( x , shape ) end subroutine zndsysarray_create_single !> Subroutine to create an array of arrays subroutine zndsysarray_create_array ( this , x , n , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( zndsysarray :: x ( n )) do i = 1 , n call zndsysarray_build ( x ( i ), shape ) end do end subroutine zndsysarray_create_array !>  Subroutine to destroy array subroutine zndsysarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( zndsysarray ), pointer :: zndsysarray_obj zndsysarray_obj => cast_as_zndsysarray ( encap ) deallocate ( zndsysarray_obj % arr_shape ) deallocate ( zndsysarray_obj % flatarray ) nullify ( zndsysarray_obj ) end subroutine zndsysarray_destroy !> Subroutine to destroy an single array subroutine zndsysarray_destroy_single ( this , x ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( zndsysarray ) deallocate ( x % arr_shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine zndsysarray_destroy_single !> Subroutine to destroy an array of arrays subroutine zndsysarray_destroy_array ( this , x ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( zndsysarray ) do i = 1 , size ( x ) deallocate ( x ( i )% arr_shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine zndsysarray_destroy_array !>  The following are the base subroutines that all encapsulations must provide !! !> Subroutine to set array to a scalare  value. subroutine zndsysarray_setval ( this , val , flags ) class ( zndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine zndsysarray_setval !> Subroutine to copy an array subroutine zndsysarray_copy ( this , src , flags ) class ( zndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( zndsysarray ) this % flatarray = src % flatarray class default stop \"TYPE ERROR\" end select end subroutine zndsysarray_copy !> Subroutine to pack an array into a flat array for sending subroutine zndsysarray_pack ( this , z , flags ) class ( zndsysarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: ntot ntot = this % ndof * this % ncomp z ( 1 : ntot ) = real ( this % flatarray , pfdp ) z ( ntot + 1 : 2 * ntot ) = aimag ( this % flatarray ) end subroutine zndsysarray_pack !> Subroutine to unpack a flatarray after receiving subroutine zndsysarray_unpack ( this , z , flags ) class ( zndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: ntot ntot = this % ndof * this % ncomp this % flatarray = z ( 1 : ntot ) this % flatarray = this % flatarray + cmplx ( 0.0 , 1.0 , pfdp ) * z ( ntot + 1 : 2 * ntot ) this % flatarray = cmplx ( z ( 1 : ntot ), z ( ntot + 1 : 2 * ntot )) end subroutine zndsysarray_unpack !> Subroutine to define the norm of the array (here the max norm) function zndsysarray_norm ( this , flags ) result ( norm ) class ( zndsysarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function zndsysarray_norm !> Subroutine to compute y = a x + y where a is a scalar and x and y are arrays subroutine zndsysarray_axpy ( this , a , x , flags ) class ( zndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( zndsysarray ) this % flatarray = a * x % flatarray + this % flatarray class default stop \"TYPE ERROR\" end select end subroutine zndsysarray_axpy !>  Subroutine to print the array to the screen (mainly for debugging purposes) subroutine zndsysarray_eprint ( this , flags ) class ( zndsysarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % flatarray ( 1 : 10 ) !print *, this%flatarray end subroutine zndsysarray_eprint function cast_as_zndsysarray ( encap_polymorph ) result ( zndsysarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( zndsysarray ), pointer :: zndsysarray_obj select type ( encap_polymorph ) type is ( zndsysarray ) zndsysarray_obj => encap_polymorph end select end function cast_as_zndsysarray !>  Helper function to return the array part function get_array1d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:) select type ( x ) type is ( zndsysarray ) r => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array1d function get_array2d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( zndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array2d function get_array3d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( zndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 ), 1 : x % arr_shape ( 3 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array3d end module pf_mod_zndsysarray","tags":"","loc":"sourcefile/pf_zndsysarray_encap.f90.html","title":"pf_zndsysarray_encap.f90 – LibPFASST"},{"text":"Useful subroutines to return exact solutions for various problems Contents Modules pf_mod_solutions Source Code pf_solutions.f90 Source Code !! Useful subroutines to return exact solutions for various problems ! ! This file is part of LIBPFASST. ! !> Module with useful subroutines that don't  fit in other modules module pf_mod_solutions use pf_mod_dtype implicit none !  Advection diffusion example !  procedure, private  :: exact_ad_1d, exact_ad_2d, exact_ad_3d,zexact_ad_1d, zexact_ad_2d, zexact_ad_3d !  generic :: exact_ad => exact_ad_1d, exact_ad_2d, exact_ad_3d,zexact_ad_1d, zexact_ad_2d, zexact_ad_3d interface exact_ad_cos module procedure exact_ad_cos_1d module procedure exact_ad_cos_1dz module procedure exact_ad_cos_2d module procedure exact_ad_cos_2dz module procedure exact_ad_cos_3d module procedure exact_ad_cos_3dz end interface exact_ad_cos interface exact_ad_exp module procedure exact_ad_exp_1d module procedure exact_ad_exp_1dz module procedure exact_ad_exp_2d module procedure exact_ad_exp_2dz module procedure exact_ad_exp_3d module procedure exact_ad_exp_3dz end interface exact_ad_exp interface exact_burg_sin module procedure exact_burg_sin_1d module procedure exact_burg_sin_1dz module procedure exact_burg_sin_2d module procedure exact_burg_sin_2dz module procedure exact_burg_sin_3d module procedure exact_burg_sin_3dz end interface exact_burg_sin interface exact_nls module procedure exact_nls_1dz module procedure exact_nls_2dz module procedure exact_nls_3dz end interface exact_nls interface exact_kdv module procedure exact_kdv_1d module procedure exact_kdv_1dz !!$     module procedure exact_kdv_2d !!$     module procedure exact_kdv_3d !!$     module procedure exact_kdv_2dz !!$     module procedure exact_kdv_3dz end interface exact_kdv contains !> Routine to return the exact solution for advection diffusion !> Routine to return the exact solution for advection diffusion function ad_cos_ex ( t , x , nu , v , kfreq , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: v real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: kfreq real ( pfdp ), intent ( in ) :: Lx real ( pfdp ) :: u real ( pfdp ) :: omega omega = kfreq * two_pi / Lx u = cos ( omega * ( x - t * v )) * exp ( - omega * omega * nu * t ) end function ad_cos_ex subroutine exact_ad_cos_1d ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu , v , kfreq , Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = ad_cos_ex ( t , x , nu , v , kfreq , Lx ) end do end subroutine exact_ad_cos_1d subroutine exact_ad_cos_1dz ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu , v , kfreq , Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = ad_cos_ex ( t , x , nu , v , kfreq , Lx ) end do end subroutine exact_ad_cos_1dz subroutine exact_ad_cos_2d ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy nx = size ( uex , 1 ) ny = size ( uex , 2 ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_cos_ex ( t , y , nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = ad_cos_ex ( t , x , nu , v ( 1 ), kfreq ( 1 ), Lx ( 1 )) * uy end do end do end subroutine exact_ad_cos_2d subroutine exact_ad_cos_2dz ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy nx = size ( uex , 1 ) ny = size ( uex , 2 ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_cos_ex ( t , y , nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = ad_cos_ex ( t , x , nu , v ( 1 ), kfreq ( 1 ), Lx ( 1 )) * uy end do end do end subroutine exact_ad_cos_2dz subroutine exact_ad_cos_3d ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu , v ( 3 ), kfreq ( 3 ), Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , uy , uz nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) uz = ad_cos_ex ( t , z , nu , v ( 3 ), kfreq ( 3 ), Lx ( 3 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_cos_ex ( t , y , nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = ad_cos_ex ( t , x , nu , v ( 1 ), kfreq ( 1 ), Lx ( 1 )) * uy * uz end do end do end do end subroutine exact_ad_cos_3d subroutine exact_ad_cos_3dz ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu , v ( 3 ), kfreq ( 3 ), Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , uy , uz nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) uz = ad_cos_ex ( t , z , nu , v ( 3 ), kfreq ( 3 ), Lx ( 3 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_cos_ex ( t , y , nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = ad_cos_ex ( t , x , nu , v ( 1 ), kfreq ( 1 ), Lx ( 1 )) * uy * uz end do end do end do end subroutine exact_ad_cos_3dz function ad_exp_ex ( t , x , nu , v , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: v real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx real ( pfdp ) :: u integer :: nx , i , ii , k , nbox real ( pfdp ) :: xx , c , t0 u = 0.0_pfdp if ( nu . gt . 0.0 ) then t0 = 0.0025_pfdp / nu nbox = ceiling ( sqrt ( 4.0_pfdp * nu * ( t0 + t ) * 3 7.0_pfdp )) !  Decide how many periodic images do k = - nbox , nbox xx = x - 0.5_pfdp * Lx - t * v + real ( k , pfdp ) * Lx u = u + sqrt ( t0 ) / sqrt ( t0 + t ) * exp ( - xx * xx / ( 4.0_pfdp * nu * ( t0 + t ))) end do else nbox = ceiling ( sqrt ( 3 7.0d0 )) !  Decide how many periodic images do k = - nbox , nbox xx = x - 0.5_pfdp * Lx - t * v + real ( k , pfdp ) * Lx u = u + exp ( - xx * xx / ( 4.0_pfdp * 0.0025_pfdp )) end do end if end function ad_exp_ex subroutine exact_ad_exp_1d ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu , v , Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = ad_exp_ex ( t , x , nu , v , Lx ) end do end subroutine exact_ad_exp_1d subroutine exact_ad_exp_1dz ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu , v , Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = ad_exp_ex ( t , x , nu , v , Lx ) end do end subroutine exact_ad_exp_1dz subroutine exact_ad_exp_2d ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu , v ( 2 ), Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy nx = size ( uex , 1 ) ny = size ( uex , 2 ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_exp_ex ( t , y , nu , v ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = ad_exp_ex ( t , x , nu , v ( 1 ), Lx ( 1 )) * uy end do end do end subroutine exact_ad_exp_2d subroutine exact_ad_exp_2dz ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu , v ( 2 ), Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy nx = size ( uex , 1 ) ny = size ( uex , 2 ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_exp_ex ( t , y , nu , v ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = ad_exp_ex ( t , x , nu , v ( 1 ), Lx ( 1 )) * uy end do end do end subroutine exact_ad_exp_2dz subroutine exact_ad_exp_3d ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu , v ( 3 ), Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , uy , uz nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) uz = ad_exp_ex ( t , z , nu , v ( 3 ), Lx ( 3 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_exp_ex ( t , y , nu , v ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = ad_exp_ex ( t , x , nu , v ( 1 ), Lx ( 1 )) * uy * uz end do end do end do end subroutine exact_ad_exp_3d subroutine exact_ad_exp_3dz ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu , v ( 3 ), Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , uy , uz nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) uz = ad_exp_ex ( t , z , nu , v ( 3 ), Lx ( 3 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_exp_ex ( t , y , nu , v ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = ad_exp_ex ( t , x , nu , v ( 1 ), Lx ( 1 )) * uy * uz end do end do end do end subroutine exact_ad_exp_3dz !> Routine to return the exact solution for inviscid Burgers based on Platzman !>See \"A Simple Illustration of a Weak Spectral Cascade\", Muraki D,SIAM J Appl Math,2007 function burg_sin_ex ( t , x , nu , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx real ( pfdp ) :: u real ( pfdp ) :: rn , ts , xs , a , b , c , phi , dphi , o1 , o2 integer :: n , nterms nterms = 100 u = 0.0_pfdp xs = x * two_pi / Lx ts = t * two_pi / Lx if ( t . gt . 0.0_pfdp ) then do n = nterms , 1 , - 1 rn = real ( n , pfdp ) u = u - 2.0_pfdp * bessel_jn ( n , rn * ts ) / ( rn * ts ) * sin ( rn * xs ) end do else u =- sin ( xs ) end if end function burg_sin_ex subroutine exact_burg_sin_1d ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = burg_sin_ex ( t , x , nu , Lx ) end do end subroutine exact_burg_sin_1d subroutine exact_burg_sin_1dz ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = burg_sin_ex ( t , x , nu , Lx ) end do end subroutine exact_burg_sin_1dz subroutine exact_burg_sin_2d ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) L = 0.5_pfdp * ( Lx ( 1 ) + Lx ( 2 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = burg_sin_ex ( 2.0_pfdp * t , x + y , nu , L ) end do end do end subroutine exact_burg_sin_2d subroutine exact_burg_sin_2dz ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) L = 0.5_pfdp * ( Lx ( 1 ) + Lx ( 2 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = burg_sin_ex ( 2.0_pfdp * t , x + y , nu , L ) end do end do end subroutine exact_burg_sin_2dz subroutine exact_burg_sin_3d ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) L = ( Lx ( 1 ) + Lx ( 2 ) + Lx ( 3 )) / 3.0_pfdp do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = burg_sin_ex ( 3.0_pfdp * t , x + y + z , nu , L ) end do end do end do end subroutine exact_burg_sin_3d subroutine exact_burg_sin_3dz ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) L = ( Lx ( 1 ) + Lx ( 2 ) + Lx ( 3 )) / 3.0_pfdp do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = burg_sin_ex ( 3.0_pfdp * t , x + y + z , nu , L ) end do end do end do end subroutine exact_burg_sin_3dz !> Routine to return the exact solution for the nonlinear Schoedinger Eq  u_t=i2}u|&#94;2u +i u_xx !>See Tuncay Aktosun et al 2007 Inverse Problems 23 217 !>  Note the domain size should be 2*pi function nls_ex ( t , x , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: Lx complex ( pfdp ) :: u real ( pfdp ) :: a , b , taa , c complex ( pfdp ) :: ae , dn a = 1.0_pfdp / sqrt ( 2.0_pfdp ) b = 1.0_pfdp taa = 1.0_pfdp ae = a * exp ( zi * t ) dn = cosh ( t ) + zi * sinh ( t ) c = 4.0_pfdp u = exp ( zi * c * ( x - c * t )) * ae * ( dn / ( cosh ( t ) - sqrt ( 2.0_pfdp ) / 2.0_pfdp * cos ( x - 2.0_pfdp * c * t )) - 1.0_pfdp ) end function nls_ex subroutine exact_nls_1dz ( t , uex , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = nls_ex ( t , x , Lx ) end do end subroutine exact_nls_1dz subroutine exact_nls_2dz ( t , uex , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) L = 0.5_pfdp * ( Lx ( 1 ) + Lx ( 2 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = nls_ex ( 2.0_pfdp * t , x + y , L ) end do end do end subroutine exact_nls_2dz subroutine exact_nls_3dz ( t , uex , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) L = ( Lx ( 1 ) + Lx ( 2 ) + Lx ( 3 )) / 3.0_pfdp do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = nls_ex ( 3.0_pfdp * t , x + y + z , L ) end do end do end do end subroutine exact_nls_3dz !  Soliton exact solution to kdv  moving at speed one (must scale equation properly) function kdv_ex ( t , x , beta , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: beta real ( pfdp ), intent ( in ) :: Lx real ( pfdp ) :: u real ( pfdp ) :: a , s a = beta * ( x - 0.375_pfdp * Lx - t ) s = 2.0_pfdp / ( exp ( a ) + exp ( - a )) u = s * s end function kdv_ex subroutine exact_kdv_1dz ( t , uex , beta , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: beta real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = kdv_ex ( t , x , beta , Lx ) end do end subroutine exact_kdv_1dz subroutine exact_kdv_1d ( t , uex , beta , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: beta real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = kdv_ex ( t , x , beta , Lx ) end do end subroutine exact_kdv_1d !!$  subroutine exact_kdv_2dz(t, uex,beta,Lx) !!$    real(pfdp), intent(in)  :: t !!$    complex(pfdp), intent(inout) :: uex(:,:) !!$    real(pfdp), intent(in) :: Lx(2) !!$ !!$    integer    :: nx,ny, i,j !!$    real(pfdp) :: x, y,L !!$ !!$    nx = size(uex,1) !!$    ny = size(uex,2) !!$    L=0.5_pfdp*(Lx(1)+Lx(2)) !!$    do j = 1, ny !!$       y = Lx(2)*real(j-1,pfdp)/real(ny,pfdp) !!$       do i = 1, nx !!$          x = Lx(1)*real(i-1,pfdp)/real(nx,pfdp) !!$          uex(i,j) = kdv_ex(2.0_pfdp*t,x+y,L) !!$       end do !!$    end do !!$ !!$  end subroutine exact_kdv_2dz !!$ !!$  subroutine exact_kdv_3dz(t, uex,Lx) !!$    real(pfdp), intent(in)  :: t !!$    complex(pfdp), intent(inout) :: uex(:,:,:) !!$    real(pfdp), intent(in) :: Lx(3) !!$ !!$    integer    :: nx,ny,nz, i,j,k !!$    real(pfdp) :: x, y,z,L !!$ !!$    nx = size(uex,1) !!$    ny = size(uex,2) !!$    nz = size(uex,3) !!$    L=(Lx(1)+Lx(2)+Lx(3))/3.0_pfdp !!$    do k = 1, nz !!$       z = Lx(3)*real(k-1,pfdp)/real(nz,pfdp) !!$       do j = 1, ny !!$          y = Lx(2)*real(j-1,pfdp)/real(ny,pfdp) !!$          do i = 1, nx !!$             x = Lx(1)*real(i-1,pfdp)/real(nx,pfdp) !!$             uex(i,j,k) = kdv_ex(3.0_pfdp*t,x+y+z,L) !!$          end do !!$       end do !!$    end do !!$ !!$  end subroutine exact_kdv_3dz !!$ end module pf_mod_solutions","tags":"","loc":"sourcefile/pf_solutions.f90.html","title":"pf_solutions.f90 – LibPFASST"},{"text":"N-dimensional system of array encapsulation. Contents Modules pf_mod_ndsysarray Source Code pf_ndsysarray_encap.f90 Source Code !!  N-dimensional system of array encapsulation. ! ! This file is part of LIBPFASST. ! !> System of N-dimensional arrays encapsulation. !! !! When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'arr_shape' attribute to create a new multi-component array with that !! shape.  Thus, the 'arr_shape' attributes of the PFASST levels should be !! set appropriately.  The last component of arr_shape is the number of components in the system !! !! For example, before calling pf_pfasst_run we can !! set the arr_shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%arr_shape(3)) !!   pf%levels(1)%arr_shape = [ nx, ny, 3 ] !! !! Which would imply that a 3 component system of two-dimensional solutions. !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to a component of  encapsulated system !! performing any copies. !! module pf_mod_ndsysarray use iso_c_binding use pf_mod_dtype implicit none !>  Type to create and destroy systems of N-dimensional arrays type , extends ( pf_factory_t ) :: ndsysarray_factory contains procedure :: create_single => ndsysarray_create_single procedure :: create_array => ndsysarray_create_array procedure :: destroy_single => ndsysarray_destroy_single procedure :: destroy_array => ndsysarray_destroy_array end type ndsysarray_factory !> Type for system of  N-dimensional arrays,  extends the abstract encap type type , extends ( pf_encap_t ) :: ndsysarray integer :: dim !  The spatial dimension of each component in system integer :: ncomp !  The number of components in the system integer :: ndof !  The number of variables in each component integer , allocatable :: arr_shape (:) real ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => ndsysarray_setval procedure :: copy => ndsysarray_copy procedure :: norm => ndsysarray_norm procedure :: pack => ndsysarray_pack procedure :: unpack => ndsysarray_unpack procedure :: axpy => ndsysarray_axpy procedure :: eprint => ndsysarray_eprint end type ndsysarray !> Interfaces to output routines in pf_numpy.c interface !>  Subroutine to write an the array to a file subroutine ndsysarray_dump_numpy ( dname , fname , endian , dim , mpibuflen , arr_shape , array ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname , fname , endian ( 5 ) integer , intent ( in ), value :: dim , mpibuflen integer , intent ( in ) :: arr_shape ( dim ) real ( c_double ), intent ( in ) :: array ( mpibuflen ) end subroutine ndsysarray_dump_numpy end interface contains !>  Subroutine to allocate the array and set the size parameters subroutine ndsysarray_build ( q , arr_shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: arr_shape (:) select type ( q ) class is ( ndsysarray ) allocate ( q % arr_shape ( size ( arr_shape ))) q % dim = size ( arr_shape ) - 1 q % ncomp = arr_shape ( q % dim + 1 ) q % ndof = product ( arr_shape ( 1 : q % dim )) q % arr_shape = arr_shape allocate ( q % flatarray ( product ( arr_shape ))) end select end subroutine ndsysarray_build !> Subroutine to  create a single array subroutine ndsysarray_create_single ( this , x , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( ndsysarray :: x ) call ndsysarray_build ( x , shape ) end subroutine ndsysarray_create_single !> Subroutine to create an array of arrays subroutine ndsysarray_create_array ( this , x , n , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndsysarray :: x ( n )) do i = 1 , n call ndsysarray_build ( x ( i ), shape ) end do end subroutine ndsysarray_create_array !!$ !>  Subroutine to destroy array (simple) subroutine ndsysarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndsysarray ), pointer :: ndsysarray_obj ndsysarray_obj => cast_as_ndsysarray ( encap ) deallocate ( ndsysarray_obj % arr_shape ) deallocate ( ndsysarray_obj % flatarray ) nullify ( ndsysarray_obj ) end subroutine ndsysarray_destroy !> Subroutine to destroy an single array subroutine ndsysarray_destroy_single ( this , x ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( ndsysarray ) deallocate ( x % arr_shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine ndsysarray_destroy_single !> Subroutine to destroy an array of arrays subroutine ndsysarray_destroy_array ( this , x ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( ndsysarray ) do i = 1 , size ( x ) deallocate ( x ( i )% arr_shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine ndsysarray_destroy_array !>  The following are the base subroutines that all encapsulations must provide !! !> Subroutine to set array to a scalare  value. subroutine ndsysarray_setval ( this , val , flags ) class ( ndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine ndsysarray_setval !> Subroutine to copy an array subroutine ndsysarray_copy ( this , src , flags ) class ( ndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( ndsysarray ) this % flatarray = src % flatarray class default stop \"TYPE ERROR\" end select end subroutine ndsysarray_copy !> Subroutine to pack an array into a flat array for sending subroutine ndsysarray_pack ( this , z , flags ) class ( ndsysarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags z = this % flatarray end subroutine ndsysarray_pack !> Subroutine to unpack a flatarray after receiving subroutine ndsysarray_unpack ( this , z , flags ) class ( ndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags this % flatarray = z end subroutine ndsysarray_unpack !> Subroutine to define the norm of the array (here the max norm) function ndsysarray_norm ( this , flags ) result ( norm ) class ( ndsysarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function ndsysarray_norm !> Subroutine to compute y = a x + y where a is a scalar and x and y are arrays subroutine ndsysarray_axpy ( this , a , x , flags ) class ( ndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( ndsysarray ) this % flatarray = a * x % flatarray + this % flatarray class default stop \"TYPE ERROR\" end select end subroutine ndsysarray_axpy !>  Subroutine to print the array to the screen (mainly for debugging purposes) subroutine ndsysarray_eprint ( this , flags ) class ( ndsysarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % flatarray ( 1 : 10 ) !print *, this%flatarray end subroutine ndsysarray_eprint function cast_as_ndsysarray ( encap_polymorph ) result ( ndsysarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndsysarray ), pointer :: ndsysarray_obj select type ( encap_polymorph ) type is ( ndsysarray ) ndsysarray_obj => encap_polymorph end select end function cast_as_ndsysarray !>  Helper function to return the array part function get_array1d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) select type ( x ) type is ( ndsysarray ) r => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array1d function get_array2d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( ndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array2d function get_array3d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( ndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 ), 1 : x % arr_shape ( 3 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array3d end module pf_mod_ndsysarray","tags":"","loc":"sourcefile/pf_ndsysarray_encap.f90.html","title":"pf_ndsysarray_encap.f90 – LibPFASST"},{"text":"IMEX sweeper for optimal control problems Contents Modules pf_mod_imexQ_oc Source Code pf_imexQ_oc_sweeper.f90 Source Code !!  IMEX sweeper for optimal control problems ! ! This file is part of LIBPFASST_OC. ! !>  Module to do imex SDC sweeps in the optimal control setting module pf_mod_imexQ_oc use pf_mod_dtype use pf_mod_utils implicit none !>  IMEX SDC sweeper type for optimal control, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_imexQ_oc_t real ( pfdp ), allocatable :: QtilE (:,:) !!  Approximate explcit quadrature rule real ( pfdp ), allocatable :: QtilI (:,:) !!  Approximate implcit quadrature rule real ( pfdp ), allocatable :: dtsdc (:) !!  SDC step sizes real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: QdiffI (:,:) !!  qmat-QtilI logical :: explicit = . true . !!  Is there an explicit piece logical :: implicit = . true . !!  Is there an implicit piece class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver !>  Set the generic functions procedure :: sweep => imexQ_oc_sweep procedure :: initialize => imexQ_oc_initialize procedure :: evaluate => imexQ_oc_evaluate procedure :: integrate => imexQ_oc_integrate procedure :: residual => imexQ_oc_residual procedure :: evaluate_all => imexQ_oc_evaluate_all procedure :: spreadq0 => imexQ_oc_spreadq0 procedure :: destroy => imexQ_oc_destroy procedure :: imexQ_oc_destroy procedure :: imexQ_oc_initialize end type pf_imexQ_oc_t interface !!  This is the interface for the routine to compute the RHS function values subroutine pf_f_eval_p ( this , y , t , level_index , f , piece , flags , idx , step ) !!  Evaluae f_piece(y), where piece is one or two import pf_imexQ_oc_t , pf_encap_t , pfdp class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value integer , intent ( in ) :: piece !!  Which piece to evaluate integer , intent ( in ) :: flags integer , intent ( in ), optional :: idx ! index of quadrature node integer , intent ( in ), optional :: step ! time step for sequential version end subroutine pf_f_eval_p subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece , flags ) !!  Solve the equation y - dtq*f_2(y) =rhs import pf_imexQ_oc_t , pf_encap_t , pfdp class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_2 of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate integer , intent ( in ) :: flags end subroutine pf_f_comp_p end interface contains ! Perform on SDC sweep on level Lev and set qend appropriately. subroutine imexQ_oc_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: level_index !!  which level this is integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: lev !  points to current level ! indicate if sweep on both (0, default; might skip y or p if tolerance satisfied), just y (1), just p (2) integer :: k , m , n , Nnodes , which real ( pfdp ) :: t , tend logical :: sweep_y , sweep_p real ( pfdp ), allocatable :: norms_y (:) !, norms_p(Lev%nnodes-1) integer :: step lev => pf % levels ( level_index ) !  Assign level pointer step = pf % state % step + 1 !     print *, 'sweep on step', step which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SWEEPER WITHOUT FLAGS\" !     print *, \"IMEXQ_OC SWEEP\", which Nnodes = lev % nnodes tend = t0 + dt call start_timer ( pf , TLEVEL + lev % index - 1 ) if ( which . eq . 1 ) then sweep_y = . true . sweep_p = . false . else if ( which . eq . 2 ) then sweep_y = . false . sweep_p = . true . else sweep_y = . true . sweep_p = . true . allocate ( norms_y ( lev % nnodes - 1 )) do m = 1 , Nnodes - 1 norms_y ( m ) = lev % R ( m )% norm ( 1 ) end do if ( maxval ( abs ( norms_y )) < pf % abs_res_tol ) then sweep_y = . false . if ( level_index == pf % state % finest_level ) pf % state % skippedy = pf % state % skippedy + 1 end if deallocate ( norms_y ) !if ( maxval(abs(norms_p)) < pf%abs_res_tol ) sweep_p = .false. end if !     if( sweep_p .and. pf%rank == 0)  print *, \"sweep on p with which = \", which do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals from previous iteration and add fas correction !     do m = 1, Nnodes-1 !        call Lev%encap%setval(Lev%S(m), 0.0_pfdp, 1) !        call Lev%encap%setval(Lev%S(m), 0.0_pfdp, 2) if ( sweep_y ) then do m = 1 , Nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp , 1 ) !  Forward in y if ( this % explicit ) then do n = 1 , Nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 ), 1 ) !                 call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(m,n), Lev%F(n,1),1) end do end if if ( this % implicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 ), 1 ) !                 call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(m,n), Lev%F(n,2),1) end do end if if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 1 ) !              call Lev%encap%axpy(Lev%S(m), 1.0_pfdp, Lev%tauQ(m),1) end if end do end if if ( sweep_p ) then do m = Nnodes - 1 , 1 , - 1 call lev % I ( m )% setval ( 0.0_pfdp , 2 ) !  Backward in p, note S(m) goes backward now !2          do n =  1,Nnodes !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffE(m,n), Lev%F(Nnodes+1-n,1),2) !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffI(m,n), Lev%F(Nnodes+1-n,2),2) !2          end do if ( this % explicit ) then do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffE ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 1 ), 2 ) !call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(Nnodes-m,Nnodes+1-n), Lev%F(n,1),2) end do end if if ( this % implicit ) then do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 2 ), 2 ) !               call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(Nnodes-m,Nnodes+1-n), Lev%F(n,2),2) end do end if if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 2 ) end if end do end if ! Reload the newest initial values ! Recompute first function values if ( sweep_y ) then if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 , 1 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 , 1 , 1 , step ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 , 1 , 1 , step ) end if !        call Lev%encap%copy(Lev%Q(1), Lev%q0, 1) !        call imexQ_oc%f1eval(Lev%Q(1), t0, Lev%level, Lev%ctx, Lev%F(1,1), 1, 1, step) !        call imexQ_oc%f2eval(Lev%Q(1), t0, Lev%level, Lev%ctx, Lev%F(1,2), 1) end if !else !     if( sweep_p ) then !       if (k .eq. 1) then !         call lev%Q(Nnodes)%copy(lev%qend, 2) !         if (this%explicit) & !           call this%f_eval(lev%Q(Nnodes), tend, lev%index, lev%F(Nnodes,1), 1, 2, Nnodes, step) !         if (this%implicit) & !           call this%f_eval(lev%Q(Nnodes), tend, lev%index, lev%F(Nnodes,2), 2, 2, Nnodes, step) !       end if ! !        call Lev%encap%copy(Lev%Q(Nnodes), Lev%qend, 2) ! !        call imexQ_oc%f1eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,1), 2, Nnodes, step) ! !        call imexQ_oc%f2eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,2), 2) !     end if !     if (sweep_p) then !    !  Backward  sweep on p !       t = tend !       do m =  Nnodes-1,1,-1 !          t = t - dt*this%dtsdc(m) ! !          ! Do the dirk parts !          call this%rhs%setval(0.0_pfdp, 2) !          do n = Nnodes, m+1,-1 !             if (this%explicit) & !               call this%rhs%axpy(dt*this%QtilE(Nnodes-m,Nnodes-n+1), lev%F(n,1), 2) !             if (this%implicit) & !               call this%rhs%axpy(dt*this%QtilI(Nnodes-m,Nnodes-n+1), lev%F(n,2), 2) !          end do ! !          call this%rhs%axpy(1.0_pfdp, lev%I(m), 2) !          call this%rhs%axpy(1.0_pfdp, lev%Q(Nnodes), 2) ! !          !  Do implicit solve !          if (this%implicit) then !            call this%f_comp(lev%Q(m), t, dt*this%QtilI(Nnodes-m,Nnodes-m+1), this%rhs, lev%index, lev%F(m,2), 2, 2) !          else !             call lev%Q(m)%copy(this%rhs,2) !          end if !          if (this%explicit) & !            call this%f_eval(lev%Q(m), t, lev%index, lev%F(m,1), 1, 2, m, step) !       end do !       ! reset first value !       call lev%q0%copy(lev%Q(1), 2) !       call pf_residual(pf, lev, dt, 2) ! !       call pf_residual(pf, lev, dt, which) !     end if !  Make some space !     call Lev%encap%create(rhs, Lev%level, SDC_KIND_SOL_FEVAL, Lev%nvars, Lev%shape, Lev%ctx) if ( sweep_y ) then !  Forward sweep on y t = t0 do m = 1 , Nnodes - 1 t = t + dt * this % dtsdc ( m ) !  forward running time !  Form rhs with all explicit terms call this % rhs % setval ( 0.0_pfdp , 1 ) do n = 1 , m if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 ), 1 ) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 ), 1 ) end do call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 1 ) call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) ! Do implicit solve if ( this % implicit ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 ) else call lev % Q ( m + 1 )% copy ( this % rhs , 1 ) end if !  Compute explicit piece on new value if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 , 1 , m + 1 , step ) end do !  Reset last values call lev % qend % copy ( lev % Q ( Nnodes ), 1 ) !       call pf_residual(pf, lev, dt, 1) !       call pf_residual(pf, lev, dt, which) end if if ( sweep_p ) then !        do m=1, Nnodes-1 !           call lev%I(m)%setval(0.0_pfdp, 2) ! !           !  Backward in p, note S(m) goes backward now ! !2          do n =  1,Nnodes ! !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffE(m,n), Lev%F(Nnodes+1-n,1),2) ! !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffI(m,n), Lev%F(Nnodes+1-n,2),2) ! !2          end do !           if (this%explicit) then !             do n =  Nnodes,1,-1 !               call lev%I(m)%axpy(dt*this%QdiffE(Nnodes-m,Nnodes+1-n), lev%F(n,1), 2) !               !call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(Nnodes-m,Nnodes+1-n), Lev%F(n,1),2) !             end do !           end if !           if (this%implicit) then !             do n =  Nnodes,1,-1 !               call lev%I(m)%axpy(dt*this%QdiffI(Nnodes-m,Nnodes+1-n), lev%F(n,2), 2) ! !               call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(Nnodes-m,Nnodes+1-n), Lev%F(n,2),2) !             end do !           end if !           if (allocated(lev%tauQ)) then !              call lev%I(m)%axpy(1.0_pfdp, lev%tauQ(m), 2) !           end if !       end do if ( k . eq . 1 ) then call lev % Q ( Nnodes )% copy ( lev % qend , 2 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 1 ), 1 , 2 , Nnodes , step ) if ( this % implicit ) & call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 2 ), 2 , 2 , Nnodes , step ) end if !        call Lev%encap%copy(Lev%Q(Nnodes), Lev%qend, 2) !        call imexQ_oc%f1eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,1), 2, Nnodes, step) !        call imexQ_oc%f2eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,2), 2) end if if ( sweep_p ) then !  Backward  sweep on p t = tend do m = Nnodes - 1 , 1 , - 1 t = t - dt * this % dtsdc ( m ) ! Do the dirk parts call this % rhs % setval ( 0.0_pfdp , 2 ) do n = Nnodes , m + 1 , - 1 if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 1 ), 2 ) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 2 ), 2 ) end do call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) call this % rhs % axpy ( 1.0_pfdp , lev % Q ( Nnodes ), 2 ) !  Do implicit solve if ( this % implicit ) then call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 2 ), 2 , 2 ) else call lev % Q ( m )% copy ( this % rhs , 2 ) end if if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , 2 , m , step ) end do ! reset first value call lev % q0 % copy ( lev % Q ( 1 ), 2 ) !       call pf_residual(pf, lev, dt, 2) end if !     if(sweep_p) & !       call this%evaluate_all(lev, t0 + dt*lev%nodes, 2, step) !     if( sweep_p .and. sweep_y ) then !       call pf_residual(pf, lev, dt, 0) !     else if( sweep_y ) then !       call pf_residual(pf, lev, dt, 1) !     else if (sweep_p ) then !       call pf_residual(pf, lev, dt, 2) !     else !       stop \"neither sweep on p nor on y : that should not happen\" !     end if call pf_residual ( pf , lev % index , dt , which ) ! done call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !nsweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imexQ_oc_sweep ! Evaluate function values subroutine imexQ_oc_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , intent ( in ), optional :: flags , step integer :: which , mystep type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC EVAL WITHOUT FLAGS\" mystep = 1 if ( present ( step )) then mystep = step else print * , \"step not present in evaluate\" , which stop end if !     print *, \"IMEXQ_OC EVAL \", which if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , which , m , mystep ) if ( this % implicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , which , m , mystep ) end subroutine imexQ_oc_evaluate subroutine imexQ_oc_evaluate_all ( this , pf , level_index , t , flags , step ) !! Evaluate all function values class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) integer , intent ( in ), optional :: flags , step !     call pf_generic_evaluate_all(this, lev, t, flags, step) integer :: m type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer if (. not . present ( flags )) stop \"IMEXQ_OC EVAL_ALL WITHOUT FLAGS\" if (. not . present ( step )) stop \"IMEXQ_OC EVAL_ALL WITHOUT step\" do m = 1 , lev % nnodes call this % evaluate ( pf , level_index , t ( m ), m , flags , step ) end do end subroutine imexQ_oc_evaluate_all ! Initialize matrices subroutine imexQ_oc_initialize ( this , pf , level_index ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index integer :: Nnodes type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 2 Nnodes = lev % nnodes allocate ( this % QdiffE ( Nnodes - 1 , Nnodes )) !  S-FE allocate ( this % QdiffI ( Nnodes - 1 , Nnodes )) !  S-BE allocate ( this % QtilE ( Nnodes - 1 , Nnodes )) !  S-FE allocate ( this % QtilI ( Nnodes - 1 , Nnodes )) !  S-BE this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp this % dtsdc = lev % nodes ( 2 : Nnodes ) - lev % nodes ( 1 : Nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !!  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_oc_initialize ! Compute SDC integral subroutine imexQ_oc_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) !qSDC unused? real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , intent ( in ), optional :: flags integer :: n , m , Nnodes , which type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer Nnodes = lev % nnodes which = 0 if ( present ( flags )) then which = flags else print * , \"flags not present in integrate\" , which stop end if !     print *, \"IMEXQ_OC INTEGRATE \", which do n = 1 , Nnodes - 1 !  Forward in y if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call fintSDC ( n )% setval ( 0.0_pfdp , 1 ) do m = 1 , Nnodes !               do p = 1, npieces !                 call Lev%encap%axpy(fintSDC(n), dt*Lev%sdcmats%qmat(n,m), fSDC(m,p),1) !               end do if ( this % explicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 1 ), 1 ) if ( this % implicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 2 ), 1 ) end do end if !  Backward in p if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call fintSDC ( Nnodes - n )% setval ( 0.0_pfdp , 2 ) do m = 1 , Nnodes !               do p = 1, npieces !                 call Lev%encap%axpy(fintSDC(Nnodes-n), dt*Lev%sdcmats%qmat(n,m), fSDC(Nnodes+1-m,p),2) !               end do if ( this % explicit ) & call fintSDC ( Nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( Nnodes + 1 - m , 1 ), 2 ) if ( this % implicit ) & call fintSDC ( Nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( Nnodes + 1 - m , 2 ), 2 ) end do end if end do end subroutine imexQ_oc_integrate subroutine imexQ_oc_residual ( this , pf , level_index , dt , flags ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m , which type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) which = 0 if ( present ( flags )) then which = flags else print * , \"flags not present in residual\" , which stop end if !     print *, \"IMEXQ_OC RESIDUAL \", which call this % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I , which ) ! add tau (which is 'node to node') if ( level_index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), which ) end do end if ! subtract out Q do m = 1 , pf % levels ( level_index )% nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do end subroutine imexQ_oc_residual subroutine imexQ_oc_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer :: m , p , which , mystep type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer which = 3 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SPREADQ0 WITHOUT FLAGS\" !     print *, \"IMEXQ_OC SPREADQ0\", which mystep = 1 if ( present ( step )) then mystep = step !needed for sequential version else print * , \"step not present in spreadq0\" , which stop end if select case ( which ) case ( 1 ) !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , 1 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , 1 , 1 , mystep ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), 1 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p ), 1 ) end do end do case ( 2 ) !  Stick terminal condition into last node slot call lev % Q ( lev % nnodes )% copy ( lev % qend , 2 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , lev % nnodes , 2 , mystep ) ! Spread F and solution to all nodes do m = lev % nnodes - 1 , 1 , - 1 call lev % Q ( m )% copy ( lev % Q ( lev % nnodes ), 2 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( lev % nnodes , p ), 2 ) end do end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine imexQ_oc_spreadq0 subroutine imexQ_oc_destroy ( this , pf , level_index ) !  deallocate class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !!  Assign level pointer deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine imexQ_oc_destroy end module pf_mod_imexQ_oc","tags":"","loc":"sourcefile/pf_imexq_oc_sweeper.f90.html","title":"pf_imexQ_oc_sweeper.f90 – LibPFASST"},{"text":"Module of FFT based routines using fftpack Contents Modules pf_mod_fftpackage Source Code pf_fftpack.f90 Source Code !!  Module of FFT based routines using fftpack ! ! This file is part of LIBPFASST. ! !>  Module for using fftpack module pf_mod_fftpackage use pf_mod_dtype use pf_mod_utils use pf_mod_fft_abs implicit none !>  Variables and storage for FFT type , extends ( pf_fft_abs_t ) :: pf_fft_t integer :: lensavx , lensavy , lensavz !! workspace lengths real ( pfdp ) :: normfact !! normalization factor real ( pfdp ), allocatable :: wsavex (:) ! work space real ( pfdp ), allocatable :: wsavey (:) ! work space real ( pfdp ), allocatable :: wsavez (:) ! work space complex ( pfdp ), pointer :: workhatx (:) ! work space complex ( pfdp ), pointer :: workhaty (:) ! work space complex ( pfdp ), pointer :: workhatz (:) ! work space contains procedure :: fft_setup procedure :: fft_destroy procedure :: fftf !  Forward FFT procedure :: fftb !  Inverse (backward)  FFT !  Interpolate in spectral space procedure , private :: interp_1d , interp_2d , interp_3d , zinterp_1d , zinterp_2d , zinterp_3d generic :: interp => interp_1d , interp_2d , interp_3d , zinterp_1d , zinterp_2d , zinterp_3d end type pf_fft_t contains !>  Allocate and initialize FFT structure subroutine fft_setup ( this , grid_shape , dim , grid_size ) class ( pf_fft_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) integer :: nx , ny , nz this % dim = dim !  FFT Storage parameters nx = grid_shape ( 1 ) this % nx = nx this % lensavx = 4 * nx + 15 this % normfact = real ( nx , pfdp ) allocate ( this % workhatx ( nx )) !  complex transform allocate ( this % wsavex ( this % lensavx )) this % Lx = 1.0_pfdp if ( present ( grid_size )) this % Lx = grid_size ( 1 ) !  Initialize FFT call ZFFTI ( nx , this % wsavex ) if ( dim > 1 ) then !  FFT Storage ny = grid_shape ( 2 ) this % ny = ny this % lensavy = 4 * ny + 15 this % normfact = real ( nx * ny , pfdp ) allocate ( this % workhaty ( ny )) !  complex transform allocate ( this % wsavey ( this % lensavy )) this % Ly = 1.0_pfdp if ( present ( grid_size )) this % Ly = grid_size ( 2 ) !  Initialize FFT call ZFFTI ( ny , this % wsavey ) if ( dim > 2 ) then !  FFT Storage nz = grid_shape ( 3 ) this % nz = nz this % lensavz = 4 * nz + 15 this % normfact = real ( nx * ny * nz , pfdp ) allocate ( this % workhatz ( nz )) !  complex transform allocate ( this % wsavez ( this % lensavz )) this % Lz = 1.0_pfdp if ( present ( grid_size )) this % Lz = grid_size ( 3 ) !  Initialize FFT call ZFFTI ( nz , this % wsavez ) endif endif select case ( this % dim ) case ( 1 ) allocate ( this % wk_1d ( nx )) case ( 2 ) allocate ( this % wk_2d ( nx , ny )) case ( 3 ) allocate ( this % wk_3d ( nx , ny , nz )) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_setup !>  Deallocate and destroy fft structures subroutine fft_destroy ( this ) class ( pf_fft_t ), intent ( inout ) :: this deallocate ( this % workhatx ) deallocate ( this % wsavex ) if ( this % dim > 1 ) then deallocate ( this % workhaty ) deallocate ( this % wsavey ) if ( this % dim > 2 ) then deallocate ( this % workhatz ) deallocate ( this % wsavez ) end if end if select case ( this % dim ) case ( 1 ) deallocate ( this % wk_1d ) case ( 2 ) deallocate ( this % wk_2d ) case ( 3 ) deallocate ( this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_destroy !>  Forward fft call subroutine fftf ( this ) class ( pf_fft_t ), intent ( inout ) :: this integer i , j , k select case ( this % dim ) case ( 1 ) call zfftf ( this % nx , this % wk_1d , this % wsavex ) this % wk_1d = this % wk_1d / this % normfact case ( 2 ) do j = 1 , this % ny this % workhatx = this % wk_2d (:, j ) call zfftf ( this % nx , this % workhatx , this % wsavex ) this % wk_2d (:, j ) = this % workhatx end do do i = 1 , this % nx this % workhaty = this % wk_2d ( i ,:) call zfftf ( this % ny , this % workhaty , this % wsavey ) this % wk_2d ( i ,:) = this % workhaty end do this % wk_2d = this % wk_2d / this % normfact case ( 3 ) do k = 1 , this % nz do j = 1 , this % ny this % workhatx = this % wk_3d (:, j , k ) call zfftf ( this % nx , this % workhatx , this % wsavex ) this % wk_3d (:, j , k ) = this % workhatx end do end do do k = 1 , this % nz do i = 1 , this % nx this % workhaty = this % wk_3d ( i ,:, k ) call zfftf ( this % ny , this % workhaty , this % wsavey ) this % wk_3d ( i ,:, k ) = this % workhaty end do end do do j = 1 , this % ny do i = 1 , this % nx this % workhatz = this % wk_3d ( i , j ,:) call zfftf ( this % nz , this % workhatz , this % wsavez ) this % wk_3d ( i , j ,:) = this % workhatz end do end do this % wk_3d = this % wk_3d / this % normfact case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftf !  Backward FFT subroutine fftb ( this ) class ( pf_fft_t ), intent ( inout ) :: this integer i , j , k select case ( this % dim ) case ( 1 ) this % wk_1d = this % wk_1d call zfftb ( this % nx , this % wk_1d , this % wsavex ) case ( 2 ) this % wk_2d = this % wk_2d do j = 1 , this % ny this % workhatx = this % wk_2d (:, j ) call zfftb ( this % nx , this % workhatx , this % wsavex ) this % wk_2d (:, j ) = this % workhatx end do do i = 1 , this % nx this % workhaty = this % wk_2d ( i ,:) call zfftb ( this % ny , this % workhaty , this % wsavey ) this % wk_2d ( i ,:) = this % workhaty end do case ( 3 ) this % wk_3d = this % wk_3d do k = 1 , this % nz do j = 1 , this % ny this % workhatx = this % wk_3d (:, j , k ) call zfftb ( this % nx , this % workhatx , this % wsavex ) this % wk_3d (:, j , k ) = this % workhatx end do end do do k = 1 , this % nz do i = 1 , this % nx this % workhaty = this % wk_3d ( i ,:, k ) call zfftb ( this % ny , this % workhaty , this % wsavey ) this % wk_3d ( i ,:, k ) = this % workhaty end do end do do j = 1 , this % ny do i = 1 , this % nx this % workhatz = this % wk_3d ( i , j ,:) call zfftb ( this % nz , this % workhatz , this % wsavez ) this % wk_3d ( i , j ,:) = this % workhatz end do end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftb subroutine interp_1d ( this , yvec_c , fft_f , yvec_f ) !      use pf_mod_fftpackage, only: pf_fft_t !        class(pf_fft_abs_t), intent(inout) :: this class ( pf_fft_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f integer :: nx_f , nx_c complex ( pfdp ), pointer :: wk_f (:), wk_c (:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_1d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f , pfdp ) end subroutine interp_1d subroutine interp_2d ( this , yvec_c , fft_f , yvec_f ) class ( pf_fft_t ), intent ( inout ) :: this !    class(pf_fft_abs_t), intent(inout) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:,:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:,:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f complex ( pfdp ), pointer :: wk_f (:,:), wk_c (:,:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_2d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f , pfdp ) end subroutine interp_2d subroutine interp_3d ( this , yvec_c , fft_f , yvec_f ) class ( pf_fft_t ), intent ( inout ) :: this !   class(pf_fft_abs_t), intent(inout) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:,:,:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:,:,:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f complex ( pfdp ), pointer :: wk_f (:,:,:), wk_c (:,:,:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_3d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f , pfdp ) end subroutine interp_3d !>  Interpolate from coarse  level to fine subroutine zinterp_1d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:), yhat_c (:) integer :: nx_f , nx_c real ( pfdp ) :: fct nx_f = size ( yhat_f ) nx_c = size ( yhat_c ) fct = real ( nx_f , pfdp ) / real ( nx_c , pfdp ) yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c / 2 ) = yhat_c ( 1 : nx_c / 2 ) yhat_f ( nx_f - nx_c / 2 + 2 : nx_f ) = yhat_c ( nx_c / 2 + 2 : nx_c ) end subroutine zinterp_1d !>  Interpolate from coarse  level to fine subroutine zinterp_2d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:), yhat_c (:,:) integer :: nx_f ( 2 ), nx_c ( 2 ), nf1 , nf2 , nc1 , nc2 nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 )) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 )) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 )) end subroutine zinterp_2d !>  Interpolate from coarse  level to fine subroutine zinterp_3d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:,:), yhat_c (:,:,:) integer :: nx_f ( 3 ), nx_c ( 3 ), nf1 , nf2 , nf3 , nc1 , nc2 , nc3 nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nf3 = nx_f ( 3 ) - nx_c ( 3 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 nc3 = nx_c ( 3 ) / 2 + 2 yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) end subroutine zinterp_3d end module pf_mod_fftpackage","tags":"","loc":"sourcefile/pf_fftpack.f90.html","title":"pf_fftpack.f90 – LibPFASST"},{"text":"Useful subroutines that don't  fit in other modules Contents Modules pf_mod_utils Source Code pf_utils.f90 Source Code !! Useful subroutines that don't  fit in other modules ! ! This file is part of LIBPFASST. ! !> Module with useful subroutines that don't  fit in other modules module pf_mod_utils use pf_mod_dtype use pf_mod_timer implicit none contains ! !> Compute full residual at each node and measure its size subroutine pf_residual ( pf , level_index , dt , flag ) type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flag real ( pfdp ) :: res_norms ( pf % levels ( level_index )% nnodes - 1 ) !!  Holds norms of residual real ( pfdp ) :: sol_norms ( pf % levels ( level_index )% nnodes ) !!  Holds norms of solution ! for adjoint: need sol at t0 as well, not only t0+dt integer :: m type ( pf_level_t ), pointer :: lev call start_timer ( pf , TRESIDUAL ) lev => pf % levels ( level_index ) call lev % ulevel % sweeper % residual ( pf , level_index , dt , flag ) ! compute max residual norm sol_norms ( 1 ) = lev % Q ( 1 )% norm ( flag ) ! for adjoint do m = 1 , lev % nnodes - 1 res_norms ( m ) = lev % R ( m )% norm ( flag ) sol_norms ( m + 1 ) = lev % Q ( m + 1 )% norm ( flag ) ! only the value at lev%nnodes is needed for forward integration, right? end do !    lev%residual = res_norms(lev%nnodes-1) m = lev % nnodes ! for usual forward integration if ( present ( flag )) then if ( flag == 2 ) m = 1 end if lev % residual = maxval ( res_norms ) if ( sol_norms ( m ) > 0.0d0 ) then lev % residual_rel = lev % residual / sol_norms ( m ) else lev % residual_rel = 0.0d0 end if call pf_set_resid ( pf , lev % index , lev % residual ) !    if (pf%save_residuals .and. pf%state%iter>0)  then !       pf%results(lev%index)%residuals(pf%state%iter, pf%state%pfblock, pf%state%sweep) = lev%residual !    end if call end_timer ( pf , TRESIDUAL ) end subroutine pf_residual ! !> Generic residual !! Each sweeper can define its own residual, or use this generic one !! This routine is in the \"Q\" form, so the residual approximates !! R(m)=y(t_n) + \\int_{t_n}&#94;t_m f(y,s) ds - y(t_m) subroutine pf_generic_residual ( this , pf , level_index , dt , flags ) class ( pf_sweeper_t ), intent ( in ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , intent ( in ), optional :: flags integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( lev % index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if !> subtract out the solution value if ( present ( flags )) then do m = 1 , lev % nnodes - 1 if ( ( flags . eq . 0 ) . or . ( flags . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( flags . eq . 0 ) . or . ( flags . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do else do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end if end subroutine pf_generic_residual !>  Output the current residual in the solution subroutine pf_echo_residual ( pf , level_index ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index print '(\"resid: time: \", f8.4,\" step: \",i3.3,\" rank: \",i3.3,\" iter: \",i4.3,\" level: \",i2.2,\" resid: \",es14.7)' , & pf % state % t0 + pf % state % dt , pf % state % step + 1 , pf % rank , pf % state % iter , level_index , pf % levels ( level_index )% residual call flush ( 6 ) end subroutine pf_echo_residual !>  Subroutine to store a residual value subroutine pf_set_resid ( pf , level_index , resid ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: resid if ( pf % save_residuals . and . pf % state % iter > 0 ) then pf % results ( level_index )% residuals ( pf % state % iter , pf % state % pfblock , pf % state % sweep ) = resid end if end subroutine pf_set_resid !>  Subroutine to store a residual value subroutine pf_set_error ( pf , level_index , error ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: error if ( pf % save_residuals . and . pf % state % iter > 0 ) then pf % results ( level_index )% errors ( pf % state % iter , pf % state % pfblock , pf % state % sweep ) = error end if end subroutine pf_set_error ! !> Generic evaluate all !! Each sweeper can define its own evaluate_all or use this generic one subroutine pf_generic_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_sweeper_t ), intent ( in ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step integer :: m class ( pf_level_t ), pointer :: lev !!  points to current level lev => pf % levels ( level_index ) !!  Assign level pointer !     which = 1 !     if(present(flags)) which = flags !     mystep = 1 !     if(present(step)) mystep = step do m = 1 , lev % nnodes call lev % ulevel % sweeper % evaluate ( pf , level_index , t ( m ), m , flags = flags , step = step ) end do end subroutine pf_generic_evaluate_all !> Generic routine to spread initial conditions !! Each sweeper can define its own spreadq0 or use this generic one subroutine pf_generic_spreadq0 ( this , pf , level_index , t0 ) class ( pf_sweeper_t ), intent ( in ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to sweep real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of interval integer :: m , p class ( pf_level_t ), pointer :: lev !!  Level on which to spread lev => pf % levels ( level_index ) !!  Assign level pointer !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , 1 ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 )) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p )) end do end do end subroutine pf_generic_spreadq0 subroutine pf_stop ( pf_file , Nline , msg , N ) character ( len =* ), intent ( in ) :: pf_file integer , intent ( in ) :: Nline character ( len =* ), intent ( in ) :: msg integer , intent ( in ), optional :: N print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * , 'Stopping in File: ' , pf_file print * , 'Line number: ' , Nline print * , msg if ( present ( N )) print * , 'value=' , N print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' stop end subroutine pf_stop subroutine pf_apply_mat ( dst , a , mat , src , zero_first , flags ) !! Apply a matrix (tmat or rmat) to src and add to dst. !! Mathematically this is !!     dst= dst + a*mat*src !!  Where dst and src are vectors, mat is a matrix, and a is a scalar !!  If the optional variable \"zero\" is provided and is true, then we compute !!     dst=  a*mat*src class ( pf_encap_t ), intent ( inout ) :: dst (:) !!  destination vector real ( pfdp ), intent ( in ) :: a !!  scalar real ( pfdp ), intent ( in ) :: mat (:, :) !!  matrix class ( pf_encap_t ), intent ( in ) :: src (:) !!  src vector logical , intent ( in ), optional :: zero_first !! If true, zero out the the dst variable before computing integer , intent ( in ), optional :: flags !! Used for choosing which variable to operate on !!  Local variables logical :: lzero !!  local version of input parameter zero integer :: which !!  local version of flags integer :: n , m !!  size of mat integer :: i , j !!  loop variables lzero = . true .; if ( present ( zero_first )) lzero = zero_first which = 1 ; if ( present ( flags )) which = flags n = size ( mat , dim = 1 ) m = size ( mat , dim = 2 ) do i = 1 , n if ( lzero ) call dst ( i )% setval ( 0.0_pfdp , flags ) do j = 1 , m if ( abs ( a * mat ( i , j )) /= 0.0_pfdp ) call dst ( i )% axpy ( a * mat ( i , j ), src ( j ), flags ) end do end do end subroutine pf_apply_mat subroutine pf_apply_mat_backward ( dst , a , mat , src , zero_first , flags ) !! Apply a matrix (tmat or rmat) to src and add to dst. class ( pf_encap_t ), intent ( inout ) :: dst (:) !!  destination vector real ( pfdp ), intent ( in ) :: a !!  scalar real ( pfdp ), intent ( in ) :: mat (:, :) !!  matrix class ( pf_encap_t ), intent ( in ) :: src (:) !!  src vector logical , intent ( in ), optional :: zero_first !! If true, zero out the the dst variable before computing integer , intent ( in ), optional :: flags !! Used for choosing which variable to operate on !!  Local variables logical :: lzero !!  local version of input parameter zero integer :: which !!  local version of flags integer :: n , m !!  size of mat integer :: i , j !!  loop variables lzero = . true .; if ( present ( zero_first )) lzero = zero_first which = 2 ; if ( present ( flags )) which = flags if ( which /= 2 ) & stop \"pf_apply_mat_backward can only be used for restricting the backward integrals with which==2\" n = size ( mat , dim = 1 ) m = size ( mat , dim = 2 ) do i = 1 , n if ( lzero ) call dst ( n + 1 - i )% setval ( 0.0_pfdp , 2 ) do j = 1 , m if ( abs ( a * mat ( i , j )) /= 0.0_pfdp ) call dst ( n + 1 - i )% axpy ( a * mat ( i , j ), src ( m + 1 - j ), 2 ) end do end do end subroutine pf_apply_mat_backward end module pf_mod_utils","tags":"","loc":"sourcefile/pf_utils.f90.html","title":"pf_utils.f90 – LibPFASST"},{"text":"Restriction operators Contents Modules pf_mod_restrict Source Code pf_restrict.f90 Source Code !!  Restriction operators ! ! This file is part of LIBPFASST. ! module pf_mod_restrict !!  Module to restrict solutions between pfasst levels and create the FAS tau correction use pf_mod_dtype use pf_mod_timer use pf_mod_hooks use pf_mod_utils implicit none contains subroutine restrict_time_space_fas ( pf , t0 , dt , level_index , flags , mystep ) !! Restrict (in time and space) fine level to coarse and set coarse level FAS correction. !! !! The coarse function values are re-evaluated after restriction. !! Note that even if the number of variables and nodes is the same, !! we should still compute the FAS correction since the function !! evaluations may be different. type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of step real ( pfdp ), intent ( in ) :: dt !!  time step integer , intent ( in ) :: level_index !! defines which level to restrict integer , optional , intent ( in ) :: flags , mystep !>  Local variables class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p integer :: m , step real ( pfdp ), allocatable :: c_times (:) !!  Simulation time at coarse nodes real ( pfdp ), allocatable :: f_times (:) !!  Simulation time at fine nodes f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) step = pf % state % step + 1 if ( present ( mystep )) step = mystep call call_hooks ( pf , level_index , PF_PRE_RESTRICT_ALL ) call start_timer ( pf , TRESTRICT + level_index - 1 ) allocate ( c_times ( c_lev_p % nnodes )) allocate ( f_times ( f_lev_p % nnodes )) !> restrict q's and recompute f's c_times = t0 + dt * c_lev_p % nodes f_times = t0 + dt * f_lev_p % nodes call restrict_ts ( f_lev_p , c_lev_p , f_lev_p % Q , c_lev_p % Q , f_times , flags ) !>  Recompute the functions call c_lev_p % ulevel % sweeper % evaluate_all ( pf , level_index - 1 , c_times , flags = flags , step = step ) !>  Compute  FAS correction do m = 1 , c_lev_p % nnodes - 1 call c_lev_p % tauQ ( m )% setval ( 0.0_pfdp , flags ) end do if ( pf % state % iter >= pf % taui0 ) then ! compute '0 to node' integral on the coarse level call c_lev_p % ulevel % sweeper % integrate ( pf , level_index - 1 , c_lev_p % Q , & c_lev_p % F , dt , c_lev_p % I , flags ) ! compute '0 to node' integral on the fine level call f_lev_p % ulevel % sweeper % integrate ( pf , level_index , f_lev_p % Q , & f_lev_p % F , dt , f_lev_p % I , flags ) !  put tau in on fine level if ( level_index < pf % state % finest_level ) then do m = 1 , f_lev_p % nnodes - 1 call f_lev_p % I ( m )% axpy ( 1.0_pfdp , f_lev_p % tauQ ( m ), flags ) end do end if !  Subtract coarse integral do m = 1 , c_lev_p % nnodes - 1 call c_lev_p % tauQ ( m )% axpy ( - 1.0_pfdp , c_lev_p % I ( m ), flags ) end do ! restrict '0 to node' integral on the fine level  in time and space call restrict_ts_integral ( f_lev_p , c_lev_p , f_lev_p % I , c_lev_p % I , f_times , flags ) ! Add fine restriction of fine integral (stored on coarse) do m = 1 , c_lev_p % nnodes - 1 call c_lev_p % tauQ ( m )% axpy ( 1.0_pfdp , c_lev_p % I ( m ), flags ) end do !!$       if (pf%use_Sform) then !!$          do m = c_lev_p%nnodes-1,2,-1 !!$!             call c_lev_p%tauQ(m)%axpy(-1.0_pfdp, c_lev_p%tauQ(m-1), flags) !!$          end do !!$       end if end if call end_timer ( pf , TRESTRICT + level_index - 1 ) call call_hooks ( pf , level_index , PF_POST_RESTRICT_ALL ) deallocate ( c_times ) deallocate ( f_times ) end subroutine restrict_time_space_fas subroutine restrict_ts ( f_lev_p , c_lev_p , f_encap_array , c_encap_array , f_time , flags ) !! Restrict (in time and space) f_sol_array  to c_sol_array !! This version is for point values (either functions or solutions) class ( pf_level_t ), intent ( inout ) :: f_lev_p !!   pointer to fine level class ( pf_level_t ), intent ( inout ) :: c_lev_p !!   pointer to coarse level class ( pf_encap_t ), intent ( inout ) :: f_encap_array (:) !! array of fine level data to be restricted class ( pf_encap_t ), intent ( inout ) :: c_encap_array (:) !! array of coarse level data to be computed real ( pfdp ), intent ( in ) :: f_time (:) !! time at the fine nodes integer , optional , intent ( in ) :: flags class ( pf_encap_t ), allocatable :: f_encap_array_c (:) !!  fine solution restricted in space only integer :: m , j integer :: f_nnodes , c_nnodes f_nnodes = f_lev_p % nnodes c_nnodes = c_lev_p % nnodes !!  Create a temp array for the spatial restriction call c_lev_p % ulevel % factory % create_array ( f_encap_array_c , f_nnodes , c_lev_p % index , c_lev_p % shape ) !  spatial restriction do m = 1 , f_nnodes call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_encap_array ( m ), f_encap_array_c ( m ), f_time ( m ), flags ) end do ! temporal restriction if ( present ( flags )) then if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) & call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_p % rmat , f_encap_array_c , . true ., flags ) if (( flags . eq . 0 ) . or . ( flags . eq . 2 )) & call pf_apply_mat_backward ( c_encap_array , 1.0_pfdp , f_lev_p % rmat , f_encap_array_c , . true ., flags = 2 ) else call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_p % rmat , f_encap_array_c , . true .) end if call c_lev_p % ulevel % factory % destroy_array ( f_encap_array_c ) end subroutine restrict_ts subroutine restrict_ts_integral ( f_lev_p , c_lev_p , f_encap_array , c_encap_array , f_time , flags ) !! Restrict (in time and space) f_sol_array  to c_sol_array !! This version is for integrals class ( pf_level_t ), intent ( inout ) :: f_lev_p !!   pointer to fine level class ( pf_level_t ), intent ( inout ) :: c_lev_p !!   pointer to coarse level class ( pf_encap_t ), intent ( inout ) :: f_encap_array (:) !! array of fine level data to be restricted class ( pf_encap_t ), intent ( inout ) :: c_encap_array (:) !! array of coarse level data to be computed real ( pfdp ), intent ( in ) :: f_time (:) !! time at the fine nodes integer , optional , intent ( in ) :: flags class ( pf_encap_t ), allocatable :: f_encap_array_c (:) !!  fine solution restricted in space only integer :: m , j integer :: f_nnodes , c_nnodes f_nnodes = f_lev_p % nnodes c_nnodes = c_lev_p % nnodes !!  Create a temp array for the spatial restriction call c_lev_p % ulevel % factory % create_array ( f_encap_array_c , f_nnodes - 1 , c_lev_p % index , c_lev_p % shape ) !  spatial restriction do m = 1 , f_nnodes - 1 call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_encap_array ( m ), f_encap_array_c ( m ), f_time ( m ), flags ) end do ! temporal restriction ! when restricting '0 to node' integral terms, skip the first entry since it is zero if ( present ( flags )) then if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) & call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_p % rmat ( 2 :, 2 :), f_encap_array_c , . true ., flags = 1 ) if (( flags . eq . 0 ) . or . ( flags . eq . 2 )) & call pf_apply_mat_backward ( c_encap_array , 1.0_pfdp , f_lev_p % rmat ( 2 :, 2 :), f_encap_array_c , . true ., flags = 2 ) else call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_p % rmat ( 2 :, 2 :), f_encap_array_c , . true .) end if call c_lev_p % ulevel % factory % destroy_array ( f_encap_array_c ) end subroutine restrict_ts_integral end module pf_mod_restrict","tags":"","loc":"sourcefile/pf_restrict.f90.html","title":"pf_restrict.f90 – LibPFASST"},{"text":"Main controllers for optimal control problems Contents Modules pf_mod_parallel_oc Source Code pf_parallel_oc.f90 Source Code !!  Main controllers for optimal control problems ! ! This file is part of LIBPFASST. ! !> Module of parallel PFASST routines for optimal control problems. module pf_mod_parallel_oc use pf_mod_pfasst use pf_mod_interpolate use pf_mod_restrict use pf_mod_utils use pf_mod_timer use pf_mod_dtype use pf_mod_hooks use pf_mod_comm implicit none contains subroutine pf_predictor_oc ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p integer :: k !!  Loop indices integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k integer :: which , dir , send_tag , burnin_sweeps , my_coarse_sweeps which = 1 ! standard: predict and sweep forward-in-time dir = 1 ! for MPI communication, standard is forward-in-time if ( present ( flags )) then if ( flags ( 1 ) == 2 ) then which = 2 ! if we are computing an adjoint, predict and sweep backward-in-time dir = 2 ! communication has to be backwards as well end if if ( flags ( 1 ) == 0 ) which = 0 ! sweep forward and backward simultaneously on two components, communication only forwards end if call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning predictor' !! Step 1. Getting the  initial condition on the finest level at each processor !!         If we are doing multiple levels, then we need to coarsen to fine level f_lev_p => pf % levels ( pf % state % finest_level ) if ( pf % q0_style < 2 ) then !  Spread q0 to all the nodes if ( ( which == 0 ) . or . ( which == 1 )) call f_lev_p % ulevel % sweeper % spreadq0 ( pf , pf % state % finest_level , t0 , 1 , pf % state % step + 1 ) if ( ( which == 0 ) . or . ( which == 2 )) call f_lev_p % ulevel % sweeper % spreadq0 ( pf , pf % state % finest_level , t0 + dt , 2 , pf % state % step + 1 ) endif !!  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do coarsen  in predictor' if ( pf % state % finest_level > 1 ) then do level_index = pf % state % finest_level , 2 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call pf_residual ( pf , f_lev_p % index , dt , which ) if ( ( which == 0 ) . or . ( which == 1 )) & call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0 , t0 , flags = 1 ) if ( ( which == 0 ) . or . ( which == 2 )) & call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % qend , c_lev_p % qend , t0 + dt , flags = 2 ) call restrict_time_space_fas ( pf , t0 , dt , level_index , flags = which ) !  Restrict call save ( pf , c_lev_p , which ) end do !  level_index = pf%state%finest_level, 2, -1 end if level_index = 1 c_lev_p => pf % levels ( 1 ) if ( pf % q0_style < 3 ) then ! Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !         (this is skipped if the fine initial conditions are already consistent) ! The first processor does nothing, the second does one set of sweeps, the 2nd two, etc ! Hence, this is skipped completely if nprocs=1 if ( pf % q0_style . eq . 0 ) then !  The coarse level needs burn in if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do burnin in pred' , ' RK_pred' , pf % RK_pred , ' PFASST_pred' , pf % PFASST_pred !! If RK_pred is true, just do some RK_steps if ( pf % RK_pred . or . which == 2 ) then !  Use Runge-Kutta to get the coarse initial data !  Get new initial conditions call pf_recv ( pf , c_lev_p , 100000 + pf % rank , . true ., dir ) !  Do a RK_step call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 , which ) !  Send forward/backward if ( dir == 1 ) send_tag = 100000 + pf % rank + 1 if ( dir == 2 ) send_tag = 100000 + pf % rank - 1 call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) else !  Normal PFASST burn in burnin_sweeps = pf % rank + 1 if ( which == 2 ) then if ( pf % rank == 0 ) & print * , 'WARNING --- normal PFASST burn in is not suitable for adjoint as rhs cannot be evaluated for [t0k, t0k+dt]' burnin_sweeps = pf % comm % nproc - pf % rank end if if ( pf % debug ) print * , 'DEBUG ---' , pf % rank , 'which = ' , which , 'burnin_sweeps = ' , burnin_sweeps do k = 1 , burnin_sweeps !pf%rank + 1 pf % state % iter = - k t0k = t0 - ( pf % rank ) * dt + ( k - 1 ) * dt ! Remember t0=pf%rank*dt is the beginning of this time slice so t0-(pf%rank)*dt is 0 ! and we iterate up to the correct time step. ! for optimal control problem t, t0k has no influence on f_eval, so there this does something else if ( which == 2 ) t0k = t0 + ( burnin_sweeps - 1 ) * dt - ( k - 1 ) * dt if ( pf % debug ) print * , 'DEBUG ----' , pf % rank , 't0k = ' , t0k ! Get new initial value (skip on first iteration) if ( k > 1 ) then if (( which == 0 ) . or . ( which == 1 )) call c_lev_p % q0 % copy ( c_lev_p % qend , 1 ) !                 if ((which == 0) .or. (which == 2)) call c_lev_p%qend%copy(c_lev_p%q0, 2) ! for which==0, we solve with zero terminal conditions, ! but q0,2 is not zero (source term due to state sweeps) if ( which == 2 ) call c_lev_p % qend % copy ( c_lev_p % q0 , 2 ) ! If we are doing PFASST_pred, we use the old values at nodes, otherwise spread q0 if (. not . pf % PFASST_pred ) then if ( ( which == 0 ) . or . ( which == 1 )) call c_lev_p % ulevel % sweeper % spreadq0 ( pf , level_index , t0k , 1 , pf % state % step + 1 ) !                    if( (which == 0) .or. (which == 2)) call c_lev_p%ulevel%sweeper%spreadq0(pf,level_index, t0k+dt, 2, pf%state%step+1) if ( which == 2 ) call c_lev_p % ulevel % sweeper % spreadq0 ( pf , level_index , t0k + dt , 2 , pf % state % step + 1 ) end if end if !  Do some sweeps if ( which == 0 . or . which == 1 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn , 1 ) ! was: 1 not which if ( which == 2 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn , 2 ) end do endif !  RK_pred end if ! (q0_style .eq. 0) if ( pf % q0_style > 0 ) then my_coarse_sweeps = pf % rank + 1 ! for warm start do pipelining if ( which == 2 ) my_coarse_sweeps = pf % comm % nproc - pf % rank else my_coarse_sweeps = c_lev_p % nsweeps_pred end if ! Step 4: Now we have everyone burned in, so do some coarse sweeps ! Modification: each processor does sweeps according to its rank if ( pf % state % finest_level > 1 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do sweeps  in predictor' , ' Pipeline_pred' , pf % Pipeline_pred level_index = 1 c_lev_p => pf % levels ( level_index ) if ( pf % Pipeline_pred ) then do k = 1 , my_coarse_sweeps !c_lev_p%nsweeps_pred pf % state % iter =- ( pf % rank + 1 ) - k !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + k , . true ., dir ) !  Do a sweep call c_lev_p % ulevel % sweeper % sweep ( pf , c_lev_p % index , t0 , dt , 1 , which ) !  Send forward/backward if ( dir == 1 ) send_tag = c_lev_p % index * 1110000 + pf % rank + 1 + k if ( dir == 2 ) send_tag = c_lev_p % index * 1110000 + pf % rank - 1 + k call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) end do ! k = 1, c_lev_p%nsweeps_pred-1 else !  Don't pipeline !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 100000 + pf % rank , . true ., dir ) !  Do sweeps !         if(which == 0 .or. which == 1) call c_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, c_lev_p%nsweeps_pred, 1) !1 ! why only state? if ( which == 0 . or . which == 1 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , my_coarse_sweeps , which ) !1 ! why only state? !         if(which == 2)                 call c_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, c_lev_p%nsweeps_pred, 2) !which if ( which == 2 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , my_coarse_sweeps , 2 ) !which !  Send forward/backward if ( dir == 1 ) send_tag = c_lev_p % index * 100000 + pf % rank + 1 if ( dir == 2 ) send_tag = c_lev_p % index * 100000 + pf % rank - 1 call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) endif ! (Pipeline_pred .eq. .true) then end if ! pf%state%finest_level > 1 !  Step 5:  Return to fine level sweeping on any level in between coarsest and finest if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'returning to fine level in predictor' do level_index = 2 , pf % state % finest_level !  Will do nothing with one level f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp , flags = which ) if (( which == 0 ) . or . ( which == 1 )) then call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 1 ) if ( pf % rank /= 0 ) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 1 ) end if if ( which == 2 ) then ! for which==0, qend never changes, so don't need to interpolate call f_lev_p % q0 % copy ( f_lev_p % Q ( 1 ), flags = 2 ) if ( pf % rank /= pf % comm % nproc - 1 ) call interpolate_qend ( pf , f_lev_p , c_lev_p ) end if !  Do sweeps on level unless we are at the finest level if ( level_index < pf % state % finest_level ) then if (( which == 0 ) . or . ( which == 1 )) & call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred , which ) !which was 1 if ( which == 2 ) & call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred , 2 ) end if end do end if call end_timer ( pf , TPREDICTOR ) call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' end subroutine pf_predictor_oc !> Subroutine to test residuals to determine if the current processor has converged. subroutine pf_check_residual_oc ( pf , level_index , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if relative tolerance is met if ( pf % levels ( level_index )% residual_rel < pf % rel_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , ' residual relative tol met' , pf % levels ( level_index )% residual_rel residual_converged = . true . end if ! Check to see if relative tolerance is met if ( pf % levels ( level_index )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( level_index )% residual residual_converged = . true . end if end subroutine pf_check_residual_oc !> !> Test residuals to determine if the current processor has converged, !> adapted to optimal control. Can probably be removed, when pf_pfasst_block_oc !> is changed to use pf_check_convergence of pf_check_convergence_old. !> !> Note that if the previous processor hasn't converged yet !> (pstatus), the current processor hasn't converged yet either, !> regardless of the residual. !> !   subroutine pf_check_convergence_oc(pf, k, residual,converged, flags) subroutine pf_check_convergence_oc ( pf , level_index , send_tag , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index integer , intent ( in ) :: send_tag !     real(pfdp),        intent(inout) :: residual !     integer,           intent(in)    :: k !     logical,           intent(out)   :: converged   !!  True if this processor is done integer , optional , intent ( in ) :: flags !     real(pfdp)     :: residual1 integer :: dir , which logical :: residual_converged , converged converged = . false . ! shortcut for fixed block mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if ! in first sweep: always continue if ( pf % state % iter == 1 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual_oc ( pf , level_index , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag , dir ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 . and . dir == 1 ) then converged = . true . elseif ( pf % rank == pf % comm % nproc - 1 . and . dir == 2 ) then converged = . true . else !  I am not the first/last processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag , dir ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag , dir ) end if call call_hooks ( pf , 1 , PF_POST_CONVERGENCE ) end subroutine pf_check_convergence_oc !>  Routine to do the pfasst iterations for optimal control problems on one block of processors until completion. !>  Each processor will do either a fixed number of iterations, or iterate until a tolerance is met !>  On calling, it is assumed that the levels are already loaded with the initial guesses !> subroutine pf_pfasst_block_oc ( pf , dt , nsteps , predict , flags , step ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps logical , intent ( in ) :: predict integer , optional , intent ( in ) :: flags !0 (default): sweep on y and p, 1: just y, 2: just p integer , optional , intent ( in ) :: step ! not yet clear how to handle send and receive for forward and backward combined type ( pf_level_t ), pointer :: fine_lev_p , coarse_lev_p integer :: k , j , l , which , pred_flags ( 1 ), dir , ierror !dir to choose forward or backward send real ( pfdp ) :: residual logical :: converged , qbroadcast logical :: did_post_step_hook call start_timer ( pf , TTOTAL ) which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 pred_flags ( 1 ) = which if ( present ( step ) ) then pf % state % step = step else pf % state % step = pf % rank end if !     print *, pf%state%step pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % t0 = pf % state % step * dt pf % state % iter = - 1 !     pf%state%itcnt   = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % nsteps = nsteps !     pf%state%component = which residual = - 1 did_post_step_hook = . false . !       if (pf%state%status == PF_STATUS_PREDICTOR) then !         !print *, 'pf%state%status == PF_STATUS_PREDICTOR', pf%state%t0, dt, which if ( predict ) then !print *, 'calling predictor' call pf_predictor_oc ( pf , pf % state % t0 , dt , pred_flags ) end if !       end if call call_hooks ( pf , - 1 , PF_POST_ITERATION ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING k = pf % state % pfblock ! !pf%state%pfblock = k ! has to be set in pf_optimization_flex to current step ! this is relevant for save_residuals do j = 1 , pf % niters call start_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle !       call pf_v_cycle(pf, k, pf%state%t0, dt, 1 ,pf%nlevels) call pf_v_cycle_oc ( pf , j , pf % state % t0 , dt , 1 , pf % state % finest_level , which ) !  Check for convergence call pf_check_convergence_oc ( pf , pf % state % finest_level , send_tag = 1111 * k + j , flags = dir ) call call_hooks ( pf , - 1 , PF_POST_ITERATION ) call end_timer ( pf , TITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) exit end do !  Loop over the iteration in this block call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) pf % state % itcnt = pf % state % itcnt + pf % state % iter call call_hooks ( pf , - 1 , PF_POST_STEP ) !    call pf_dump_results(pf) call end_timer ( pf , TTOTAL ) end subroutine pf_pfasst_block_oc subroutine pf_v_cycle_oc ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) ! Execute a V-cycle between levels nfine and ncoarse type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j , which , dir which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 ! !>  Post the nonblocking receives on the all the levels that will be recieving later !>    (for single level this will be skipped) do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ) call pf_post ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , dir ) end do !> move from fine to coarse doing sweeps do level_index = level_index_f , level_index_c + 1 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) call restrict_time_space_fas ( pf , t0 , dt , level_index , flags = which ) call save ( pf , c_lev_p , which ) end do !> Do the coarsest level level_index = level_index_c f_lev_p => pf % levels ( level_index ) if ( pf % pipeline_pred ) then do j = 1 , f_lev_p % nsweeps call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . true ., dir ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 , which ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . false ., dir ) end do else call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . true ., dir ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . false ., dir ) endif !> Now move coarse to fine interpolating and sweeping do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp , flags = which ) if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 1 ) if ( flags . eq . 2 ) call f_lev_p % q0 % copy ( f_lev_p % Q ( 1 ), flags = 2 ) call pf_recv ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) if ( pf % rank /= 0 ) then ! interpolate increment to q0 -- the fine initial condition ! needs the same increment that Q(1) got, but applied to the ! new fine initial condition if (( which . eq . 0 ) . or . ( which . eq . 1 )) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 1 ) end if if ( pf % rank /= pf % comm % nproc - 1 ) then if ( which . eq . 2 ) call interpolate_qend ( pf , f_lev_p , c_lev_p ) end if ! don't sweep on the finest level since that is only done at beginning if ( level_index < level_index_f ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) else !  compute residual for diagnostics since we didn't sweep call pf_residual ( pf , f_lev_p % index , dt , which ) end if end do end subroutine pf_v_cycle_oc end module pf_mod_parallel_oc","tags":"","loc":"sourcefile/pf_parallel_oc.f90.html","title":"pf_parallel_oc.f90 – LibPFASST"},{"text":"Old style Asynchronous MISDC sweeper Contents Modules pf_mod_amisdc Source Code pf_amisdc_sweeper.f90 Source Code !! Old style Asynchronous MISDC sweeper ! ! This file is part of LIBPFASST. ! !> Old style Asynchronous MISDC sweeper module pf_mod_amisdc use pf_mod_dtype use pf_mod_utils implicit none !>  Asynchronous multi-implicit sweeper type (old style) type , extends ( pf_sweeper_t ), abstract :: pf_amisdc_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f1eval_p ), deferred :: f1eval procedure ( pf_f2eval_p ), deferred :: f2eval procedure ( pf_f2comp_p ), deferred :: f2comp procedure ( pf_f3eval_p ), deferred :: f3eval procedure ( pf_f3comp_p ), deferred :: f3comp procedure :: sweep => amisdc_sweep procedure :: initialize => amisdc_initialize procedure :: evaluate => amisdc_evaluate procedure :: integrate => amisdc_integrate procedure :: residual => amisdc_residual procedure :: evaluate_all => amisdc_evaluate_all procedure :: destroy => amisdc_destroy procedure :: amisdc_destroy end type pf_amisdc_t interface subroutine pf_f1eval_p ( this , y , t , level , f1 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y class ( pf_encap_t ), intent ( inout ) :: f1 real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level end subroutine pf_f1eval_p subroutine pf_f2eval_p ( this , y , t , level , f2 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y class ( pf_encap_t ), intent ( inout ) :: f2 real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level end subroutine pf_f2eval_p subroutine pf_f2comp_p ( this , y , t , dt , rhs , level , f2 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: rhs class ( pf_encap_t ), intent ( inout ) :: y , f2 real ( pfdp ), intent ( in ) :: t , dt integer , intent ( in ) :: level end subroutine pf_f2comp_p subroutine pf_f3eval_p ( this , y , t , level , f3 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y class ( pf_encap_t ), intent ( inout ) :: f3 real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level end subroutine pf_f3eval_p subroutine pf_f3comp_p ( this , y , t , dt , rhs , level , f3 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: rhs class ( pf_encap_t ), intent ( inout ) :: y , f3 real ( pfdp ), intent ( in ) :: t , dt integer , intent ( in ) :: level end subroutine pf_f3comp_p end interface contains ! Perform on SDC sweep on level lev and set qend appropriately. subroutine amisdc_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhsA , rhsB , QA , QB call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f1eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) call this % f2eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 )) call this % f3eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 )) call lev % ulevel % factory % create_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QB , lev % index , lev % shape ) call QA % setval ( 0.0_pfdp ) call QB % setval ( 0.0_pfdp ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) ! First compute the explicit part of the right-hand side call rhsA % copy ( lev % Q ( m )) call rhsA % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhsA % axpy ( 1.0_pfdp , lev % S ( m )) ! Save the right-hand side with only the explicit contribution call rhsB % copy ( rhsA ) ! Add the first implicit part to the right-hand side and solve for the first asynchronous update call rhsA % axpy ( - 2.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 2 )) call this % f2comp ( QA , t , 2.0_pfdp * dtsdc ( m ), rhsA , lev % index , lev % F ( m + 1 , 2 )) ! Add the second implicit part to the right-hand side and solve for the second asynchronous update call rhsB % axpy ( - 2.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 3 )) call this % f3comp ( QB , t , 2.0_pfdp * dtsdc ( m ), rhsB , lev % index , lev % F ( m + 1 , 3 )) ! Now we average the two asynchronous updates call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QA ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QB ) ! Evaluate the three right-hand sides with the updated variables call this % f1eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 )) call this % f2eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 )) call this % f3eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 3 )) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! Destroy the temporary variables call lev % ulevel % factory % destroy_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QB , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine amisdc_sweep ! Evaluate function values subroutine amisdc_evaluate ( this , lev , t , m ) use pf_mod_dtype class ( pf_amisdc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f1eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) call this % f2eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 )) call this % f3eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 )) end subroutine amisdc_evaluate ! Initialize matrices subroutine amisdc_initialize ( this , lev ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine amisdc_initialize ! Destroy the matrices subroutine amisdc_destroy ( this , lev ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine amisdc_destroy ! Compute SDC integral subroutine amisdc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine amisdc_integrate subroutine amisdc_residual ( this , lev , dt ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine amisdc_residual subroutine amisdc_evaluate_all ( this , lev , t ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine amisdc_evaluate_all end module pf_mod_amisdc","tags":"","loc":"sourcefile/pf_amisdc_sweeper.f90.html","title":"pf_amisdc_sweeper.f90 – LibPFASST"},{"text":"Timing routines Contents Modules pf_mod_timer Source Code pf_timer.f90 Source Code !!  Timing routines ! ! This file is part of LIBPFASST. ! !> Module for setting timers module pf_mod_timer use pf_mod_dtype use pf_mod_mpi implicit none !  List of timers integer , parameter :: & TTOTAL = 1 , & TPREDICTOR = 2 , & TITERATION = 3 , & THOOKS = 4 , & TSTEP = 5 , & TRESIDUAL = 6 , & TBROADCAST = 7 , & TINTERPOLATE = 10 , & TRESTRICT = 20 , & TRECEIVE = 30 , & TSEND = 40 , & TLEVEL = 50 , & TAUX = 60 ! if you add more timers here, make sure to update the timer arrays in pf_dtype.f90 character ( len = 14 ), parameter :: timer_names ( 62 ) = ( / & 'total       ' , & ! 1 'predictor   ' , & 'iteration   ' , & 'hooks       ' , & 'step        ' , & ! 5 'residual    ' , & 'broadcast   ' , & '8           ' , & '9           ' , & 'interpL1    ' , & ! 10 'interpL2    ' , & 'interpL3    ' , & 'interpL4    ' , & 'interpL5    ' , & 'interpL6    ' , & 'interpL7    ' , & 'interpL8    ' , & 'interpL9    ' , & 'interpL10   ' , & 'restrictL1  ' , & ! 20 'restrictL2  ' , & 'restrictL3  ' , & 'restrictL4  ' , & 'restrictL5  ' , & 'restrictL6  ' , & 'restrictL7  ' , & 'restrictL8  ' , & 'restrictL9  ' , & 'restrictL10 ' , & 'recvL1      ' , & ! 30 'recvL2      ' , & 'recvL3      ' , & 'recvL4      ' , & 'recvL5      ' , & 'recvL6      ' , & 'recvL7      ' , & 'recvL8      ' , & 'recvL9      ' , & 'recvL10     ' , & 'sendL1      ' , & ! 40 'sendL2      ' , & 'sendL3      ' , & 'sendL4      ' , & 'sendL5      ' , & 'sendL6      ' , & 'sendL7      ' , & 'sendL8      ' , & 'sendL9      ' , & 'sendL10     ' , & 'sweepL1     ' , & ! 50 'sweepL2     ' , & 'sweepL3     ' , & 'sweepL4     ' , & 'sweepL5     ' , & 'sweepL6     ' , & 'sweepL7     ' , & 'sweepL8     ' , & 'sweepL9     ' , & 'sweepL10    ' , & 'exp         ' , & ! 60 'omega       ' , & 'feval       ' / ) contains !>  Subroutine to start a timer subroutine start_timer ( pf , timer ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: timer pf % timers ( timer ) = MPI_Wtime () end subroutine start_timer !>  Subroutine to stop a timer subroutine end_timer ( pf , timer ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: timer double precision :: t t = MPI_Wtime () pf % runtimes ( timer ) = pf % runtimes ( timer ) + t - pf % timers ( timer ) if ( pf % echo_timings ) then write ( * , '(\"timer:\",a16,\", rank: \",i3,\", step: \",i4, \", level: \", i3,' & // '\", iter: \",i3, f23.8,f23.8,f23.8)' ) & timer_names ( timer ), pf % rank , & pf % state % step , pf % state % level , pf % state % iter , & t - pf % timers ( timer ), pf % runtimes ( timer ), t - pf % timers ( TTOTAL ) end if end subroutine end_timer end module pf_mod_timer","tags":"","loc":"sourcefile/pf_timer.f90.html","title":"pf_timer.f90 – LibPFASST"},{"text":"Some convenient use statements Contents Modules pfasst Source Code pfasst.f90 Source Code !! Some convenient use statements ! ! This file is part of LIBPFASST. ! !>  Module containing a collection of \"use\" statements to simplify !!  including the common main modules in writing applications that use libpfasst module pfasst use pf_mod_dtype use pf_mod_hooks use pf_mod_results use pf_mod_parallel use pf_mod_pfasst use pf_mod_utils #ifndef NOMPI use pf_mod_comm_mpi #endif end module pfasst","tags":"","loc":"sourcefile/pfasst.f90.html","title":"pfasst.f90 – LibPFASST"},{"text":"Module for storing results for eventual output Contents Modules pf_mod_results Source Code pf_results.f90 Source Code !! Module for storing results for eventual output ! ! This file is part of LIBPFASST. ! !>  Module for the storing results for eventual output module pf_mod_results use pf_mod_dtype use pf_mod_utils implicit none contains subroutine initialize_results ( this , nsteps_in , niters_in , nprocs_in , nsweeps_in , rank_in , level_index , datpath , save_residuals ) class ( pf_results_t ), intent ( inout ) :: this integer , intent ( in ) :: nsteps_in , niters_in , nprocs_in , nsweeps_in , rank_in , level_index character ( len =* ), intent ( in ) :: datpath logical , intent ( in ) :: save_residuals character ( len = 128 ) :: fname !!  output file name for residuals character ( len = 256 ) :: fullname !!  output file name for residuals integer :: istat , system !  Set up the directory to dump results if ( save_residuals ) then istat = system ( 'mkdir -p ' // trim ( datpath )) this % datpath = trim ( datpath ) // '/' if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in initialize_results\" ) write ( fname , \"(A16,I0.1,A4)\" ) 'residuals_size_L' , level_index , '.dat' fullname = trim ( this % datpath ) // trim ( fname ) if ( rank_in == 0 ) then open ( unit = 123 , file = trim ( fullname ), form = 'formatted' ) write ( 123 , '(I5, I5, I5, I5)' ) nsteps_in , niters_in , nprocs_in , nsweeps_in close ( unit = 123 ) end if end if !    this%dump => dump_results this % destroy => destroy_results this % nsteps = nsteps_in this % nblocks = nsteps_in / nprocs_in this % niters = niters_in this % nprocs = nprocs_in this % nsweeps = nsweeps_in this % rank = rank_in this % level = level_index if (. not . allocated ( this % errors )) allocate ( this % errors ( niters_in , this % nblocks , nsweeps_in )) if (. not . allocated ( this % residuals )) allocate ( this % residuals ( niters_in , this % nblocks , nsweeps_in )) this % errors = - 1.0_pfdp this % residuals = - 1.0_pfdp end subroutine initialize_results subroutine dump_resids ( this ) type ( pf_results_t ), intent ( inout ) :: this integer :: i , j , k , istat , system character ( len = 128 ) :: fname !!  output file name for residuals character ( len = 256 ) :: fullname !!  output file name for residuals character ( len = 128 ) :: datpath !!  directory path datpath = trim ( this % datpath ) // 'residuals' istat = system ( 'mkdir -p ' // trim ( datpath )) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in dump_resids\" ) write ( fname , \"(A6,I0.3,A5,I0.1,A4)\" ) '/Proc_' , this % rank , '_Lev_' , this % level , '.dat' fullname = trim ( datpath ) // trim ( fname ) !  output residuals open ( 100 + this % rank , file = trim ( fullname ), form = 'formatted' ) do j = 1 , this % nblocks do i = 1 , this % niters do k = 1 , this % nsweeps write ( 100 + this % rank , '(I4, I4, I4, e22.14)' ) j , i , k , this % residuals ( i , j , k ) end do end do enddo close ( 100 + this % rank ) end subroutine dump_resids subroutine dump_errors ( this ) type ( pf_results_t ), intent ( inout ) :: this integer :: i , j , k , istat , system character ( len = 128 ) :: fname !!  output file name for residuals character ( len = 256 ) :: fullname !!  output file name for residuals character ( len = 128 ) :: datpath !!  directory path datpath = trim ( this % datpath ) // 'errors' istat = system ( 'mkdir -p ' // trim ( datpath )) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in dump_errors\" ) write ( fname , \"(A6,I0.3,A5,I0.1,A4)\" ) '/Proc_' , this % rank , '_Lev_' , this % level , '.dat' fullname = trim ( datpath ) // trim ( fname ) !  output errors open ( 100 + this % rank , file = trim ( fullname ), form = 'formatted' ) do j = 1 , this % nblocks do i = 1 , this % niters do k = 1 , this % nsweeps write ( 100 + this % rank , '(I4, I4, I4, e22.14)' ) j , i , k , this % errors ( i , j , k ) end do end do enddo close ( 100 + this % rank ) end subroutine dump_errors subroutine dump_timings ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf character ( len = 128 ) :: fname !!  output file name for runtimes character ( len = 256 ) :: fullname !!  output file name for runtimes character ( len = 128 ) :: datpath !!  directory path integer :: istat , j , istream , system datpath = trim ( pf % outdir ) // '/runtimes' istat = system ( 'mkdir -p ' // trim ( datpath )) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in dump_timings\" ) write ( fname , \"(A6,I0.3,A4)\" ) '/Proc_' , pf % rank , '.dat' fullname = trim ( datpath ) // trim ( fname ) istream = 200 + pf % rank !  Use processor dependent file number !  output timings open ( istream , file = trim ( fullname ), form = 'formatted' ) do j = 1 , 100 if ( pf % runtimes ( j ) > 0.0d0 ) then write ( istream , '(a16,  f23.8)' ) timer_names ( j ), pf % runtimes ( j ) end if end do close ( istream ) end subroutine dump_timings subroutine destroy_results ( this ) type ( pf_results_t ), intent ( inout ) :: this if ( allocated ( this % errors )) deallocate ( this % errors ) if ( allocated ( this % residuals )) deallocate ( this % residuals ) end subroutine destroy_results end module pf_mod_results","tags":"","loc":"sourcefile/pf_results.f90.html","title":"pf_results.f90 – LibPFASST"},{"text":"N-dimensional array encapsulation. Contents Modules pf_mod_ndarray Source Code pf_ndarray_encap.f90 Source Code !!  N-dimensional array encapsulation. ! ! This file is part of LIBPFASST. ! !> N-dimensional array encapsulation. !! !! When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'shape' attribute to create a new array with that !! shape.  Thus, the 'shape' attributes of the PFASST levels should be !! set appropriately.  For example, before calling pf_pfasst_run we can !! set the shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%shape(2)) !!   pf%levels(1)%shape = [ 3, 10 ] !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to the encapsulated array without !! performing any copies. !! module pf_mod_ndarray use iso_c_binding use pf_mod_dtype use pf_mod_utils implicit none !>  Type to create and destroy N-dimenstional arrays type , extends ( pf_factory_t ) :: ndarray_factory contains procedure :: create_single => ndarray_create_single procedure :: create_array => ndarray_create_array procedure :: destroy_single => ndarray_destroy_single procedure :: destroy_array => ndarray_destroy_array end type ndarray_factory !>  N-dimensional array type,  extends the abstract encap type type , extends ( pf_encap_t ) :: ndarray integer :: dim integer , allocatable :: shape (:) real ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => ndarray_setval procedure :: copy => ndarray_copy procedure :: norm => ndarray_norm procedure :: pack => ndarray_pack procedure :: unpack => ndarray_unpack procedure :: axpy => ndarray_axpy procedure :: eprint => ndarray_eprint end type ndarray !> Interfaces to output routines in pf_numpy.c interface !>  Subroutine to write an the array to a file subroutine ndarray_dump_numpy ( dname , fname , endian , dim , mpibuflen , shape , array ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname , fname , endian ( 5 ) integer , intent ( in ), value :: dim , mpibuflen integer , intent ( in ) :: shape ( dim ) real ( c_double ), intent ( in ) :: array ( mpibuflen ) end subroutine ndarray_dump_numpy end interface contains function cast_as_ndarray ( encap_polymorph ) result ( ndarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndarray ), pointer :: ndarray_obj select type ( encap_polymorph ) type is ( ndarray ) ndarray_obj => encap_polymorph end select end function cast_as_ndarray !>  Subroutine to allocate the array and set the size parameters subroutine ndarray_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) select type ( q ) class is ( ndarray ) allocate ( q % shape ( size ( shape ))) allocate ( q % flatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape end select end subroutine ndarray_build !> Subroutine to  create a single array subroutine ndarray_create_single ( this , x , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) integer :: i allocate ( ndarray :: x ) call ndarray_build ( x , shape ) end subroutine ndarray_create_single !> Subroutine to create an array of arrays subroutine ndarray_create_array ( this , x , n , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndarray :: x ( n )) do i = 1 , n call ndarray_build ( x ( i ), shape ) end do end subroutine ndarray_create_array !>  Subroutine to destroy array subroutine ndarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndarray ), pointer :: ndarray_obj ndarray_obj => cast_as_ndarray ( encap ) deallocate ( ndarray_obj % shape ) deallocate ( ndarray_obj % flatarray ) nullify ( ndarray_obj ) end subroutine ndarray_destroy !> Subroutine to destroy an single array subroutine ndarray_destroy_single ( this , x ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( ndarray ) deallocate ( x % shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine ndarray_destroy_single !> Subroutine to destroy an array of arrays subroutine ndarray_destroy_array ( this , x ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( ndarray ) do i = 1 , size ( x ) deallocate ( x ( i )% shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine ndarray_destroy_array !>  The following are the base subroutines that all encapsulations must provide !! !> Subroutine to set array to a scalare  value. subroutine ndarray_setval ( this , val , flags ) class ( ndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine ndarray_setval !> Subroutine to copy an array subroutine ndarray_copy ( this , src , flags ) class ( ndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( ndarray ) this % flatarray = src % flatarray class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_copy !> Subroutine to pack an array into a flat array for sending subroutine ndarray_pack ( this , z , flags ) class ( ndarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags z = this % flatarray end subroutine ndarray_pack !> Subroutine to unpack a flatarray after receiving subroutine ndarray_unpack ( this , z , flags ) class ( ndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags this % flatarray = z end subroutine ndarray_unpack !> Subroutine to define the norm of the array (here the max norm) function ndarray_norm ( this , flags ) result ( norm ) class ( ndarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function ndarray_norm !> Subroutine to compute y = a x + y where a is a scalar and x and y are arrays subroutine ndarray_axpy ( this , a , x , flags ) class ( ndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( ndarray ) this % flatarray = a * x % flatarray + this % flatarray class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_axpy !>  Subroutine to print the array to the screen (mainly for debugging purposes) subroutine ndarray_eprint ( this , flags ) class ( ndarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values if ( product ( this % shape ) < 10 ) then print * , this % flatarray else print * , this % flatarray ( 1 : 10 ) endif end subroutine ndarray_eprint !>  Helper function to return the array part function get_array1d ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) select type ( x ) type is ( ndarray ) r => x % flatarray end select end function get_array1d function get_array2d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( ndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % flatarray end select end function get_array2d function get_array3d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( ndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % flatarray end select end function get_array3d end module pf_mod_ndarray","tags":"","loc":"sourcefile/pf_ndarray_encap.f90.html","title":"pf_ndarray_encap.f90 – LibPFASST"},{"text":"Multi-implicit forward-backward sweeper module Contents Modules pf_mod_misdcQ_oc Source Code pf_misdcQ_oc_sweeper.f90 Source Code !! Multi-implicit forward-backward sweeper module ! ! This file is part of LIBPFASST. ! !>  Module of the  the derived sweeper class for doing MISDC sweeps for an equation of the form !!            y' = f_1(y) + f_2(y) + f_3(y)  !!  The f_1 piece is treated explicitly and f_2 and f_3 implicitly !!  Afer this sweeper is initialized (usually in main), the locgical flags can be changed if desired module pf_mod_misdcQ_oc use pf_mod_dtype use pf_mod_utils implicit none !>  Multi-implicit SDC sweeper type for optimal control, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_misdcQ_oc_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) real ( pfdp ), allocatable :: dtsdc (:) class ( pf_encap_t ), allocatable :: I3 (:) class ( pf_encap_t ), allocatable :: rhs contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdcQ_oc_sweep procedure :: initialize => misdcQ_oc_initialize procedure :: integrate => misdcQ_oc_integrate procedure :: residual => misdcQ_oc_residual procedure :: spreadq0 => misdcQ_oc_spreadq0 procedure :: evaluate_all => misdcQ_oc_evaluate_all procedure :: evaluate => misdcQ_oc_evaluate procedure :: destroy => misdcQ_oc_destroy procedure :: misdcQ_oc_destroy procedure :: misdcQ_oc_initialize end type pf_misdcQ_oc_t interface !>  This is the interface for the routine to compute the RHS function values !>  Evaluate f_piece(y), where piece is one or two subroutine pf_f_eval_p ( this , y , t , level_index , f , piece , flags , idx , step ) !>  Evaluate f_piece(y), where piece is one or two import pf_misdcQ_oc_t , pf_encap_t , pfdp class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value integer , intent ( in ) :: piece !!  Which piece to evaluate integer , intent ( in ) :: flags !!  forward or backward integer , intent ( in ), optional :: idx !! index of quadrature node integer , intent ( in ), optional :: step !! time step for sequential version end subroutine pf_f_eval_p !>  Solve the equation y - dtq*f_n(y) =rhs  where n is given by the argument piece subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece , flags ) import pf_misdcQ_oc_t , pf_encap_t , pfdp class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_n of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate integer , intent ( in ) :: flags !!  forward or backward end subroutine pf_f_comp_p end interface contains ! Perform one forward and/or backward SDC sweep on level and set qend/q0 appropriately. subroutine misdcQ_oc_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index , nsweeps real ( pfdp ), intent ( in ) :: dt , t0 integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev integer :: k , m , n , which , Nnodes real ( pfdp ) :: t , tend logical :: sweep_y , sweep_p integer :: step lev => pf % levels ( level_index ) !  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) step = pf % state % step + 1 which = 0 if ( present ( flags )) which = flags if ( which . eq . 1 ) then sweep_y = . true . sweep_p = . false . else if ( which . eq . 2 ) then sweep_y = . false . sweep_p = . true . else sweep_y = . true . sweep_p = . true . end if Nnodes = lev % nnodes tend = t0 + dt do k = 1 , nsweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction if ( sweep_y ) then !  Forward in y do m = 1 , Nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp , 1 ) call this % I3 ( m )% setval ( 0.0_pfdp , 1 ) do n = 1 , Nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 ), 1 ) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( m , n ), lev % F ( n , 3 ), 1 ) call this % I3 ( m )% axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 ), 1 ) end do if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 1 ) end if end do end if if ( sweep_p ) then !  Backward in p do m = Nnodes - 1 , 1 , - 1 call lev % I ( m )% setval ( 0.0_pfdp , 2 ) call this % I3 ( m )% setval ( 0.0_pfdp , 2 ) do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffE ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 1 ), 2 ) call lev % I ( m )% axpy ( dt * this % QdiffI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 2 ), 2 ) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 3 ), 2 ) call this % I3 ( m )% axpy ( dt * this % QtilI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 3 ), 2 ) end do if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 2 ) end if end do end if ! do the time-stepping if ( k . eq . 1 ) then if ( sweep_y ) then call lev % Q ( 1 )% copy ( lev % q0 , 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 , 1 , 1 , step ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 , 1 , 1 , step ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 , 1 , 1 , step ) end if if ( sweep_p ) then call lev % Q ( Nnodes )% copy ( lev % qend , 2 ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 1 ), 1 , 2 , Nnodes , step ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 2 ), 2 , 2 , Nnodes , step ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 3 ), 3 , 2 , Nnodes , step ) end if end if ! k .eq. 1 if ( sweep_y ) then t = t0 do m = 1 , lev % nnodes - 1 t = t + dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp , 1 ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 ), 1 ) call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 ), 1 ) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 1 ) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( lev % Q ( m + 1 ), 1 ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 ), 1 ) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m ), 1 ) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 3 ), 3 , 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 , 1 , m + 1 , step ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 , m + 1 , step ) end do !call pf_residual(pf, level_index, dt, 1) call lev % qend % copy ( lev % Q ( lev % nnodes ), 1 ) end if ! sweep_y if ( sweep_p ) then t = tend do m = Nnodes - 1 , 1 , - 1 t = t - dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp , 2 ) do n = Nnodes , m + 1 , - 1 call this % rhs % axpy ( dt * this % QtilE ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 1 ), 2 ) call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 2 ), 2 ) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( Nnodes ), 2 ) call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 2 ), 2 , 2 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( lev % Q ( m ), 2 ) do n = Nnodes , m + 1 , - 1 call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 3 ), 2 ) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m ), 2 ) call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 3 ), 3 , 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , 2 , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , 2 , m , step ) end do !call pf_residual(pf, level_index, dt, 2) call lev % q0 % copy ( lev % Q ( 1 ), 2 ) end if ! sweep_p if ( sweep_p . and . sweep_y ) then call pf_residual ( pf , level_index , dt , 0 ) else if ( sweep_y ) then call pf_residual ( pf , level_index , dt , 1 ) else if ( sweep_p ) then call pf_residual ( pf , level_index , dt , 2 ) else stop \"neither sweep on p nor on y : that should not happen\" end if ! done call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! k=1,nsweeps end subroutine misdcQ_oc_sweep ! Initialize matrices subroutine misdcQ_oc_initialize ( this , pf , level_index ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index integer :: m , n , nnodes type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % dtsdc ( nnodes - 1 )) this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) !>  Make space for extra integration piece call lev % ulevel % factory % create_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) end subroutine misdcQ_oc_initialize subroutine misdcQ_oc_destroy ( this , pf , level_index ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % I3 ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine misdcQ_oc_destroy ! Compute SDC integral subroutine misdcQ_oc_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: n , m , p , which type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer which = 0 if ( present ( flags )) which = flags do n = 1 , lev % nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call fintSDC ( n )% setval ( 0.0_pfdp , 1 ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , p ), 1 ) end do end do end if !  Backward in p if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call fintSDC ( lev % nnodes - n )% setval ( 0.0_pfdp , 2 ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( lev % nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( lev % nnodes + 1 - m , p ), 2 ) end do end do end if end do end subroutine misdcQ_oc_integrate ! Evaluate function values subroutine misdcQ_oc_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , optional , intent ( in ) :: flags , step integer :: which , mystep type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer which = 0 if ( present ( flags )) which = flags mystep = 1 if ( present ( step )) mystep = step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , which , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , which , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 , which , m , step ) end subroutine misdcQ_oc_evaluate subroutine misdcQ_oc_evaluate_all ( this , pf , level_index , t , flags , step ) !! Evaluate all function values class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) integer , intent ( in ), optional :: flags , step integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer if (. not . present ( flags )) stop \"MISDCQ_OC EVAL_ALL WITHOUT FLAGS\" if (. not . present ( step )) stop \"MISDCQ_OC EVAL_ALL WITHOUT step\" do m = 1 , lev % nnodes call this % evaluate ( pf , level_index , t ( m ), m , flags , step ) end do end subroutine misdcQ_oc_evaluate_all subroutine misdcQ_oc_residual ( this , pf , level_index , dt , flags ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m , n , which type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer which = 0 if ( present ( flags )) which = flags call this % integrate ( pf , level_index , pf % levels ( level_index )% Q , pf % levels ( level_index )% F , dt , & pf % levels ( level_index )% I , which ) ! add tau (which is 'node to node') if ( level_index < pf % state % finest_level ) then do m = 1 , pf % levels ( level_index )% nnodes - 1 call pf % levels ( level_index )% I ( m )% axpy ( 1.0_pfdp , pf % levels ( level_index )% tauQ ( m ), which ) end do end if ! subtract out Q do m = 1 , pf % levels ( level_index )% nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call pf % levels ( level_index )% R ( m )% copy ( pf % levels ( level_index )% I ( m ), 1 ) call pf % levels ( level_index )% R ( m )% axpy ( 1.0_pfdp , pf % levels ( level_index )% Q ( 1 ), 1 ) call pf % levels ( level_index )% R ( m )% axpy ( - 1.0_pfdp , pf % levels ( level_index )% Q ( m + 1 ), 1 ) end if if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call pf % levels ( level_index )% R ( m )% copy ( pf % levels ( level_index )% I ( m ), 2 ) call pf % levels ( level_index )% R ( m )% axpy ( 1.0_pfdp , pf % levels ( level_index )% Q ( pf % levels ( level_index )% nnodes ), 2 ) call pf % levels ( level_index )% R ( m )% axpy ( - 1.0_pfdp , pf % levels ( level_index )% Q ( m ), 2 ) end if end do end subroutine misdcQ_oc_residual subroutine misdcQ_oc_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer :: m , p , which , mystep type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer which = 3 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SPREADQ0 WITHOUT FLAGS\" mystep = 1 if ( present ( step )) then mystep = step !needed for sequential version else print * , \"step not present in spreadq0\" , which stop end if select case ( which ) case ( 1 ) !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , 1 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , 1 , 1 , mystep ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), 1 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p ), 1 ) end do end do case ( 2 ) !  Stick terminal condition into last node slot call lev % Q ( lev % nnodes )% copy ( lev % qend , 2 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , lev % nnodes , 2 , mystep ) ! Spread F and solution to all nodes do m = lev % nnodes - 1 , 1 , - 1 call lev % Q ( m )% copy ( lev % Q ( lev % nnodes ), 2 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( lev % nnodes , p ), 2 ) end do end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) stop end select end subroutine misdcQ_oc_spreadq0 end module pf_mod_misdcQ_oc","tags":"","loc":"sourcefile/pf_misdcq_oc_sweeper.f90.html","title":"pf_misdcQ_oc_sweeper.f90 – LibPFASST"},{"text":"Routines that run the PFASST algorithm Contents Modules pf_mod_parallel Source Code pf_parallel.f90 Source Code !!  Routines that run the PFASST algorithm ! ! This file is part of LIBPFASST. ! !> Module of routines to run  PFASST module pf_mod_parallel use pf_mod_pfasst use pf_mod_interpolate use pf_mod_restrict use pf_mod_utils use pf_mod_timer use pf_mod_dtype use pf_mod_hooks use pf_mod_comm use pf_mod_results implicit none contains !>  This is the main interface to pfasst. !!  It examines the parameters and decides which subroutine to call !!  to execute the code correctly subroutine pf_pfasst_run ( pf , q0 , dt , tend , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  The complete PFASST structure class ( pf_encap_t ), intent ( inout ) :: q0 !!  The initial condition real ( pfdp ), intent ( in ) :: dt !!  The time step for each processor real ( pfdp ), intent ( in ) :: tend !!  The final time of run integer , intent ( in ), optional :: nsteps !!  The number of time steps class ( pf_encap_t ), intent ( inout ), optional :: qend !!  The computed solution at tend integer , intent ( in ), optional :: flags (:) !!  User defnined flags !  Local variables integer :: nproc !!  Total number of processors integer :: nsteps_loc !!  local number of time steps real ( pfdp ) :: tend_loc !!  The final time of run ! make a local copy of nproc nproc = pf % comm % nproc !>  Set the number of time steps to do !!  The user can either pass in the number of time steps or !!  pass in the time step size and length of run if ( present ( nsteps )) then nsteps_loc = nsteps tend_loc = dble ( nsteps_loc * dt ) else nsteps_loc = ceiling ( tend / dt ) !  Do  sanity check on steps if ( abs ( real ( nsteps_loc , pfdp ) - tend / dt ) > dt / 10 0.0 ) then print * , 'dt=' , dt print * , 'nsteps=' , nsteps_loc print * , 'tend=' , tend stop \"Invalid nsteps\" end if end if pf % state % nsteps = nsteps_loc !>  Allocate stuff for holding results call pf_initialize_results ( pf ) !  do sanity checks on Nproc if ( mod ( nsteps , nproc ) > 0 ) stop \"ERROR: nsteps must be multiple of nproc (pf_parallel.f90).\" if ( present ( qend )) then call pf_block_run ( pf , q0 , dt , nsteps_loc , qend = qend , flags = flags ) else call pf_block_run ( pf , q0 , dt , nsteps_loc , flags = flags ) end if call pf_dump_results ( pf ) !>   deallocate results data call pf_destroy_results ( pf ) !  What we would like to do is check for !  1.  nlevels==1  and nprocs ==1 -> Serial SDC !      Predictor is either spreadQ or nothing !      Then we just call a loop on sweeps !      Communication is copy !  2.  nlevels > 1  and nprocs ==1 -> Serial MLSDC !      Predictor is needed to populate levels (or nothing) !      Then we just call a loop on MLSDC sweeps !      Communication is copy !  3.  nlevels == 1  and nprocs > 1 -> Pipelined SDC !      Predictor is just like PFASST, but on finest (only) level (or nothing) !  4.  nlevels > 1  and nprocs > 1 -> PFASST end subroutine pf_pfasst_run ! !> PFASST Predictor. !>  Subroutine  to initialize the solution on each processor !!  The goal is to have a solution at each level and each node set to a consistent value !!  When this is called, the value of q0 at the fine level on each processor has been set somehow (see q0_style below) !! !! This can be broken down into four substeps !! 1. Get the  initial condition on the finest level at each node !! 2. Coarsen the initial condition to each coarser level with tau corrections !! 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !!    (this is skipped if the fine initial conditions are already consistent) !! 4. Do some coarse grid sweeps to improve initial solutions on coarsest nodes !! 5. Interpolating coarse correction back to finer levels sweeping along the way. !! !! There are several parameters or flags that determine how things are done: !!  integer  q0_style:    can take 3 values !!           0:  Only the q0 at t=0 is valid  (default) !!           1:  The q0 at each processor is valid !!           2:  q0 and all nodes at each processor is valid !! logical  PFASST_pred:  If true, the burn-in step uses the \"PFASST predictor\" trick !! integer  nsweeps_burn: Determines how many sweeps are done on the coarse level during burn in !! integer  nsweeps_pred: Determines how many sweeps are done at the coarse level after burn in !! logical Pipeline_burn: True if coarse sweeps during burn in are pipelined  (meaningless if nsweeps_burn>1 on coarse level) !! logical Pipeline_pred: True if coarse sweeps after burn in are pipelined  (meaningless if nsweeps_pred>1 on coarse level) !!    Pipeline variables do nothing if there is only one processor !! logical  RK_pred:      If true, the coarse level is initialized with Runge-Kutta instead of the  PFASST burn in. !!                        We  will still do coarse sweeps after and correct finer levels !! !! The user defined flags(:) parameter is used to determine whether we are in a (standard) forward-in-time run (flags(1) == 1) !! or backward-in-time (for the adjoint) with a given terminal condition qend instead of initial condition q0  (flags(1) == 2). !! In the latter case, e.g., sweeper%spreadq0 has to do the correct thing (i.e., spread qend instead of q0). !! !! No time communication is performed during the predictor since all !! procesors can do the work themselves !! !!  The iteration count is reset to 0, and the status is reset to !!  ITERATING. subroutine pf_predictor ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p !! integer :: k !!  Loop indices integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k pf % state % iter = - 1 call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning predictor' !! !! Step 1. Getting the  initial condition on the finest level at each processor !!         If we are doing multiple levels, then we need to coarsen to fine level f_lev_p => pf % levels ( pf % state % finest_level ) if ( pf % q0_style < 2 ) then !  Spread q0 to all the nodes call f_lev_p % ulevel % sweeper % spreadq0 ( pf , pf % state % finest_level , t0 ) endif !! !!  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do coarsen  in predictor' if ( pf % state % finest_level > 1 ) then do level_index = pf % state % finest_level , 2 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call pf_residual ( pf , f_lev_p % index , dt ) call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0 , t0 ) call restrict_time_space_fas ( pf , t0 , dt , level_index ) !  Restrict call save ( pf , c_lev_p ) end do !  level_index = pf%state%finest_level, 2, -1 else level_index = 1 c_lev_p => pf % levels ( 1 ) end if !! !! Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !!         (this is skipped if the fine initial conditions are already consistent) !! The first processor does nothing, the second does one set of sweeps, the third two, etc !! Hence, this is skipped completely if nprocs=1 if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do burnin  in predictor' if ( pf % q0_style . eq . 0 ) then !  The coarse level needs burn in !! If RK_pred is true, just do some RK_steps if ( pf % RK_pred ) then !  Use Runge-Kutta to get the coarse initial data !  Get new initial conditions call pf_recv ( pf , c_lev_p , 100000 + pf % rank , . true .) !  Do a RK_step call c_lev_p % ulevel % stepper % do_n_steps ( pf , level_index , t0 , c_lev_p % q0 , c_lev_p % qend , dt , 1 ) !  Send forward call pf_send ( pf , c_lev_p , 100000 + pf % rank + 1 , . false .) print * , 'woo hoo' else !  Normal PFASST burn in level_index = 1 c_lev_p => pf % levels ( level_index ) do k = 1 , pf % rank + 1 pf % state % iter = - k t0k = t0 - ( pf % rank ) * dt + ( k - 1 ) * dt ! Remember t0=pf%rank*dt is the beginning of this time slice so t0-(pf%rank)*dt is 0 ! and we iterate up to the correct time step. ! for optimal control problem t, t0k has no influence on f_eval, so there this does something else ! Get new initial value (skip on first iteration) if ( k > 1 ) then call c_lev_p % q0 % copy ( c_lev_p % qend , flags = 0 ) ! If we are doing PFASST_pred, we use the old values at nodes, otherwise spread q0 if (. not . pf % PFASST_pred ) then call c_lev_p % ulevel % sweeper % spreadq0 ( pf , level_index , t0k ) end if end if !  Do some sweeps call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn ) end do endif !  RK_pred end if ! (q0_style .eq. 0) !! !! Step 4: Now we have everyone burned in, so do some coarse sweeps if ( pf % state % finest_level > 1 ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do sweeps  in predictor' , 'Pipeline_pred' , pf % Pipeline_pred pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING if ( pf % Pipeline_pred ) then do k = 1 , c_lev_p % nsweeps_pred pf % state % iter =- ( pf % rank + 1 ) - k !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + k , . true .) !  Do a sweep call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) !  Send forward call pf_send ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + 1 + k , . false .) end do ! k = 1, c_lev_p%nsweeps_pred-1 else !  Don't pipeline !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank , . true .) !  Do a sweeps call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , c_lev_p % nsweeps_pred ) !  Send forward call pf_send ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + 1 , . false .) endif ! (Pipeline_pred .eq. .true) then end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'returning to fine level in predictor' !! !!  Step 5:  Return to fine level sweeping on any level in between coarsest and finest do level_index = 2 , pf % state % finest_level !  Will do nothing with one level f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp ) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 0 ) if ( pf % rank /= 0 ) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 0 ) !  Do a sweep on level unless we are at the finest level if ( level_index < pf % state % finest_level ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred ) end if end do call end_timer ( pf , TPREDICTOR ) call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' end subroutine pf_predictor !> Subroutine to test residuals to determine if the current processor has converged. subroutine pf_check_residual ( pf , level_index , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if relative tolerance is met if ( pf % levels ( level_index )% residual_rel < pf % rel_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , ' residual relative tol met' , pf % levels ( level_index )% residual_rel residual_converged = . true . print * , 'DEBUG --' , pf % rank , 'residual_rel tol met' , pf % levels ( level_index )% residual_rel end if ! Check to see if absolute tolerance is met if ( pf % levels ( level_index )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( level_index )% residual residual_converged = . true . print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( level_index )% residual end if end subroutine pf_check_residual !> Subroutine to check if the current processor has converged and !> to update the next processor on the status !> Note that if the previous processor hasn't converged yet !> (pstatus), the current processor can't be converged yet either subroutine pf_check_convergence_block ( pf , level_index , send_tag ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index integer , intent ( in ) :: send_tag !! identifier for status send and receive logical :: residual_converged , converged ! Shortcut for fixed iteration mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual ( pf , level_index , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 ) then converged = . true . else !  I am not the first processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag ) end if end subroutine pf_check_convergence_block ! !>  PFASST controller for block mode subroutine pf_block_run ( pf , q0 , dt , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf class ( pf_encap_t ), intent ( in ) :: q0 real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps class ( pf_encap_t ), intent ( inout ), optional :: qend integer , intent ( in ), optional :: flags (:) class ( pf_level_t ), pointer :: lev_p !!  pointer to the one level we are operating on integer :: j , k integer :: nblocks !!  The number of blocks of steps to do integer :: nproc !!  The number of processors being used integer :: level_index_c !!  Coarsest level in V (Lambda)-cycle integer :: level_max_depth !!  Finest level in V-cycle call start_timer ( pf , TTOTAL ) pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % step = pf % rank pf % state % t0 = pf % state % step * dt ! set finest level to visit in the following run pf % state % finest_level = pf % nlevels !  pointer to finest  level to start lev_p => pf % levels ( pf % state % finest_level ) !  Stick the initial condition into q0 (will happen on all processors) call lev_p % q0 % copy ( q0 , flags = 0 ) nproc = pf % comm % nproc nblocks = nsteps / nproc !  Decide what the coarsest level in the V-cycle is level_index_c = 1 if (. not . pf % Vcycle ) level_index_c = pf % state % finest_level do k = 1 , nblocks !  Loop over blocks of time steps ! print *,'Starting  step=',pf%state%step,'  block k=',k ! Each block will consist of !  1.  predictor !  2.  Vcycle until max iterations, or tolerances met !  3.  Move solution to next block !  Reset some flags !>  When starting a new block, broadcast new initial conditions to all procs !>  For initial block, this is done when initial conditions are set !> Reset some flags pf % state % iter = - 1 pf % state % itcnt = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % pfblock = k if ( k > 1 ) then if ( nproc > 1 ) then call lev_p % qend % pack ( lev_p % send ) !!  Pack away your last solution call pf_broadcast ( pf , lev_p % send , lev_p % mpibuflen , pf % comm % nproc - 1 ) call lev_p % q0 % unpack ( lev_p % send ) !!  Everyone resets their q0 else call lev_p % q0 % copy ( lev_p % qend , flags = 0 ) !!  Just stick qend in q0 end if !>  Update the step and t0 variables for new block pf % state % step = pf % state % step + pf % comm % nproc pf % state % t0 = pf % state % step * dt end if !> Call the predictor to get an initial guess on all levels and all processors call pf_predictor ( pf , pf % state % t0 , dt , flags ) !>  Start the loops over SDC sweeps pf % state % iter = 0 call call_hooks ( pf , - 1 , PF_POST_ITERATION ) call start_timer ( pf , TITERATION ) do j = 1 , pf % niters call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle call pf_v_cycle ( pf , k , pf % state % t0 , dt , level_index_c , pf % state % finest_level ) !  Check for convergence call pf_check_convergence_block ( pf , pf % state % finest_level , send_tag = 1111 * k + j ) !          print *,pf%rank, ' post res' call call_hooks ( pf , - 1 , PF_POST_ITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) then call pf % levels ( pf % nlevels )% ulevel % sweeper % sweep ( pf , pf % nlevels , pf % state % t0 , dt , 1 ) exit end if end do !  Loop over the iteration in this bloc call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) call end_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_POST_STEP ) end do !  Loop over the blocks call end_timer ( pf , TTOTAL ) !  Grab the last solution for return (if wanted) if ( present ( qend )) then call qend % copy ( lev_p % qend , flags = 0 ) end if end subroutine pf_block_run !> Execute a V-cycle between levels nfine and ncoarse subroutine pf_v_cycle ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j !>  Post the nonblocking receives on the all the levels that will be recieving later !>    (for single level this will be skipped) do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ) call pf_post ( pf , f_lev_p , f_lev_p % index * 10000 + iteration ) end do !> move from fine to coarse doing sweeps do level_index = level_index_f , level_index_c + 1 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false .) call restrict_time_space_fas ( pf , t0 , dt , level_index ) call save ( pf , c_lev_p ) end do ! Do the coarsest level level_index = level_index_c f_lev_p => pf % levels ( level_index ) if ( pf % pipeline_pred ) then do j = 1 , f_lev_p % nsweeps call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . true .) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . false .) end do else call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . true .) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . false .) endif ! Now move coarse to fine interpolating and sweeping do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp ) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 0 ) call pf_recv ( pf , f_lev_p , level_index * 10000 + iteration , . false .) if ( pf % rank /= 0 ) then ! interpolate increment to q0 -- the fine initial condition ! needs the same increment that Q(1) got, but applied to the ! new fine initial condition call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 0 ) end if ! don't sweep on the finest level since that is only done at beginning if ( level_index <= level_index_f ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) else !  compute residual for diagnostics since we didn't sweep pf % state % sweep = 1 call pf_residual ( pf , f_lev_p % index , dt ) end if end do end subroutine pf_v_cycle end module pf_mod_parallel","tags":"","loc":"sourcefile/pf_parallel.f90.html","title":"pf_parallel.f90 – LibPFASST"},{"text":"Communication wrappers Contents Modules pf_mod_comm Source Code pf_comm.f90 Source Code !!  Communication wrappers ! ! This file is part of LIBPFASST. ! !> Module of communication wrappers module pf_mod_comm use pf_mod_pfasst implicit none contains !>  Subroutine to post a receive request for a new initial condition to be received after doing some work subroutine pf_post ( pf , level , tag , direction ) type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: ierror , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'is beginning pf_post, state%pstatus=' , pf % state % pstatus , 'with tag =' , tag ierror = 0 if ( pf % rank /= 0 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 1 ) then source = pf % rank - 1 call pf % comm % post ( pf , level , tag , ierror , source ) elseif ( pf % rank /= pf % comm % nproc - 1 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 2 ) then source = pf % rank + 1 call pf % comm % post ( pf , level , tag , ierror , source ) end if if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during post' , ierror stop \"pf_parallel:pf_post\" endif if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'is leaving pf_post, state%pstatus=' , pf % state % pstatus , 'with tag =' , tag end subroutine pf_post !>  Subroutine to send this processor's convergence status to the next processor subroutine pf_send_status ( pf , tag , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: istatus integer :: ierror , dest if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction if ( pf % rank == 0 . and . dir == 2 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 1 ) return ierror = 0 istatus = pf % state % status if ( dir == 1 ) then dest = pf % rank + 1 elseif ( dir == 2 ) then dest = pf % rank - 1 else print * , pf % rank , 'warning: bad dir during send_status' , dir stop \"pf_parallel:pf_send_status\" end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begins send_status with status' , istatus , 'with tag =' , tag call pf % comm % send_status ( pf , tag , istatus , ierror , dest ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ends send_status' if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send_status' , ierror stop \"pf_parallel:pf_send_status\" endif end subroutine pf_send_status !>  Subroutine to receive the convergence status from the previous processor subroutine pf_recv_status ( pf , tag , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: ierror , istatus , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction !  Return if this is the first processor if ( pf % rank == 0 . and . dir == 1 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 2 ) return if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin recv_status with pstatus=' , pf % state % pstatus , ' tag=' , tag ierror = 0 if ( dir == 1 ) then source = pf % rank - 1 elseif ( dir == 2 ) then source = pf % rank + 1 else print * , pf % rank , 'warning: bad dir in recv_status' , dir stop \"pf_parallel_oc:pf_recv_status\" end if if ( pf % debug ) print * , pf % rank , 'is receiving status with tag ' , tag call pf % comm % recv_status ( pf , tag , istatus , ierror , source ) if ( ierror . eq . 0 ) then pf % state % pstatus = istatus else print * , pf % rank , 'warning: error during recv_status' , ierror stop \"pf_parallel_oc:pf_recv_status\" endif if ( pf % debug ) print * , pf % rank , 'status recvd = ' , istatus if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end recv_statuswith pstatus=' , pf % state % pstatus , 'tag=' , tag end subroutine pf_recv_status !>  Subroutine to send the solution to the next processor subroutine pf_send ( pf , level , tag , blocking , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , optional , intent ( in ) :: direction integer :: dir , ierror , dest if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default: send forward if ( present ( direction )) dir = direction if ( pf % rank == 0 . and . dir == 2 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 1 ) return ierror = 0 ! need to wait here if ( blocking . eqv . . false .) & call pf_mpi_wait ( pf , level % index , ierror ) if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send (wait)' , ierror stop \"pf_parallel:pf_send\" end if if ( dir == 2 ) then call level % q0 % pack ( level % send , 2 ) dest = pf % rank - 1 else dest = pf % rank + 1 if ( present ( direction )) then !  This is for the imk sweeper where the presence of a flag matters call level % qend % pack ( level % send , 1 ) else call level % qend % pack ( level % send ) end if end if !     ierror = 0 call start_timer ( pf , TSEND + level % index - 1 ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin send, tag=' , tag , blocking , ' pf%state%status =' , pf % state % status !     if (pf%debug) print*,  'DEBUG --',pf%rank, size(level%send), 'send buffer=',level%send call pf % comm % send ( pf , level , tag , blocking , ierror , dest ) if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send' , ierror stop \"pf_parallel:pf_send\" endif if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end send, tag=' , tag , blocking call end_timer ( pf , TSEND + level % index - 1 ) end subroutine pf_send !>  Subroutine to recieve the solution from the previous processor subroutine pf_recv ( pf , level , tag , blocking , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf type ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , optional , intent ( in ) :: direction integer :: dir , ierror , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default: send forward if ( present ( direction )) dir = direction ierror = 0 call start_timer ( pf , TRECEIVE + level % index - 1 ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin recv, tag=' , tag , blocking , \"pf%state%pstatus=\" , pf % state % pstatus if ( pf % rank /= 0 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 1 ) then source = pf % rank - 1 call pf % comm % recv ( pf , level , tag , blocking , ierror , source ) !        if (pf%debug) print*,  'DEBUG --',pf%rank, size(level%recv), 'recv buffer=',level%recv if ( ierror . eq . 0 ) then if ( present ( direction )) then call level % q0 % unpack ( level % recv , 1 ) else call level % q0 % unpack ( level % recv ) end if end if elseif ( pf % rank /= pf % comm % nproc - 1 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 2 ) then source = pf % rank + 1 call pf % comm % recv ( pf , level , tag , blocking , ierror , source ) !        if (pf%debug) print*,  'DEBUG --',pf%rank, size(level%recv), 'recv buffer=',level%recv if ( ierror . eq . 0 ) then if ( present ( direction )) then call level % qend % unpack ( level % recv , 2 ) else call level % qend % unpack ( level % recv ) end if end if end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end recv, tag=' , tag , blocking if ( ierror . ne . 0 ) then print * , pf % rank , 'warning: mpi error during receive' , ierror stop \"pf_parallel:pf_recv\" end if call end_timer ( pf , TRECEIVE + level % index - 1 ) end subroutine pf_recv !>  Subroutine to broadcast the initial condition to all processors subroutine pf_broadcast ( pf , y , nvar , root ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: nvar , root real ( pfdp ) , intent ( in ) :: y ( nvar ) integer :: ierror if ( pf % comm % nproc . eq . 1 ) return call start_timer ( pf , TBROADCAST ) if ( pf % debug ) print * , 'beginning broadcast' call pf % comm % broadcast ( pf , y , nvar , root , ierror ) if ( ierror /= 0 ) then print * , pf % rank , 'warning:  error during broadcast' , ierror stop \"pf_parallel:pf_broadcast\" endif call end_timer ( pf , TBROADCAST ) if ( pf % debug ) print * , 'ending broadcast' end subroutine pf_broadcast !> Save current solution and function value so that future corrections can be computed subroutine save ( pf , lev , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: lev !!  Level to save on integer , optional , intent ( in ) :: flags !!  which component to save (state/adjoint) integer :: m , p !  Save the data so we can interpolate correction later if ( lev % index < pf % state % finest_level ) then do m = 1 , lev % nnodes call lev % pQ ( m )% copy ( lev % Q ( m ), flags ) if ( lev % Finterp ) then do p = 1 , size ( lev % F ( 1 ,:)) call lev % pF ( m , p )% copy ( lev % F ( m , p ), flags ) end do end if end do end if end subroutine save end module pf_mod_comm","tags":"","loc":"sourcefile/pf_comm.f90.html","title":"pf_comm.f90 – LibPFASST"},{"text":"Interpolation operators Contents Modules pf_mod_interpolate Source Code pf_interpolate.f90 Source Code !! Interpolation operators ! ! This file is part of LIBPFASST. ! !> Module to do interpolation between pfasst levels module pf_mod_interpolate use pf_mod_dtype use pf_mod_timer use pf_mod_hooks use pf_mod_utils implicit none contains !> Subroutine to interpolate (in time and space) level_index-1 to level_index !! Interpolation is done by interpolating increments. !! The fine function values are re-evaluated after interpolation. subroutine interpolate_time_space ( pf , t0 , dt , level_index , F_INTERP , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! main pfasst structure real ( pfdp ), intent ( in ) :: t0 !! time at beginning of time interval real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ) :: level_index !! defines which level to interpolate to logical , intent ( in ) :: F_INTERP !!  Flag, if true, then do interp on f not sol integer , optional , intent ( in ) :: flags !  Local variables class ( pf_level_t ), pointer :: c_lev_p !  Pointer to coarse level class ( pf_level_t ), pointer :: f_lev_p !  Pointer to fine level integer :: m , p , step real ( pfdp ), allocatable :: c_times (:) ! coarse level node times real ( pfdp ), allocatable :: f_times (:) ! fine level node times f_lev_p => pf % levels ( level_index ) ! fine level c_lev_p => pf % levels ( level_index - 1 ) ! coarse level call call_hooks ( pf , level_index , PF_PRE_INTERP_ALL ) call start_timer ( pf , TINTERPOLATE + level_index - 1 ) step = pf % state % step + 1 !> create workspaces if ( f_lev_p % interp_workspace_allocated . eqv . . false .) then call c_lev_p % ulevel % factory % create_array ( f_lev_p % c_delta , c_lev_p % nnodes , c_lev_p % index , c_lev_p % shape ) call f_lev_p % ulevel % factory % create_array ( f_lev_p % cf_delta , c_lev_p % nnodes , f_lev_p % index , f_lev_p % shape ) f_lev_p % interp_workspace_allocated = . true . end if !> set time at coarse and fine nodes allocate ( c_times ( c_lev_p % nnodes )) allocate ( f_times ( f_lev_p % nnodes )) c_times = t0 + dt * c_lev_p % nodes f_times = t0 + dt * f_lev_p % nodes do m = 1 , c_lev_p % nnodes call f_lev_p % c_delta ( m )% setval ( 0.0_pfdp , flags ) call f_lev_p % cf_delta ( m )% setval ( 0.0_pfdp , flags ) end do !>  interpolate coarse level correction in space only do m = 1 , c_lev_p % nnodes call f_lev_p % c_delta ( m )% copy ( c_lev_p % Q ( m ), flags ) call f_lev_p % c_delta ( m )% axpy ( - 1.0_pfdp , c_lev_p % pQ ( m ), flags ) call f_lev_p % ulevel % interpolate ( f_lev_p , c_lev_p , f_lev_p % cf_delta ( m ), f_lev_p % c_delta ( m ), c_times ( m ), flags ) end do !> interpolate corrections in time call pf_apply_mat ( f_lev_p % Q , 1.0_pfdp , f_lev_p % tmat , f_lev_p % cf_delta , . false ., flags ) !> either interpolate function values or recompute them if ( F_INTERP ) then !  Interpolating F do p = 1 , size ( c_lev_p % F ( 1 ,:)) do m = 1 , c_lev_p % nnodes call f_lev_p % c_delta ( m )% setval ( 0.0_pfdp , flags ) call f_lev_p % cf_delta ( m )% setval ( 0.0_pfdp , flags ) end do ! interpolate coarse corrections  in space do m = 1 , c_lev_p % nnodes call f_lev_p % c_delta ( m )% copy ( c_lev_p % F ( m , p ), flags ) call f_lev_p % c_delta ( m )% axpy ( - 1.0_pfdp , c_lev_p % pF ( m , p ), flags ) call f_lev_p % ulevel % interpolate ( f_lev_p , c_lev_p , f_lev_p % cf_delta ( m ), f_lev_p % c_delta ( m ), c_times ( m ), flags ) end do ! interpolate corrections  in time call pf_apply_mat ( f_lev_p % F (:, p ), 1.0_pfdp , f_lev_p % tmat , f_lev_p % cf_delta , . false ., flags ) end do !  Loop on npieces else ! recompute function values call f_lev_p % ulevel % sweeper % evaluate_all ( pf , level_index , f_times , flags = flags , step = step ) end if !  Feval !> destroy local data structures deallocate ( c_times , f_times ) call end_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call call_hooks ( pf , f_lev_p % index , PF_POST_INTERP_ALL ) end subroutine interpolate_time_space !>  Subroutine to update the fine initial condition from coarse increment by spatial interpolation subroutine interpolate_q0 ( pf , f_lev_p , c_lev_p , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: f_lev_p !!  fine level class ( pf_level_t ), intent ( inout ) :: c_lev_p !!  coarse level integer , optional , intent ( in ) :: flags !!  optional: specify component on which to operate !   here flags more or less is logical, if it is present we operate on component 1 !   of the ndarray-type call call_hooks ( pf , f_lev_p % index , PF_PRE_INTERP_Q0 ) call start_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call c_lev_p % q0_delta % setval ( 0.0_pfdp , flags ) call f_lev_p % q0_delta % setval ( 0.0_pfdp , flags ) !>  restrict fine initial data to coarse call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0_delta , pf % state % t0 , flags ) !>  get coarse level correction call c_lev_p % q0_delta % axpy ( - 1.0_pfdp , c_lev_p % q0 , flags ) !>  interpolate correction in space call f_lev_p % ulevel % interpolate ( f_lev_p , c_lev_p , f_lev_p % q0_delta , c_lev_p % q0_delta , pf % state % t0 , flags ) !> update fine inital condition call f_lev_p % q0 % axpy ( - 1.0_pfdp , f_lev_p % q0_delta , flags ) call end_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call call_hooks ( pf , f_lev_p % index , PF_POST_INTERP_Q0 ) end subroutine interpolate_q0 !>  Subroutine to update the fine terminal condition from coarse increment by spatial interpolation !>  used for adjoint solver subroutine interpolate_qend ( pf , f_lev_p , c_lev_p ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: f_lev_p !!  fine level class ( pf_level_t ), intent ( inout ) :: c_lev_p !!  coarse level call call_hooks ( pf , f_lev_p % index , PF_PRE_INTERP_Q0 ) call start_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call c_lev_p % q0_delta % setval ( 0.0_pfdp ) call f_lev_p % q0_delta % setval ( 0.0_pfdp ) !>  restrict fine initial data to coarse call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % qend , c_lev_p % q0_delta , pf % state % t0 , flags = 2 ) !>  get coarse level correction call c_lev_p % q0_delta % axpy ( - 1.0_pfdp , c_lev_p % qend , flags = 2 ) !>  interpolate correction in space call f_lev_p % ulevel % interpolate ( f_lev_p , c_lev_p , f_lev_p % q0_delta , c_lev_p % q0_delta , pf % state % t0 , flags = 2 ) !> update fine inital condition call f_lev_p % qend % axpy ( - 1.0_pfdp , f_lev_p % q0_delta , flags = 2 ) call end_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call call_hooks ( pf , f_lev_p % index , PF_POST_INTERP_Q0 ) end subroutine interpolate_qend end module pf_mod_interpolate","tags":"","loc":"sourcefile/pf_interpolate.f90.html","title":"pf_interpolate.f90 – LibPFASST"},{"text":"Exponential integrator sweeper  module Contents Modules pf_mod_exp Source Code pf_exp_sweeper.f90 Source Code !!  Exponential integrator sweeper  module ! ===================================================================================== ! MODULE: pf_mod_exp ! !> @author ! Tommaso Buvoli ! ! Last Modified: Dec 28, 2018 ! !> Exponential integrator module !! !!  This module extends pf_sweeper_t and is used for creating an exponential sweeper !!  that solves equations of the form !!            y' = L y + N(t,y)   !!  When extending this class, you must supply the functions phib, swpPhib, and resPhib !!  that each compute matrix-vector products of the form !!          \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i  !!  in addition to the function f_eval for compluting the nonlinear term N(t,y). !!  The complete description of these three functions is contained below. module pf_mod_exp use pf_mod_dtype use pf_mod_utils implicit none !> Exponential SDC sweeper type, extends abstract pf_sweeper_t type , extends ( pf_sweeper_t ), abstract :: pf_exp_t real ( pfdp ), allocatable :: w (:,:,:) ! weights real ( pfdp ), allocatable :: nodes (:) ! nodes real ( pfdp ), allocatable :: eta (:) ! normalized substeps (on interval [0, 1]) class ( pf_encap_t ), allocatable :: b (:) ! scratch space for computing nonlinear derivatives class ( pf_encap_t ), allocatable :: f_old (:) ! scratch space for storing nonlinear terms class ( pf_encap_t ), allocatable :: newF ! scratch space for storing new function evaluations LOGICAL :: use_phib = . true . ! if TRUE calls phib otherwise calls swpPhib and resPhib (reset in derived sweeper) contains ! specialized procedures for exponential integrator procedure ( pf_f_eval_p ), deferred :: f_eval ! computes nonlinear term in equation procedure ( pf_phib ), deferred :: phib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i procedure ( pf_swpPhib ), deferred :: swpPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n,j} for j = 1, ... q - 1 procedure ( pf_resPhib ), deferred :: resPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n} for j = 1, ... q - 1 procedure , private :: weights procedure , private :: LocalDerivsAtNode ! generic functions procedure :: initialize => exp_initialize procedure :: sweep => exp_sweep procedure :: evaluate => exp_evaluate procedure :: integrate => exp_integrate procedure :: residual => exp_residual procedure :: spreadq0 => exp_spreadq0 procedure :: evaluate_all => exp_evaluate_all procedure :: destroy => exp_destroy ! functions that can be accessed directly by types that inherit pf_exp_t procedure :: exp_destroy procedure :: exp_initialize end type pf_exp_t interface ! DESCRIPTION OF REQUIRED FUNCTIONS ! =================================================================================             REMARK: ADDING ax operation would simplify dealing with h for b(2:end) ! PHIB: Computes the product of vectors and phi functions ! !       y(t) = exp(t h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       for a user specified t, and h. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   t   (input) DOUBLE !       evaluation time for expression ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_phib ( this , t , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_phib ! ================================================================================= ! SWPPHIB: Computes the product of vectors and phi functions ! !           y(t) = \\varphi_0(h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       where the time t is ! !           t_{n,j+1} - t_{n,j}         j = 1, ... q - 1 ! !       and h is a user specified. This procedure is used when computing !       exponential correction sweeps. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   j   (input) Integer !       substep index for determining t: t = t_{n,j+1} - t_{n,j} ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_swpPhib ( this , j , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: j real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_swpPhib ! ================================================================================= ! RESPHIB: Computes the product of vectors and phi functions ! !           y(t) = \\varphi_0(h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       where the time t is ! !           t_{n,j} - t_{n} ! !       and h is a user specified. This procedure is used when computing !       exponential correction sweeps. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   j   (input) Integer !       substep index for determining t: t = t_{n,j+1} - t_{n} ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_resPhib ( this , j , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: j real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_resPhib ! ================================================================================= ! f_eval: computes the equations nonlinear term N(t,y) ! ! Arguments ! !   y     (input) pf_encap_t !         solution y(t) ! !   t     (input) DOUBLE !         time t ! !   level (input) INTEGER !         current level index ! !   f     (output) pf_encap_t !         N(t,y) ! ================================================================================= subroutine pf_f_eval_p ( this , y , t , level , n ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: n end subroutine pf_f_eval_p end interface contains ! ================================================================================= ! INITIALIZE: initializes the following internal parameters !      w        DOUBLE(:,:,:)     contains FD weights for computing local derivatives at t_{n,j} !      nodes    DOUBLE(:)         sdc nodes !      eta      DOUBLE(:)         normalized substeps (t_{n,j+1} - t_{n,j})/h !      npieces  INTEGER           number of RHS peices (always will be one) !      newF     pf_encap_t        stores new function evaluations !      b        pf_encap_t(:)     stores vectors b for computing phi products ! ================================================================================= subroutine exp_initialize ( this , pf , level_index ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index ! local variables integer :: i , nnodes real ( pfdp ), allocatable :: q (:) type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) nnodes = lev % nnodes allocate ( this % eta ( nnodes - 1 )) allocate ( this % nodes ( nnodes )) allocate ( q ( nnodes )) ! set nodes and substeps this % nodes = lev % sdcmats % qnodes this % eta = this % nodes ( 2 : nnodes ) - this % nodes ( 1 : nnodes - 1 ) ! substeps ! compute weights allocate ( this % w ( nnodes - 1 , nnodes , nnodes )) do i = 1 , nnodes - 1 q = this % nodes - this % nodes ( i ); call weights ( this , real ( 0.0 , pfdp ), q , nnodes - 1 , this % W ( i ,:,:)) end do ! set number of rhs components this % npieces = 1 ! initialize temporary storage objects call lev % ulevel % factory % create_single ( this % newF , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % b , nnodes + 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % f_old , nnodes , lev % index , lev % shape ) end subroutine exp_initialize ! SWEEP: exponential sweep subroutine =============================================== subroutine exp_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags ! local variables type ( pf_level_t ), pointer :: lev integer :: m , nnodes , j , k real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call start_timer ( pf , TLEVEL + lev % index - 1 ) ! error sweeps do k = 1 , nsweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! NOTE: ensure that lev%F has been properly initialized here do j = 1 , nnodes call this % f_old ( j )% copy ( lev % F ( j , 1 )) ! Save old f end do if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) ! compute F_j&#94;{[k+1]} end if t = t0 do j = 1 , nnodes - 1 t = t0 + dt * this % eta ( j ) ! form b vectors call LocalDerivsAtNode ( this , j , nnodes , this % f_old , this % b ) ! phi expansion for exponential picard integral call this % b ( 1 )% copy ( lev % Q ( j )) ! add term \\phi_0(tL) y_n call this % b ( 2 )% axpy ( real ( - 1.0 , pfdp ), this % f_old ( j )) ! add -\\phi_1(tL) F_j&#94;{[k]} call this % f_eval ( lev % Q ( j ), t , lev % index , lev % F ( j , 1 )) ! compute F_j&#94;{[k+1]} call this % b ( 2 )% axpy ( real ( 1.0 , pfdp ), lev % F ( j , 1 )) ! add \\phi_1(tL) F_j&#94;{[k+1]} ! compute phi products if ( this % use_phib ) then call this % phib ( this % eta ( j ), dt , this % b , lev % Q ( j + 1 )) else call this % swpPhib ( j , dt , this % b , lev % Q ( j + 1 )) end if !  Now we have to add in the tauQ if ( level_index < pf % state % finest_level ) then call lev % Q ( j + 1 )% axpy ( 1.0_pfdp , lev % tauQ ( j )) if ( j > 1 ) then ! The tau is not node to node, so subtract out call lev % Q ( j + 1 )% axpy ( - 1.0_pfdp , lev % tauQ ( j - 1 )) end if end if end do !  Substepping over nodes call this % f_eval ( lev % Q ( nnodes ), t0 + dt , lev % index , lev % F ( nnodes , 1 )) ! eval last nonlinear term call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  Sweeps end subroutine exp_sweep ! ================================================================================= ! INTEGRATE: computes the integrals for the exponential Picard residual ! !         r_j = A_j - B_j ! !     where ! !         A_j = \\left[ \\exp(t h L) y(t_n) - \\int_{t_n}&#94;{t_{n,j}} \\exp(L(t - t_n)) P(t) dt \\right] !         B_j = y(t_{n,j}) ! !     NOTE: This procedure computes the expression \\hat{r}_j = A_j - y(t_n). The !     term y(t_n) is subtracted from result since the generic calling function !     compute the residual as ! !        r_j = y(t_n) + exp_integrate() - y(t_{n,j}) ! !     thus incorrectly adding the term y_n ! ================================================================================= subroutine exp_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintsdc , flags ) class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintsdc (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags ! local variables integer :: i , nnodes type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer nnodes = lev % nnodes do i = 1 , nnodes call this % f_old ( i )% copy ( fSDC ( i , 1 )) ! Save old f end do do i = 1 , nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} call LocalDerivsAtNode ( this , i , nnodes , this % f_old , this % b ) ! compute derivatives call this % b ( 1 )% copy ( qSDC ( i )) call fintsdc ( i )% setval ( 0.0_pfdp ) if ( this % use_phib ) then call this % phib ( this % eta ( i ), dt , this % b , fintsdc ( i )) else call this % swpPhib ( i , dt , this % b , fintsdc ( i )) end if call fintsdc ( i )% axpy ( - 1.0_pfdp , qSDC ( i )) if ( i > 1 ) then call fintsdc ( i )% axpy ( 1.0_pfdp , fintsdc ( i - 1 )) end if end do end subroutine exp_integrate ! RESIDUAL: compute  residual (generic) ==================================== subroutine exp_residual ( this , pf , level_index , dt , flags ) class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , intent ( in ), optional :: flags integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( level_index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if !> subtract out the solution value do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) end do end subroutine exp_residual ! SPREADQ: spread solution (generic) ====================================== subroutine exp_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine exp_spreadq0 ! EVALUATE: evaluate the nonlinear term at node m ======================== subroutine exp_evaluate ( this , pf , level_index , t , m , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine exp_evaluate ! EVALUATE_ALL: evaluate the nonlinear term at all nodes ================= subroutine exp_evaluate_all ( this , pf , level_index , t , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine exp_evaluate_all ! DEALLOCATE: deallocate sweeper variables subroutine exp_destroy ( this , pf , level_index ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % w ) deallocate ( this % eta ) deallocate ( this % newF ) call lev % ulevel % factory % destroy_array ( this % b ) call lev % ulevel % factory % destroy_array ( this % f_old ) end subroutine exp_destroy ! ======================================================================= ! LocalDerivsAtNode: approximate the local derivative vector !           at the substep t_{n,i} for the nonlinear function N(y(t)) !           using the terms N(y{n,i}). Local coordinates coorespond to !           s = h t. ! Arguments ! !   i       (input) INTEGER !           index of the substep for which we want to approximate derivatives ! !   nnodes  (input) INTEGER !           number of nodes ! !   N_eval  (input) pf_encap_t(:) !           Nonlinear function evaluations; N_eval(i) contains N(y_{n,i}) ! !   N_deriv (output) pf_encap_t(:) !           N_deriv(i) approximates \\frac{d&#94;{i-1}}{dt&#94;{i-1}} N(y(t)) ! ======================================================================= subroutine LocalDerivsAtNode ( this , i , nnodes , N_eval , N_deriv ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: i integer , intent ( in ) :: nnodes class ( pf_encap_t ), intent ( in ) :: N_eval (:) class ( pf_encap_t ), intent ( inout ) :: N_deriv (:) ! local variables integer :: j , k ! form nonlinear derivative vectors b do j = 1 , nnodes ! loop over derivatives j = 1 ... n call N_deriv ( j + 1 )% setval ( real ( 0.0 , pfdp )) do k = 1 , nnodes ! look over nodes k = 1 ... n call N_deriv ( j + 1 )% axpy ( this % w ( i , k , j ), N_eval ( k )) end do end do end subroutine LocalDerivsAtNode ! ======================================================================= ! WEIGHTS   Compute coefficients for finite difference approximation for !           the derivatives 1 to m at point z assuming data is known at !           points in array x. Based on the program \"weights\" in !           B. Fornberg, \"Calculation of weights in finite difference !           formulas\", SIAM Review 40 (1998), pp. 685-691. ! Arguments ! !   z   (input) DOUBLE !       location where approximations are to be accurate ! !   x   (input) DOUBLE Array !       array containing interpolation points ! !   m   (input) INTEGER !       highest derivative for which weights are sought ! !   W   (output) DOUBLE array, dimension(size(x),m+1) !       matrix that gives weights at grid locations x for !       derivative of order j<=m are found in c(:,j) ! ======================================================================= subroutine weights ( this , z , x , m , W ) ! Arguments class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z real ( pfdp ), intent ( inout ) :: x (:) integer , intent ( in ) :: m real ( pfdp ), intent ( out ) :: W ( m + 1 , m + 1 ) ! Variable Declarations real ( pfdp ) :: c1 , c2 , c3 , c4 , c5 integer :: ii , i , j , k , n , mn !        do ii = 1, m !        x = this%nodes - this%nodes(ii); c1 = 1.0_pfdp c4 = x ( 1 ) - z W = 0.0_pfdp W ( 1 , 1 ) = 1.0_pfdp n = size ( x ) do i = 2 , n mn = min ( i , m + 1 ) c2 = 1.0_pfdp c5 = c4 c4 = x ( i ) - z do j = 1 , i - 1 c3 = x ( i ) - x ( j ) c2 = c2 * c3 ; if ( j == i - 1 ) then do k = mn , 2 , - 1 W ( i , k ) = c1 * ( real ( k - 1 , pfdp ) * W ( i - 1 , k - 1 ) - c5 * W ( i - 1 , k )) / c2 ; enddo W ( i , 1 ) = - c1 * c5 * W ( i - 1 , 1 ) / c2 ; endif do k = mn , 2 , - 1 W ( j , k ) = ( c4 * W ( j , k ) - real ( k - 1 , pfdp ) * W ( j , k - 1 )) / c3 ; enddo W ( j , 1 ) = c4 * W ( j , 1 ) / c3 ; enddo c1 = c2 ; enddo !        end do end subroutine weights end module pf_mod_exp","tags":"","loc":"sourcefile/pf_exp_sweeper.f90.html","title":"pf_exp_sweeper.f90 – LibPFASST"},{"text":"Module for calling of user defined routines from various places in the pfasst algorithm Contents Modules pf_mod_hooks Source Code pf_hooks.f90 Source Code !! Module for calling of user defined routines from various places in the pfasst algorithm ! ! This file is part of LIBPFASST. ! !>  Module for the calling of user defined routines from various places in the pfasst algorithm module pf_mod_hooks use pf_mod_dtype implicit none !>  Define hook indices integer , parameter :: & PF_PRE_PREDICTOR = 1 , & PF_POST_PREDICTOR = 2 , & PF_PRE_ITERATION = 3 , & PF_POST_ITERATION = 4 , & PF_PRE_SWEEP = 5 , & PF_POST_SWEEP = 6 , & PF_PRE_STEP = 7 , & PF_POST_STEP = 8 , & PF_PRE_INTERP_ALL = 9 , & PF_POST_INTERP_ALL = 10 , & PF_PRE_INTERP_Q0 = 11 , & PF_POST_INTERP_Q0 = 12 , & PF_PRE_RESTRICT_ALL = 13 , & PF_POST_RESTRICT_ALL = 14 , & PF_PRE_CONVERGENCE = 15 , & PF_POST_CONVERGENCE = 16 , & PF_MAX_HOOK = 16 integer , parameter :: & PF_HOOK_LOG_ONE = 1 , & PF_HOOK_LOG_ALL = 7 , & PF_HOOK_LOG_LAST = PF_MAX_HOOK !>  Define hook names character ( len = 20 ), parameter :: hook_names ( PF_HOOK_LOG_LAST ) = ( / & 'pre-predictor      ' , & 'post-predictor     ' , & 'pre-iteration      ' , & 'post-iteration     ' , & 'pre-sweep          ' , & 'post-sweep         ' , & 'pre-step           ' , & 'post-step          ' , & 'pre-interp-all     ' , & 'post-interp-all    ' , & 'pre-interp-q0      ' , & 'post-interp-q0     ' , & 'pre-restrict-all   ' , & 'post-restrict-all  ' , & 'pre-convergence    ' , & 'post-convergence   ' / ) contains !> Subroutine to add a procedure to the hook on the given level subroutine pf_add_hook ( pf , level_ind , hook , proc ) type ( pf_pfasst_t ), intent ( inout ) :: pf !! main pfasst structure integer , intent ( in ) :: level_ind !! which pfasst level to add hook integer , intent ( in ) :: hook !! which hook to add procedure ( pf_hook_p ) :: proc !! precudre to call from hook integer :: l ! if ( level_ind == - 1 ) then ! Do to all levels do l = 1 , pf % nlevels pf % nhooks ( l , hook ) = pf % nhooks ( l , hook ) + 1 pf % hooks ( l , hook , pf % nhooks ( l , hook ))% proc => proc end do else ! Do to just level level_ind pf % nhooks ( level_ind , hook ) = pf % nhooks ( level_ind , hook ) + 1 pf % hooks ( level_ind , hook , pf % nhooks ( level_ind , hook ))% proc => proc end if end subroutine pf_add_hook !> Subroutine to call hooks associated with the hook and level subroutine call_hooks ( pf , level_ind , hook ) use pf_mod_timer type ( pf_pfasst_t ), intent ( inout ), target :: pf !! main pfasst structure integer , intent ( in ) :: level_ind !! which pfasst level to call hook integer , intent ( in ) :: hook !! which hook to call integer :: i !!  hook loop index integer :: l !!  level loop index call start_timer ( pf , THOOKS ) pf % state % hook = hook if ( level_ind == - 1 ) then ! Do to all levels do l = 1 , pf % nlevels do i = 1 , pf % nhooks ( l , hook ) call pf % hooks ( l , hook , i )% proc ( pf , l ) end do end do else ! Do to just level level_ind do i = 1 , pf % nhooks ( level_ind , hook ) call pf % hooks ( level_ind , hook , i )% proc ( pf , level_ind ) end do end if call end_timer ( pf , THOOKS ) end subroutine call_hooks !>  Subroutine defining log hook subroutine pf_logger_hook ( pf , level_index ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index print '(\"PF:: trank: \",i4,\", step: \",i6,\", iter: \",i3,\", level: \",i2,\" location: \",a)' , & pf % rank , pf % state % step , pf % state % iter , level_index , hook_names ( pf % state % hook ) end subroutine pf_logger_hook !>  Subroutine to add log hook subroutine pf_logger_attach ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: l , h do h = PF_HOOK_LOG_ONE , PF_HOOK_LOG_ALL - 1 call pf_add_hook ( pf , 1 , h , pf_logger_hook ) end do do l = 1 , pf % nlevels do h = PF_HOOK_LOG_ALL , PF_HOOK_LOG_LAST call pf_add_hook ( pf , l , h , pf_logger_hook ) end do end do end subroutine pf_logger_attach end module pf_mod_hooks","tags":"","loc":"sourcefile/pf_hooks.f90.html","title":"pf_hooks.f90 – LibPFASST"},{"text":"Asynchronous MISDC sweeper Contents Modules pf_mod_amisdcQ Source Code pf_amisdc_sweeperQ.f90 Source Code !!  Asynchronous MISDC sweeper ! ! This file is part of LIBPFASST. ! !> Asynchronous multi-implicit sweeper module pf_mod_amisdcQ use pf_mod_amisdc implicit none !>  Asynchronous multi-implicit sweeper type type , extends ( pf_amisdc_t ), abstract :: pf_amisdcQ_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) logical :: use_LUq_ = . true . contains procedure :: sweep => amisdcQ_sweep procedure :: initialize => amisdcQ_initialize procedure :: integrate => amisdcQ_integrate procedure :: destroy => amisdcQ_destroy procedure :: sweep_coupled_implicit_terms procedure :: sweep_decoupled_implicit_terms procedure :: amisdcQ_destroy procedure :: amisdcQ_initialize end type pf_amisdcQ_t contains ! Perform an SDC sweep on level lev and set qend appropriately. ! In the asynchronous updates, the two implicit parts are coupled subroutine sweep_coupled_implicit_terms ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhsA , rhsB , QA , QB class ( pf_encap_t ), allocatable :: S2 (:), S3 (:) call start_timer ( pf , TLEVEL + lev % index - 1 ) call lev % ulevel % factory % create_array ( S2 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( S3 , lev % nnodes - 1 , lev % index , lev % shape ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) call S2 ( m )% setval ( 0.0d0 ) call S3 ( m )% setval ( 0.0d0 ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( 1.0_pfdp * dt * lev % qmat ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( 1.0_pfdp * dt * lev % qmat ( m , n ), lev % F ( n , 3 )) call S2 ( m )% axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 2 )) call S3 ( m )% axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tauQ )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f1eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) call this % f2eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 )) call this % f3eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 )) call lev % ulevel % factory % create_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QB , lev % index , lev % shape ) call QA % setval ( 0.0_pfdp ) call QB % setval ( 0.0_pfdp ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhsA % copy ( lev % Q ( 1 )) ! First compute the explicit part of the right-hand side do n = 1 , m call rhsA % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) end do call rhsA % axpy ( 1.0_pfdp , lev % S ( m )) ! Save the right-hand side with only the explicit contribution call rhsB % copy ( rhsA ) ! Add the first implicit part to the right-hand side and solve for the first asynchronous update do n = 1 , m call rhsA % axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do call rhsA % axpy ( - 1.0_pfdp , S2 ( m )) call this % f2comp ( QA , t , 2.0_pfdp * dt * this % QtilI ( m , m + 1 ), rhsA , lev % index , lev % F ( m + 1 , 2 )) ! Add the second implicit part to the right-hand side and solve for the second asynchronous update do n = 1 , m call rhsB % axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do call rhsB % axpy ( - 1.0_pfdp , S3 ( m )) call this % f3comp ( QB , t , 2.0_pfdp * dt * this % QtilI ( m , m + 1 ), rhsB , lev % index , lev % F ( m + 1 , 3 )) ! Now we average the two asynchronous updates call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QA ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QB ) ! Evaluate the three right-hand sides with the updated variables call this % f1eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 )) call this % f2eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 )) call this % f3eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 3 )) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) call lev % ulevel % factory % destroy_array ( S2 ) call lev % ulevel % factory % destroy_array ( S3 ) call lev % ulevel % factory % destroy_single ( rhsA ) call lev % ulevel % factory % destroy_single ( rhsB ) call lev % ulevel % factory % destroy_single ( QA ) call lev % ulevel % factory % destroy_single ( QB ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine sweep_coupled_implicit_terms ! Perform an SDC sweep on level lev and set qend appropriately. ! In the asynchronous updates, the two implicit parts are decoupled ! (in progress) subroutine sweep_decoupled_implicit_terms ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev ! integer                        :: m, n ! real(pfdp)                     :: t ! real(pfdp)                     :: dtsdc(1:lev%nnodes-1) ! class(pf_encap_t), allocatable :: rhsA, rhsB, QA, QB ! class(pf_encap_t), allocatable :: S2(:), S3(:) ! call start_timer(pf, TLEVEL+lev%index-1) ! call lev%ulevel%factory%create_array(S2,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%create_array(S3,lev%nnodes-1,lev%index,lev%shape) ! ! compute integrals and add fas correction ! do m = 1, lev%nnodes-1 !    call lev%S(m)%setval(0.0_pfdp) !    call S2(m)%setval(0.0d0) !    call S3(m)%setval(0.0d0) !    do n = 1, lev%nnodes !       call lev%S(m)%axpy(dt*this%QdiffE(m,n),       lev%F(n,1)) !       call S2(m)%axpy( 2.0_pfdp*dt*lev%qmat(m,n),   lev%F(n,2)) !       call S3(m)%axpy( 2.0_pfdp*dt*lev%qmat(m,n),   lev%F(n,3)) !       call S2(m)%axpy(-2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,2)) !       call S3(m)%axpy(-2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,3)) !    end do !    if (allocated(lev%tauQ)) then !       call lev%S(m)%axpy(1.0_pfdp, lev%tauQ(m)) !    end if ! end do ! ! do the time-stepping ! call lev%Q(1)%unpack(lev%q0) ! call this%f1eval(lev%Q(1), t0, lev%index, lev%F(1,1)) ! call this%f2eval(lev%Q(1), t0, lev%index, lev%F(1,2)) ! call this%f3eval(lev%Q(1), t0, lev%index, lev%F(1,3)) ! call lev%ulevel%factory%create_single(rhsA, lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(rhsB, lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(QA,   lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(QB,   lev%index,  lev%shape) ! call QA%setval(0.0_pfdp) ! call QB%setval(0.0_pfdp) ! t = t0 ! dtsdc = dt * (lev%nodes(2:lev%nnodes) - lev%nodes(1:lev%nnodes-1)) ! do m = 1, lev%nnodes-1 !    t = t + dtsdc(m) !    call rhsA%copy(lev%Q(1)) !    ! First compute the explicit part of the right-hand side !    do n = 1, m !       call rhsA%axpy(dt*this%QtilE(m,n), lev%F(n,1)) !    end do !    call rhsA%axpy(1.0_pfdp, lev%S(m)) !    ! Save the right-hand side with only the explicit contribution !    call rhsB%copy(rhsA) !    ! Add the first implicit part to the right-hand side and solve for the first asynchronous update !    do n = 1, m !       call rhsA%axpy(2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,2)) !    end do !    call rhsA%axpy(1.0_pfdp, S2(m)) !    call this%f2comp(QA, t, 2.0_pfdp*dt*this%QtilI(m,m+1), rhsA, lev%index, lev%F(m+1,2)) !    ! Add the second implicit part to the right-hand side and solve for the second asynchronous update !    do n = 1, m !       call rhsB%axpy(2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,3)) !    end do !    call rhsB%axpy(1.0_pfdp, S3(m)) !    call this%f3comp(QB, t, 2.0_pfdp*dt*this%QtilI(m,m+1), rhsB, lev%index, lev%F(m+1,3)) !    ! Now we average the two asynchronous updates !    call lev%Q(m+1)%setval(0.0_pfdp) !    call lev%Q(m+1)%axpy(0.5_pfdp, QA) !    call lev%Q(m+1)%axpy(0.5_pfdp, QB) !    ! Evaluate the three right-hand sides with the updated variables !    call this%f1eval(lev%Q(m+1), t, lev%index, lev%F(m+1,1)) !    call this%f2eval(lev%Q(m+1), t, lev%index, lev%F(m+1,2)) !    call this%f3eval(lev%Q(m+1), t, lev%index, lev%F(m+1,3)) ! end do ! call lev%qend%copy(lev%Q(lev%nnodes)) ! call lev%ulevel%factory%destroy_array(S2,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%destroy_array(S3,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%destroy_single(rhsA, lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(rhsB, lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(QA,   lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(QB,   lev%index,   lev%shape) ! call end_timer(pf, TLEVEL+lev%index-1) end subroutine sweep_decoupled_implicit_terms ! Perform an SDC sweep on level lev and set qend appropriately. subroutine amisdcQ_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev call sweep_coupled_implicit_terms ( this , pf , lev , t0 , dt ) end subroutine amisdcQ_sweep ! Initialize matrices subroutine amisdcQ_initialize ( this , lev ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , n , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) !  S-BE this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq_ ) then ! Get the LU call myLUq ( lev % qmat , lev % LUmat , lev % nnodes , 1 ) this % QtilI = lev % LUmat else do m = 1 , nnodes - 1 do n = 1 , m this % QtilI ( m , n + 1 ) = dsdc ( n ) end do end do end if ! Explicit matrix do m = 1 , nnodes - 1 do n = 1 , m this % QtilE ( m , n ) = dsdc ( n ) end do end do this % QdiffE = lev % qmat - this % QtilE this % QdiffI = lev % qmat - this % QtilI end subroutine amisdcQ_initialize ! Destroy the matrices subroutine amisdcQ_destroy ( this , lev ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) end subroutine amisdcQ_destroy ! Compute SDC integral subroutine amisdcQ_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % qmat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine amisdcQ_integrate end module pf_mod_amisdcQ","tags":"","loc":"sourcefile/pf_amisdc_sweeperq.f90.html","title":"pf_amisdc_sweeperQ.f90 – LibPFASST"},{"text":"Quadrature matrices and accompanying routines Contents Modules pf_mod_quadrature Source Code pf_quadrature.f90 Source Code !! Quadrature matrices and accompanying routines ! ! This file is part of LIBPFASST. ! ! !> Module to create quadrature matrices and accompanying routines module pf_mod_quadrature use pf_mod_dtype use pf_mod_utils implicit none integer , parameter :: qp = c_long_double integer , parameter :: dp = c_double real ( qp ), parameter :: eps = 1.0e-23_qp private :: qsort_partition interface poly_eval module procedure poly_eval module procedure poly_eval_complex end interface contains !>  Initialize the sdcmats type with the correct nodes and quadrature matrices subroutine pf_init_sdcmats ( pf , SDCmats , nnodes , nflags ) use pf_mod_utils type ( pf_pfasst_t ), intent ( in ) :: pf !!  PFASST structure type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats integer , intent ( in ) :: nnodes ! Number of ndoes integer , intent ( inout ) :: nflags ( nnodes ) integer :: ierr integer :: nnodes0 !  Copy some info SDCmats % nnodes = nnodes SDCmats % qtype = pf % qtype SDCmats % use_proper_nodes = pf % use_proper_nodes SDCmats % use_composite_nodes = pf % use_composite_nodes SDCmats % use_no_left_q = pf % use_no_left_q !> Decide what the base integration type is if ( SDCmats % use_composite_nodes ) then nnodes0 = pf % levels ( 1 )% nnodes !  Will use the coarsest quadrature rule in composite else nnodes0 = pf % levels ( pf % nlevels )% nnodes ! Will use the end if !  Allocate nodes and collocation matrices allocate ( SDCmats % qnodes ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , & __ LINE__ , \"allocate error qnodes\" ) allocate ( SDCmats % Qmat ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error Qmat\" ) allocate ( SDCmats % Smat ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error Smat\" ) !  Make the nodes and collocation matrices call pf_quadrature ( SDCmats % qtype , nnodes , nnodes0 , & SDCmats % qnodes , nflags , SDCmats % Smat , SDCmats % Qmat , & SDCmats % use_proper_nodes , SDCmats % use_composite_nodes , SDCmats % use_no_left_q ) !  Make the substepping matrices call pf_make_matrices ( SDCmats ) end subroutine pf_init_sdcmats !>  Destroy the sdcmats structure subroutine pf_destroy_sdcmats ( SDCmats ) type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats deallocate ( SDCmats % Qmat ) deallocate ( SDCmats % QmatFE ) deallocate ( SDCmats % QmatBE ) deallocate ( SDCmats % QmatTrap ) deallocate ( SDCmats % QmatVer ) deallocate ( SDCmats % QmatLU ) deallocate ( SDCmats % Smat ) deallocate ( SDCmats % qnodes ) end subroutine pf_destroy_sdcmats !>  Routine to compute the LU decomposition of spectral integration matrix subroutine myLUq ( Q , QLU , Nnodes , fillq ) integer , intent ( in ) :: Nnodes real ( pfdp ), intent ( in ) :: Q ( Nnodes - 1 , Nnodes ) real ( pfdp ), intent ( inout ) :: QLU ( Nnodes - 1 , Nnodes ) integer , intent ( in ) :: fillq ! Return the QLU=U&#94;T where U is the LU decomposition of Q without pivoting ! if fillq is positive, then the first row of QLU is filled to make ! the matrix consistent integer :: i , j , N real ( pfdp ) :: c real ( pfdp ) :: U ( Nnodes - 1 , Nnodes - 1 ) real ( pfdp ) :: L ( Nnodes - 1 , Nnodes - 1 ) real ( pfdp ) :: LUerror L = 0.0_pfdp U = 0.0_pfdp N = Nnodes - 1 U = transpose ( Q ( 1 : Nnodes - 1 , 2 : Nnodes )) do i = 1 , N if ( abs ( U ( i , i )) . gt . 1.0e-15_pfdp ) then do j = i + 1 , N c = U ( j , i ) / U ( i , i ) U ( j , i : N ) = U ( j , i : N ) - c * U ( i , i : N ) L ( j , i ) = c end do end if L ( i , i ) = 1.0_pfdp end do !  Check LUerror = maxval ( abs ( matmul ( L , U ) - transpose ( Q ( 1 : Nnodes - 1 , 2 : Nnodes )))) if ( LUerror . gt . 1e-14 ) then call pf_stop ( __ FILE__ , __ LINE__ , 'error in LU too high' ) end if QLU = 0.0_pfdp QLU ( 1 : Nnodes - 1 , 2 : Nnodes ) = transpose ( U ) !  Now scale the columns of U to match the sum of A if ( fillq . eq . 1 ) then do j = 1 , Nnodes - 1 QLU ( j , 1 ) = sum ( Q ( j , 1 : Nnodes )) - sum ( U ( j , 1 : Nnodes - 1 )) end do end if end subroutine myLUq !>  Subroutine to create quadrature nodes and matrices subroutine pf_quadrature ( qtype , nnodes , nnodes0 , nodes , nflags , Smat , Qmat , proper , composite , no_left ) integer , intent ( in ) :: qtype ! Type of nodes integer , intent ( in ) :: nnodes ! Number of nodes on this level integer , intent ( in ) :: nnodes0 ! Number of node on base level (either finest or coarsest) real ( pfdp ), intent ( out ) :: nodes ( nnodes ) !  The nodes real ( pfdp ), intent ( out ) :: Smat ( nnodes - 1 , nnodes ) !  node to node integration matrix real ( pfdp ), intent ( out ) :: Qmat ( nnodes - 1 , nnodes ) !  O to node collocation matrix integer , intent ( out ) :: nflags ( nnodes ) !  Flags logical , intent ( in ) :: composite !  Use composite nodes logical , intent ( in ) :: proper !  Use proper nodes instead of node restriction logical , intent ( in ) :: no_left !  Don't use left hand end point real ( pfdp ) :: dt !  The size of the composite base rule real ( pfqp ) :: qnodes0 ( nnodes0 ) ! quad precision base nodes real ( pfqp ) :: qnodes ( nnodes ) ! quad precision nodes real ( pfdp ) :: Qmat0 ( nnodes0 - 1 , nnodes0 ), Smat0 ( nnodes0 - 1 , nnodes0 ), qcomp0 ( nnodes0 - 1 , nnodes0 ) integer :: flags0 ( nnodes0 ) integer :: i , j , ri , rj , refine , m Qmat = 0 Smat = 0 flags0 = 0 nflags = 0 if ( composite ) then ! nodes are given by repeating the coarsest set of nodes.  note ! that in this case nnodes0 corresponds to the coarsest number ! of nodes. refine = ( nnodes - 1 ) / ( nnodes0 - 1 ) call sdc_qnodes ( qnodes0 , flags0 , qtype , nnodes0 ) !  Make coarsest level nodes call sdc_qmats ( Qmat0 , Smat0 , qnodes0 , qnodes0 , flags0 , nnodes0 , nnodes0 ) !  Make coarsest level Qmat !  This block matrix will be used to fill in composite Qmat do m = 1 , nnodes0 - 1 qcomp0 ( m ,:) = Qmat0 ( nnodes0 - 1 ,:) !  load each row with the integral over the whole composite step end do !  Build big block matrix dt = 1.0_pfdp / refine do i = 1 , refine ri = ( i - 1 ) * ( nnodes0 - 1 ) + 1 !  beginning of ith composite rule qnodes ( ri : ri + nnodes0 - 1 ) = dt * (( i - 1 ) + qnodes0 ) !  Assigns endpoints of composites twice, but no biggie Smat ( ri : ri + nnodes0 - 2 , ri : ri + nnodes0 - 1 ) = dt * Smat0 ! Make block diagonal Smat Qmat ( ri : ri + nnodes0 - 2 , ri : ri + nnodes0 - 1 ) = dt * Qmat0 ! Make block diagonal Qmat do j = 1 , i - 1 !   column blocks to left of diag rj = ( j - 1 ) * ( nnodes0 - 1 ) + 1 Qmat ( ri : ri + nnodes0 - 2 , rj : rj + nnodes0 - 1 ) = Qmat ( ri : ri + nnodes0 - 2 , rj : rj + nnodes0 - 1 ) + dt * qcomp0 end do end do else if ( proper ) then ! nodes are given by proper quadrature rules call sdc_qnodes ( qnodes , nflags , qtype , nnodes ) call sdc_Qmats ( Qmat , Smat , qnodes , qnodes , nflags , nnodes , nnodes ) else ! nodes are given by refining the finest set of nodes.  note ! that in this case nnodes0 corresponds to the finest number of ! nodes. refine = ( nnodes0 - 1 ) / ( nnodes - 1 ) call sdc_qnodes ( qnodes0 , flags0 , qtype , nnodes0 ) !  Make finest nodes qnodes = qnodes0 ( :: refine ) nflags = flags0 ( :: refine ) if ( no_left ) nflags ( 1 ) = 0 call sdc_Qmats ( Qmat , Smat , qnodes , qnodes , nflags , nnodes , nnodes ) end if nodes = real ( qnodes , pfdp ) if ( all ( nodes == 0.0d0 )) then call pf_stop ( __ FILE__ , __ LINE__ ,& 'ERROR: pf_quadrature: invalid SDC nnodes.' ) end if end subroutine pf_quadrature subroutine pf_make_matrices ( SDCmats ) type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats integer :: nnodes integer :: ierr , m , n nnodes = SDCmats % nnodes allocate ( SDCmats % QmatFE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatFE\" ) allocate ( SDCmats % QmatBE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatBE\" ) allocate ( SDCmats % QmatTrap ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatBE\" ) allocate ( SDCmats % QmatVer ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatBE\" ) allocate ( SDCmats % QmatLU ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatLU\" ) !  Make implicit Euler matrices SDCmats % QmatBE = 0.0_pfdp do m = 1 , nnodes - 1 do n = 1 , m SDCmats % QmatBE ( m , n + 1 ) = SDCmats % qnodes ( n + 1 ) - SDCmats % qnodes ( n ) end do end do ! Make explicit matrix SDCmats % QmatFE = 0.0_pfdp do m = 1 , nnodes - 1 do n = 1 , m SDCmats % QmatFE ( m , n ) = SDCmats % qnodes ( n + 1 ) - SDCmats % qnodes ( n ) end do end do !  Trapezoid matrix SDCmats % QmatTrap = 0.5_pfdp * ( SDCmats % QmatFE + SDCmats % QmatBE ) !  Get the LU call myLUq ( SDCmats % Qmat , SDCmats % QmatLU , nnodes , 0 ) end subroutine pf_make_matrices !>  Function to decide if the restriction of the nodes is pointwise, e.g. coarse nodes are every other fine node logical function not_proper ( flags , node ) integer , intent ( in ) :: flags (:) integer , intent ( in ) :: node not_proper = . not . btest ( flags ( node ), 0 ) end function not_proper !> Subroutine to compute high precision quadrature nodes. subroutine sdc_qnodes ( qnodes , flags , qtype , nnodes ) integer , intent ( in ), value :: nnodes !!  Number of nodes integer , intent ( in ), value :: qtype !!  Type of nodes (see pf_dtype) real ( pfqp ), intent ( out ) :: qnodes ( nnodes ) !!  The computed quadrature nodes integer , intent ( out ) :: flags ( nnodes ) !! integer :: j , degree real ( pfqp ), allocatable :: roots (:) real ( pfqp ), allocatable :: coeffs (:), coeffs2 (:) real ( pfqp ), parameter :: pi = 3.141592653589793115997963468544185161590576171875_pfdp flags = 0 select case ( qtype ) case ( SDC_GAUSS_LEGENDRE ) degree = nnodes - 2 allocate ( roots ( degree )) allocate ( coeffs ( degree + 1 )) call poly_legendre ( coeffs , degree ) call poly_roots ( roots , coeffs , degree ) qnodes ( 1 ) = 0.0_pfqp qnodes ( 2 : nnodes - 1 ) = 0.5_pfqp * ( 1.0_pfqp + roots ) qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs ) deallocate ( roots ) do j = 2 , nnodes - 1 flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_GAUSS_LOBATTO ) degree = nnodes - 1 allocate ( roots ( degree - 1 )) allocate ( coeffs ( degree + 1 )) call poly_legendre ( coeffs , degree ) call poly_diff ( coeffs , degree ) call poly_roots ( roots , coeffs (: degree ), degree - 1 ) qnodes ( 1 ) = 0.0_pfqp qnodes ( 2 : nnodes - 1 ) = 0.5_pfqp * ( 1.0_pfqp + roots ) qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs ) deallocate ( roots ) do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_GAUSS_RADAU ) degree = nnodes - 1 allocate ( roots ( degree )) allocate ( coeffs ( degree + 1 )) allocate ( coeffs2 ( degree )) call poly_legendre ( coeffs , degree ) call poly_legendre ( coeffs2 , degree - 1 ) coeffs (: degree ) = coeffs (: degree ) + coeffs2 call poly_roots ( roots , coeffs , degree ) qnodes ( 1 ) = 0.0_pfqp do j = 2 , nnodes - 1 qnodes ( j ) = 0.5_pfqp * ( 1.0_pfqp - roots ( nnodes + 1 - j )) end do qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs2 ) deallocate ( coeffs ) deallocate ( roots ) do j = 2 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_CLENSHAW_CURTIS ) do j = 0 , nnodes - 1 qnodes ( j + 1 ) = 0.5_pfqp * ( 1.0_pfqp - cos ( j * pi / ( nnodes - 1 ))) end do do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_UNIFORM ) do j = 0 , nnodes - 1 qnodes ( j + 1 ) = j * ( 1.0_pfqp / ( nnodes - 1 )) end do do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_CHEBYSHEV ) qnodes ( 1 ) = 0.0_pfqp do j = 1 , nnodes - 2 qnodes ( j + 1 ) = 0.5_pfqp * ( 1.0_pfqp - cos (( j - 1 / 2 ) * pi / ( nnodes - 2 ))) end do qnodes ( nnodes ) = 0.0_pfqp do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , qtype ) end select end subroutine sdc_qnodes !>  Subroutine to compute the quadrature matrices subroutine sdc_qmats ( Qmat , Smat , dst , src , flags , ndst , nsrc ) integer , intent ( in ), value :: ndst !!  Number of destination points integer , intent ( in ), value :: nsrc !!  Number of source points real ( pfqp ), intent ( in ) :: dst ( ndst ) !!  Destination points real ( pfqp ), intent ( in ) :: src ( nsrc ) !!  Source points real ( pfdp ), intent ( out ) :: Qmat ( ndst - 1 , nsrc ) !!  O to dst quadrature weights real ( pfdp ), intent ( out ) :: Smat ( ndst - 1 , nsrc ) !! dst(m) to dst(m+1) quadrature weights integer , intent ( in ) :: flags ( nsrc ) integer :: i , j , m real ( pfqp ) :: q , s , den , p ( 0 : nsrc ) Qmat = 0.0_pfdp Smat = 0.0_pfdp ! construct Qmat and Smat do i = 1 , nsrc if ( not_proper ( flags , i )) cycle ! construct interpolating polynomial coefficients p = 0.0_pfdp p ( 0 ) = 1.0_pfdp do m = 1 , nsrc if ( not_proper ( flags , m ) . or . m == i ) cycle p = eoshift ( p , - 1 ) - src ( m ) * p end do den = poly_eval ( p , nsrc , src ( i )) call poly_int ( p , nsrc ) ! evaluate integrals do j = 2 , ndst q = poly_eval ( p , nsrc , dst ( j )) - poly_eval ( p , nsrc , 0.0_pfqp ) s = poly_eval ( p , nsrc , dst ( j )) - poly_eval ( p , nsrc , dst ( j - 1 )) Qmat ( j - 1 , i ) = real ( q / den , pfdp ) Smat ( j - 1 , i ) = real ( s / den , pfdp ) end do end do end subroutine sdc_qmats !> Polynomial manipulation routines. !! !! A polynomial p !! !!   p(x) = a_n x&#94;n + ... + a_2 x&#94;2 + a_1 x + a_0 !! !! is stored as a Fortran array p(0:n) according to !! !!   p = [ a_0, a_1, ..., a_n ]. !! !> Function to evaluate real polynomial real ( pfqp ) function poly_eval ( p , n , x ) result ( v ) integer , intent ( in ), value :: n real ( pfqp ), intent ( in ) :: p ( 0 : n ), x integer :: j v = p ( n ) do j = n - 1 , 0 , - 1 v = x * v + p ( j ) end do end function !> Function to evaluate complex polynomial complex ( pfqp ) function poly_eval_complex ( p , n , x ) result ( v ) integer , intent ( in ), value :: n real ( pfqp ), intent ( in ) :: p ( 0 : n ) complex ( pfqp ), intent ( in ) :: x integer :: j v = p ( n ) do j = n - 1 , 0 , - 1 v = x * v + p ( j ) end do end function !> Subroutine to differentiate polynomial (in place) subroutine poly_diff ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( inout ) :: p ( 0 : n ) integer :: j real ( pfqp ) :: pp ( 0 : n ) pp = 0.0_pfqp do j = 1 , n pp ( j - 1 ) = j * p ( j ) end do p = pp end subroutine poly_diff !> Subroutine to integrate polynomial (in place) subroutine poly_int ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( inout ) :: p ( 0 : n ) integer :: j real ( pfqp ) :: pp ( 0 : n ) pp = 0.0_pfqp do j = 0 , n - 1 pp ( j + 1 ) = p ( j ) / ( j + 1 ) end do p = pp end subroutine poly_int !> Subroutine to compute Legendre polynomial coefficients using Bonnet's recursion formula. subroutine poly_legendre ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( out ) :: p ( 0 : n ) real ( pfqp ), dimension ( 0 : n ) :: p0 , p1 , p2 integer :: j , m if ( n == 0 ) then p = [ 1.0_pfqp ] return end if if ( n == 1 ) then p = [ 0.0_pfqp , 1.0_pfqp ] return end if p0 = 0.0_pfqp ; p1 = 0.0_pfqp ; p2 = 0.0_pfqp p0 ( 0 ) = 1.0_pfqp p1 ( 1 ) = 1.0_pfqp ! (n + 1) P_{n+1} = (2n + 1) x P_{n} - n P_{n-1} do m = 1 , n - 1 do j = 1 , n p2 ( j ) = ( ( 2 * m + 1 ) * p1 ( j - 1 ) - m * p0 ( j ) ) / ( m + 1 ) end do p2 ( 0 ) = - m * p0 ( 0 ) / ( m + 1 ) p0 = p1 p1 = p2 end do p = p2 end subroutine poly_legendre !> Subroutine to compute polynomial roots using the Durand-Kerner algorithm. !! The roots are assumed to be real. subroutine poly_roots ( roots , p0 , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( out ) :: roots ( n ) real ( pfqp ), intent ( in ) :: p0 ( 0 : n ) integer :: i , j , k complex ( pfqp ) :: num , den , z0 ( n ), z1 ( n ) real ( pfqp ) :: p ( 0 : n ) real ( pfqp ) :: eps eps = epsilon ( 1.0_pfqp ) * 10 0.0_pfqp p = p0 / p0 ( n ) ! initial guess do i = 1 , n z0 ( i ) = ( 0.4_pfqp , 0.9_pfqp ) ** i end do ! durand-kerner-weierstrass iterations z1 = z0 do k = 1 , 100 do i = 1 , n ! evaluate poly at z0(i) num = poly_eval_complex ( p , n , z0 ( i )) ! evaluate denominator den = 1.0_pfqp do j = 1 , n if ( j == i ) cycle den = den * ( z0 ( i ) - z0 ( j )) end do ! update z0 ( i ) = z0 ( i ) - num / den end do ! converged? if ( sum ( abs ( z0 - z1 )) < eps ) exit z1 = z0 end do roots = real ( z0 ) where ( abs ( roots ) < eps ) roots = 0.0_pfqp call qsort ( roots ) end subroutine poly_roots !> Subroutine to sort (inplace) using the quick sort algorithm. !> Adapted from http://www.fortran.com/qsort_c.f95. recursive subroutine qsort ( a ) real ( pfqp ), intent ( inout ) :: a (:) integer :: iq if ( size ( a ) > 1 ) then call qsort_partition ( a , iq ) call qsort ( a (: iq - 1 )) call qsort ( a ( iq :)) end if end subroutine qsort subroutine qsort_partition ( a , marker ) real ( pfqp ), intent ( inout ) :: a (:) integer , intent ( out ) :: marker integer :: i , j real ( pfqp ) :: temp , x x = a ( 1 ) i = 0 j = size ( a ) + 1 do j = j - 1 do if ( a ( j ) <= x ) exit j = j - 1 end do i = i + 1 do if ( a ( i ) >= x ) exit i = i + 1 end do if ( i < j ) then temp = a ( i ) a ( i ) = a ( j ) a ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return endif end do end subroutine qsort_partition end module pf_mod_quadrature","tags":"","loc":"sourcefile/pf_quadrature.f90.html","title":"pf_quadrature.f90 – LibPFASST"},{"text":"N-dimensional array encapsulation for optimal control problems. Contents Modules pf_mod_ndarray_oc Source Code pf_ndarray_oc_encap.f90 Source Code !! N-dimensional array encapsulation for optimal control problems. ! ! This file is part of LIBPFASST. ! !! !> When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'shape' attribute to create a new array with that !! shape.  Thus, the 'shape' attributes of the PFASST levels should be !! set appropriately.  For example, before calling pf_pfasst_run we can !! set the shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%shape(2)) !!   pf%levels(1)%shape = [ 3, 10 ] !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to the encapsulated array from a C pointer without !! performing any copies. module pf_mod_ndarray_oc use iso_c_binding use pf_mod_dtype use pf_mod_utils implicit none !>  Type to create and destroy N-dimenstional arrays for optimal control type , extends ( pf_factory_t ) :: ndarray_oc_factory contains procedure :: create_single => ndarray_oc_create_single procedure :: create_array => ndarray_oc_create_array procedure :: destroy_single => ndarray_oc_destroy_single procedure :: destroy_array => ndarray_oc_destroy_array end type ndarray_oc_factory !>  N-dimensional array type for optimal control,  extends the abstract encap type type , extends ( pf_encap_t ) :: ndarray_oc integer :: dim integer , allocatable :: shape (:) real ( pfdp ), allocatable :: yflatarray (:) real ( pfdp ), allocatable :: pflatarray (:) contains procedure :: setval => ndarray_oc_setval procedure :: copy => ndarray_oc_copy procedure :: norm => ndarray_oc_norm procedure :: pack => ndarray_oc_pack procedure :: unpack => ndarray_oc_unpack procedure :: axpy => ndarray_oc_axpy procedure :: eprint => ndarray_oc_eprint end type ndarray_oc ! interfaces to routines in pf_numpy.c interface subroutine ndarray_dump_numpy ( dname , fname , endian , dim , shape , nvars , array ) bind ( c ) use iso_c_binding use pf_mod_dtype character ( c_char ), intent ( in ) :: dname , fname , endian ( 5 ) integer ( c_int ), intent ( in ), value :: dim , nvars integer ( c_int ), intent ( in ) :: shape ( dim ) real ( pfdp ), intent ( in ) :: array ( nvars ) end subroutine ndarray_dump_numpy end interface contains !>  Subroutine to allocate the array and set the size parameters subroutine ndarray_oc_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) select type ( q ) class is ( ndarray_oc ) allocate ( q % shape ( size ( shape ))) allocate ( q % yflatarray ( product ( shape ))) allocate ( q % pflatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_build !> Subroutine to  create a single array subroutine ndarray_oc_create_single ( this , x , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( ndarray_oc :: x ) call ndarray_oc_build ( x , shape ) end subroutine ndarray_oc_create_single !> Subroutine to create an array of arrays subroutine ndarray_oc_create_array ( this , x , n , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndarray_oc :: x ( n )) do i = 1 , n call ndarray_oc_build ( x ( i ), shape ) end do end subroutine ndarray_oc_create_array !>  Subroutine to destroy array subroutine ndarray_oc_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndarray_oc ), pointer :: ndarray_oc_obj ndarray_oc_obj => cast_as_ndarray_oc ( encap ) !?? deallocate ( ndarray_oc_obj % pflatarray ) deallocate ( ndarray_oc_obj % yflatarray ) deallocate ( ndarray_oc_obj % shape ) nullify ( ndarray_oc_obj ) end subroutine ndarray_oc_destroy !> Subroutine to destroy an single array subroutine ndarray_oc_destroy_single ( this , x ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( ndarray_oc ) deallocate ( x % pflatarray ) deallocate ( x % yflatarray ) deallocate ( x % shape ) class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select deallocate ( x ) end subroutine ndarray_oc_destroy_single !> Subroutine to destroy an array of arrays subroutine ndarray_oc_destroy_array ( this , x ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( ndarray_oc ) do i = 1 , size ( x ) deallocate ( x ( i )% pflatarray ) deallocate ( x ( i )% yflatarray ) deallocate ( x ( i )% shape ) end do class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select deallocate ( x ) end subroutine ndarray_oc_destroy_array !> Subroutine to set array to a scalar  value. subroutine ndarray_oc_setval ( this , val , flags ) class ( ndarray_oc ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"setval without flags\" select case ( which ) case ( 0 ) this % yflatarray = val this % pflatarray = val case ( 1 ) this % yflatarray = val case ( 2 ) this % pflatarray = val case default call pf_stop ( __ FILE__ , __ LINE__ , 'Select case error' , which ) end select end subroutine ndarray_oc_setval !> Subroutine to copy an array subroutine ndarray_oc_copy ( this , src , flags ) class ( ndarray_oc ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"copy without flags\" select type ( src ) type is ( ndarray_oc ) select case ( which ) case ( 0 ) this % yflatarray = src % yflatarray this % pflatarray = src % pflatarray case ( 1 ) this % yflatarray = src % yflatarray case ( 2 ) this % pflatarray = src % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_copy !> Subroutine to pack an array into a flat array for sending subroutine ndarray_oc_pack ( this , z , flags ) class ( ndarray_oc ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags select case ( which ) case ( 0 ) !z = [sol%yflatarray, sol%pflatarray] !z has to be right size? initialized to nvars, so it can hold either y or p !is it ever needed to pack y and p simultaneously? stop \"ERROR in ndarray_oc_pack: only 1, 2 allowed as flags\" case ( 1 ) z = this % yflatarray case ( 2 ) z = this % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine ndarray_oc_pack !> Subroutine to unpack a flatarray after receiving subroutine ndarray_oc_unpack ( this , z , flags ) class ( ndarray_oc ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags select case ( which ) case ( 0 ) stop \"ERROR in ndarray_oc_unpack: only 1, 2 allowed as flags\" case ( 1 ) this % yflatarray = z case ( 2 ) this % pflatarray = z case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine ndarray_oc_unpack !> Subroutine to define the norm of the array (here the max norm) function ndarray_oc_norm ( this , flags ) result ( norm ) class ( ndarray_oc ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm integer :: which which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) print * , \"norm without flags\" select case ( which ) case ( 0 ) norm = max ( maxval ( abs ( this % yflatarray )), maxval ( abs ( this % pflatarray ))) case ( 1 ) norm = maxval ( abs ( this % yflatarray )) case ( 2 ) norm = maxval ( abs ( this % pflatarray )) case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end function ndarray_oc_norm !> Subroutine to compute y = a x + y where a is a scalar and x and y are arrays subroutine ndarray_oc_axpy ( this , a , x , flags ) class ( ndarray_oc ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if (.not.present(flags)) stop \"axpy without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 0 ) this % yflatarray = a * x % yflatarray + this % yflatarray this % pflatarray = a * x % pflatarray + this % pflatarray case ( 1 ) this % yflatarray = a * x % yflatarray + this % yflatarray case ( 2 ) this % pflatarray = a * x % pflatarray + this % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_axpy ! Helpers !   function dims(solptr) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer :: r ! !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     r = sol%dim !   end function dims function cast_as_ndarray_oc ( encap_polymorph ) result ( ndarray_oc_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndarray_oc ), pointer :: ndarray_oc_obj select type ( encap_polymorph ) type is ( ndarray_oc ) ndarray_oc_obj => encap_polymorph class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function cast_as_ndarray_oc function get_array1d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"array1d_oc without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r => x % yflatarray case ( 2 ) r => x % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array1d_oc function get_array2d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"array2d_oc without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % yflatarray case ( 2 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % pflatarray case default stop \"ERROR in get_array1d_oc: only 1, 2 allowed as flags\" end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array2d_oc function get_array3d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) integer :: which which = 0 if ( present ( flags )) which = flags select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % yflatarray case ( 2 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % pflatarray case default stop \"ERROR in get_array1d_oc: only 1, 2 allowed as flags\" end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array3d_oc subroutine ndarray_oc_dump_hook ( pf , level_index ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index character ( len = 256 ) :: fnamey , fnamep type ( ndarray_oc ), pointer :: qend qend => cast_as_ndarray_oc ( pf % levels ( level_index )% qend ) write ( fnamey , \"('y_s',i0.2,'i',i0.3,'l',i0.2,'.npy')\" ) & pf % state % step , pf % state % iter , level_index call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamey ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % yflatarray ), qend % yflatarray ) write ( fnamep , \"('p_s',i0.2,'i',i0.3,'l',i0.2,'.npy')\" ) & pf % state % step , pf % state % iter , level_index call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamep ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % pflatarray ), qend % pflatarray ) end subroutine ndarray_oc_dump_hook subroutine ndarray_oc_dump_all_hook ( pf , level_index ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index character ( len = 256 ) :: fnamey , fnamep integer :: m type ( ndarray_oc ), pointer :: qend do m = 1 , pf % levels ( level_index )% nnodes qend => cast_as_ndarray_oc ( pf % levels ( level_index )% Q ( m )) write ( fnamey , \"('y_s',i0.2,'l',i0.2,'m',i0.2,'.npy')\" ) & pf % state % step , level_index , m call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamey ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % yflatarray ), qend % yflatarray ) write ( fnamep , \"('p_s',i0.2,'l',i0.2,'m',i0.2,'.npy')\" ) & pf % state % step , level_index , m call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamep ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % pflatarray ), qend % pflatarray ) end do end subroutine ndarray_oc_dump_all_hook !>  Subroutine to print the array to the screen (mainly for debugging purposes) subroutine ndarray_oc_eprint ( this , flags ) class ( ndarray_oc ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % yflatarray ( 1 : 10 ) print * , this % pflatarray ( 1 : 10 ) end subroutine ndarray_oc_eprint !   function array2_oc(solptr, flags) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer,     intent(in   ), optional :: flags !     real(pfdp), pointer :: r(:,:) ! !     integer                :: shp(2) !     integer                :: which !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     if (sol%dim == 2) then !        shp = sol%shape ! !        which = 0 !        if (present(flags)) which = flags ! !        select case (which) !        case (0) !           stop \"ERROR in array2_oc: only 1, 2 allowed as flags\" !        case (1) !           call c_f_pointer(sol%yptr, r, shp) !        case (2) !           call c_f_pointer(sol%pptr, r, shp) !        case default !           stop \"ERROR in array2_oc: only 1, 2 allowed as flags\" !        end select !     else !        stop \"ERROR: array2 dimension mismatch.\" !     end if !   end function array2_oc ! !   function array3_oc(solptr, flags) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer,     intent(in   ), optional :: flags !     real(pfdp), pointer :: r(:,:,:) ! !     integer                :: shp(3) !     integer                :: which !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     if (sol%dim == 3) then !        shp = sol%shape ! !        which = 0 !        if (present(flags)) which = flags ! !        select case (which) !        case (0) !           stop \"ERROR in array3_oc: only 1, 2 allowed as flags\" !        case (1) !           call c_f_pointer(sol%yptr, r, shp) !        case (2) !           call c_f_pointer(sol%pptr, r, shp) !        case default !           stop \"ERROR in array3_oc: only 1, 2 allowed as flags\" !        end select !     else !        stop \"ERROR: array3 dimension mismatch.\" !     end if !   end function array3_oc ! !   function array4_oc(solptr, flags) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer,     intent(in   ), optional :: flags !     real(pfdp), pointer :: r(:,:,:,:) ! !     integer                :: shp(4) !     integer                :: which !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     if (sol%dim == 4) then !        shp = sol%shape ! !        which = 0 !        if (present(flags)) which = flags ! !        select case (which) !        case (0) !           stop \"ERROR in array4_oc: only 1, 2 allowed as flags\" !        case (1) !           call c_f_pointer(sol%yptr, r, shp) !        case (2) !           call c_f_pointer(sol%pptr, r, shp) !        case default !           stop \"ERROR in array4_oc: only 1, 2 allowed as flags\" !        end select !     else !        stop \"ERROR: array4 dimension mismatch.\" !     end if !   end function array4_oc ! !   function array5_oc(solptr, flags) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer,     intent(in   ), optional :: flags !     real(pfdp), pointer :: r(:,:,:,:,:) ! !     integer                :: shp(5) !     integer                :: which !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     if (sol%dim == 5) then !        shp = sol%shape ! !        which = 0 !        if (present(flags)) which = flags ! !        select case (which) !        case (0) !           stop \"ERROR in array5_oc: only 1, 2 allowed as flags\" !        case (1) !           call c_f_pointer(sol%yptr, r, shp) !        case (2) !           call c_f_pointer(sol%pptr, r, shp) !        case default !           stop \"ERROR in array5_oc: only 1, 2 allowed as flags\" !        end select !     else !        stop \"ERROR: array5 dimension mismatch.\" !     end if !   end function array5_oc ! !    function get_y(ptr) result(y) !      type(c_ptr), intent(in), value :: ptr !      real(pfdp),    pointer :: y(:) !      type(ndarray_oc), pointer :: sol ! !      call c_f_pointer(ptr, sol) !      y => sol%yflatarray !    end function get_y ! !    function get_p(ptr) result(p) !      type(c_ptr), intent(in), value :: ptr !      real(pfdp),    pointer :: p(:) !      type(ndarray_oc), pointer :: sol ! !      call c_f_pointer(ptr, sol) !      p => sol%pflatarray !    end function get_p ! !   subroutine ndarray_oc_encap_create(encap) !     type(pf_encap_t), intent(out) :: encap ! !     encap%create  => ndarray_oc_create !     encap%destroy => ndarray_oc_destroy !     encap%setval  => ndarray_oc_setval !     encap%copy    => ndarray_oc_copy !     encap%norm    => ndarray_oc_norm !     encap%pack    => ndarray_oc_pack !     encap%unpack  => ndarray_oc_unpack !     encap%axpy    => ndarray_oc_saxpy !   end subroutine ndarray_oc_encap_create end module pf_mod_ndarray_oc","tags":"","loc":"sourcefile/pf_ndarray_oc_encap.f90.html","title":"pf_ndarray_oc_encap.f90 – LibPFASST"},{"text":"Contents Modules pf_mod_parareal Source Code pf_parareal.f90 Source Code module pf_mod_parareal use pf_mod_interpolate use pf_mod_restrict use pf_mod_utils use pf_mod_timer use pf_mod_dtype use pf_mod_hooks use pf_mod_pfasst use pf_mod_comm implicit none !>  The main PFASST data type which includes pretty much everythingl contains !>  Do the parareal algorithm subroutine pf_parareal_run ( pf , q0 , dt , tend , nsteps , qend ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  The complete PFASST structure class ( pf_encap_t ), intent ( in ) :: q0 !!  The initial condition real ( pfdp ), intent ( in ) :: dt !!  The time step for each processor real ( pfdp ), intent ( in ) :: tend !!  The final time of run integer , intent ( in ), optional :: nsteps !!  The number of time steps class ( pf_encap_t ), intent ( inout ), optional :: qend !!  The computed solution at tend !  Local variables integer :: nproc !!  Total number of processors integer :: nsteps_loc !!  local number of time steps real ( pfdp ) :: tend_loc !!  The final time of run ! make a local copy of nproc nproc = pf % comm % nproc !>  Set the number of time steps to do !!  The user can either pass in the number of time steps or !!  pass in the time step size and length of run if ( present ( nsteps )) then nsteps_loc = nsteps tend_loc = dble ( nsteps_loc * dt ) else nsteps_loc = ceiling ( tend / dt ) !  Do  sanity check on steps if ( abs ( real ( nsteps_loc , pfdp ) - tend / dt ) > dt / 10 0.0 ) then print * , 'dt=' , dt print * , 'nsteps=' , nsteps_loc print * , 'tend=' , tend stop \"Invalid nsteps\" end if end if pf % state % nsteps = nsteps_loc !>  Allocate stuff for holding results call pf_initialize_results ( pf ) !  do sanity checks on Nproc if ( mod ( nsteps , nproc ) > 0 ) stop \"ERROR: nsteps must be multiple of nproc (pf_parallel.f90).\" if ( present ( qend )) then call pf_parareal_block_run ( pf , q0 , dt , nsteps_loc , qend = qend ) else call pf_parareal_block_run ( pf , q0 , dt , nsteps_loc ) end if call pf_dump_results ( pf ) !>   deallocate results data call pf_destroy_results ( pf ) end subroutine pf_parareal_run !>  parareal controller for block mode subroutine pf_parareal_block_run ( pf , q0 , dt , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf class ( pf_encap_t ), intent ( in ) :: q0 real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps class ( pf_encap_t ), intent ( inout ), optional :: qend integer , intent ( in ), optional :: flags (:) class ( pf_level_t ), pointer :: lev_p !!  pointer to the one level we are operating on integer :: j , k integer :: nblocks !!  The number of blocks of steps to do integer :: nproc !!  The number of processors being used integer :: level_index_c !!  Coarsest level in V (Lambda)-cycle integer :: level_max_depth !!  Finest level in V-cycle integer :: nsteps_c , nsteps_f call start_timer ( pf , TTOTAL ) pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % step = pf % rank pf % state % t0 = pf % state % step * dt ! set finest level to visit in the following run pf % state % finest_level = pf % nlevels !  pointer to finest  level to start lev_p => pf % levels ( pf % state % finest_level ) !  Stick the initial condition into q0 (will happen on all processors) call lev_p % q0 % copy ( q0 , flags = 0 ) nproc = pf % comm % nproc nblocks = nsteps / nproc !  Decide what the coarsest level in the V-cycle is level_index_c = 1 if (. not . pf % Vcycle ) level_index_c = pf % state % finest_level do k = 1 , nblocks !  Loop over blocks of time steps ! print *,'Starting  step=',pf%state%step,'  block k=',k ! Each block will consist of !  1.  predictor !  2.  Vcycle until max iterations, or tolerances met !  3.  Move solution to next block !  Reset some flags !>  When starting a new block, broadcast new initial conditions to all procs !>  For initial block, this is done when initial conditions are set !> Reset some flags pf % state % iter = - 1 pf % state % itcnt = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % pfblock = k pf % state % sweep = 1 !  Needed for compatibility of residual storage if ( k > 1 ) then if ( nproc > 1 ) then call lev_p % qend % pack ( lev_p % send ) !!  Pack away your last solution call pf_broadcast ( pf , lev_p % send , lev_p % mpibuflen , pf % comm % nproc - 1 ) call lev_p % q0 % unpack ( lev_p % send ) !!  Everyone resets their q0 else call lev_p % q0 % copy ( lev_p % qend , flags = 0 ) !!  Just stick qend in q0 end if !>  Update the step and t0 variables for new block pf % state % step = pf % state % step + pf % comm % nproc pf % state % t0 = pf % state % step * dt end if !> Call the predictor to get an initial guess on all levels and all processors call pf_parareal_predictor ( pf , pf % state % t0 , dt , flags ) !>  Start the parareal iterations call start_timer ( pf , TITERATION ) do j = 1 , pf % niters call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle call pf_parareal_v_cycle ( pf , k , pf % state % t0 , dt , 1 , 2 ) !  Check for convergence call pf_check_convergence_block ( pf , pf % state % finest_level , send_tag = 1111 * k + j ) call call_hooks ( pf , - 1 , PF_POST_ITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) exit end do !  Loop over the iteration in this bloc call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) call end_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_POST_STEP ) end do !  Loop over the blocks call end_timer ( pf , TTOTAL ) !  Grab the last solution for return (if wanted) if ( present ( qend )) then call qend % copy ( lev_p % qend , flags = 0 ) end if end subroutine pf_parareal_block_run !>  The parareal predictor does a serial integration on the coarse level followed !>  by a fine integration if there is a fine level subroutine pf_parareal_predictor ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p !! integer :: k , n !!  Loop indices integer :: nsteps_c , nsteps_f !!  Number of RK  steps integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k pf % state % iter = 0 call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) !  This is for one two levels only or one if only RK is done c_lev_p => pf % levels ( 1 ) f_lev_p => pf % levels ( pf % state % finest_level ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning parareal predictor' !! Step 1. Getting the initial condition on the coarsest level if ( pf % state % finest_level > 1 ) then if ( pf % q0_style < 2 ) then !  Copy coarse call c_lev_p % q0 % copy ( f_lev_p % q0 ) end if end if level_index = 1 !! !! Step 2. Do coarse level integration, no communication necessary nsteps_c = c_lev_p % ulevel % stepper % nsteps !  Each processor integrates alone do n = 1 , pf % rank + 1 if ( n . gt . 1 ) call c_lev_p % q0 % copy ( c_lev_p % qend ) t0k = dt * real ( n - 1 , pfdp ) call c_lev_p % ulevel % stepper % do_n_steps ( pf , 1 , t0k , c_lev_p % q0 , c_lev_p % qend , dt , nsteps_c ) end do ! Save the coarse level value call c_lev_p % Q ( 2 )% copy ( c_lev_p % qend , flags = 0 ) !!  Step 3:  Return to fine level and Step there !    if(pf%state%finest_level > 1) then  !  Will do nothing with one level !       call f_lev_p%q0%copy(c_lev_p%q0, flags=0)       !  Get fine initial condition !       nsteps_f= f_lev_p%ulevel%stepper%nsteps  !  Each processor integrates alone !       call f_lev_p%ulevel%stepper%do_n_steps(pf, level_index,pf%state%t0, f_lev_p%q0,f_lev_p%qend, dt, nsteps_f) !    endif call end_timer ( pf , TPREDICTOR ) pf % state % iter = 1 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) end subroutine pf_parareal_predictor !> Execute a V-cycle between levels nfine and ncoarse subroutine pf_parareal_v_cycle ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j , nsteps_f , nsteps_c if ( pf % nlevels < 2 ) return !  This is for two levels only c_lev_p => pf % levels ( 1 ) f_lev_p => pf % levels ( 2 ) nsteps_c = c_lev_p % ulevel % stepper % nsteps nsteps_f = f_lev_p % ulevel % stepper % nsteps !  Do fine steps with old initial condition if ( pf % rank /= 0 ) then call f_lev_p % q0 % copy ( c_lev_p % q0 , flags = 0 ) !  Get fine initial condition end if call f_lev_p % ulevel % stepper % do_n_steps ( pf , 2 , pf % state % t0 , f_lev_p % q0 , f_lev_p % qend , dt , nsteps_f ) ! Get a new initial condition on coarse call pf_recv ( pf , c_lev_p , 10000 + iteration , . true .) !  Step on coarse call c_lev_p % ulevel % stepper % do_n_steps ( pf , 1 , pf % state % t0 , c_lev_p % q0 , c_lev_p % qend , dt , nsteps_c ) !  Compute the correction (store in Q(1)) call c_lev_p % Q ( 1 )% copy ( f_lev_p % qend , flags = 0 ) !  Current call c_lev_p % Q ( 1 )% axpy ( - 1.0_pfdp , c_lev_p % Q ( 2 )) ! ! Save the result of the coarse sweep call c_lev_p % Q ( 2 )% copy ( c_lev_p % qend , flags = 0 ) ! correct coarse level solution at end (the parareal correction) call c_lev_p % qend % axpy ( 1.0_pfdp , c_lev_p % Q ( 1 )) !  Send coarse forward  (nonblocking) call pf_send ( pf , c_lev_p , 10000 + iteration , . false .) !  Compute the jump in the initial condition call f_lev_p % q0_delta % copy ( c_lev_p % q0 , flags = 0 ) call f_lev_p % q0_delta % axpy ( - 1.0d0 , f_lev_p % q0 , flags = 0 ) f_lev_p % residual = f_lev_p % q0_delta % norm ( flags = 0 ) call pf_set_resid ( pf , 2 , f_lev_p % residual ) !!$    print *,'after fine steps ' !!$    call f_lev_p%qend%eprint() !!$    call c_lev_p%qend%eprint() end subroutine pf_parareal_v_cycle !> Subroutine to check if the current processor has converged and !> to update the next processor on the status !> Note that if the previous processor hasn't converged yet !> (pstatus), the current processor can't be converged yet either subroutine pf_check_convergence_block ( pf , level_index , send_tag ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index integer , intent ( in ) :: send_tag !! identifier for status send and receive logical :: residual_converged , converged ! Shortcut for fixed iteration mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual ( pf , level_index , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 ) then converged = . true . else !  I am not the first processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !>  For parareal, Proc N is converged after iteration N if ( pf % rank . lt . pf % state % iter ) then converged = . true . end if !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag ) end if end subroutine pf_check_convergence_block !> Subroutine to test residuals to determine if the current processor has converged. subroutine pf_check_residual ( pf , level_index , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if absolute tolerance is met if ( pf % levels ( level_index )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( level_index )% residual residual_converged = . true . end if end subroutine pf_check_residual end module pf_mod_parareal","tags":"","loc":"sourcefile/pf_parareal.f90.html","title":"pf_parareal.f90 – LibPFASST"},{"text":"type, public, abstract, extends( pf_stepper_t ) :: pf_ark_stepper_t IMEX or additive or semi-implicit Runge-Kutta stepper  type Contents Variables npieces order nsteps AmatI AmatE cvec bvecI bvecE QtilI explicit implicit nstages rhs qtemp q0 qend F Type-Bound Procedures f_eval f_comp do_n_steps initialize destroy ark_initialize ark_destroy Source Code pf_ark_stepper_t Components Type Visibility Attributes Name Initial integer, public :: npieces integer, public :: order integer, public :: nsteps real(kind=pfdp), public, allocatable :: AmatI (:,:) real(kind=pfdp), public, allocatable :: AmatE (:,:) real(kind=pfdp), public, allocatable :: cvec (:) real(kind=pfdp), public, allocatable :: bvecI (:) real(kind=pfdp), public, allocatable :: bvecE (:) real(kind=pfdp), public, allocatable :: QtilI (:,:) logical, public :: explicit = .true. logical, public :: implicit = .true. integer, public :: nstages class( pf_encap_t ), public, allocatable :: rhs Accumulated right hand side for implicit solves class( pf_encap_t ), public, allocatable :: qtemp Temp for y class( pf_encap_t ), public, allocatable :: q0 Local q0 class( pf_encap_t ), public, allocatable :: qend Local qend class( pf_encap_t ), public, pointer :: F (:,:) Pointer to F Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dtq class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure, public :: do_n_steps => ark_do_n_steps public subroutine ark_do_n_steps (this, pf, level_index, t0, q0, qend, big_dt, nsteps_rk) Perform N steps of ark on level level_index and set qend appropriately.\n Assign pointer to appropriate level Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Level of the index to step on real(kind=pfdp), intent(in) :: t0 Time at start of time interval class( pf_encap_t ), intent(in) :: q0 Starting value class( pf_encap_t ), intent(inout) :: qend Final value real(kind=pfdp), intent(in) :: big_dt Size of time interval to integrato on integer, intent(in) :: nsteps_rk Number of steps to use procedure, public :: initialize => ark_initialize public subroutine ark_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize procedure, public :: destroy => ark_destroy public subroutine ark_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: ark_initialize public subroutine ark_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize procedure, public :: ark_destroy public subroutine ark_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Source Code type , extends ( pf_stepper_t ), abstract :: pf_ark_stepper_t real ( pfdp ), allocatable :: AmatI (:,:) real ( pfdp ), allocatable :: AmatE (:,:) real ( pfdp ), allocatable :: cvec (:) real ( pfdp ), allocatable :: bvecI (:) real ( pfdp ), allocatable :: bvecE (:) real ( pfdp ), allocatable :: QtilI (:,:) logical :: explicit = . true . logical :: implicit = . true . integer :: nstages !  Local storage (not optimal) class ( pf_encap_t ), allocatable :: rhs !!  Accumulated right hand side for implicit solves class ( pf_encap_t ), allocatable :: qtemp !!  Temp for y class ( pf_encap_t ), allocatable :: q0 !!  Local q0 class ( pf_encap_t ), allocatable :: qend !!  Local qend class ( pf_encap_t ), pointer :: F (:,:) !!  Pointer to F contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: do_n_steps => ark_do_n_steps procedure :: initialize => ark_initialize procedure :: destroy => ark_destroy procedure :: ark_initialize procedure :: ark_destroy end type pf_ark_stepper_t","tags":"","loc":"type/pf_ark_stepper_t.html","title":"pf_ark_stepper_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_imex_sweeper_t IMEX SDC sweeper type, extends abstract sweeper Contents Variables npieces use_LUq QtilE QtilI dtsdc QdiffE QdiffI explicit implicit rhs Type-Bound Procedures f_eval f_comp sweep initialize evaluate integrate residual spreadq0 evaluate_all destroy imex_destroy imex_initialize Source Code pf_imex_sweeper_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QtilE (:,:) Approximate explicit quadrature rule real(kind=pfdp), public, allocatable :: QtilI (:,:) Approximate implicit quadrature rule real(kind=pfdp), public, allocatable :: dtsdc (:) SDC step sizes real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: QdiffI (:,:) qmat-QtilI logical, public :: explicit True if there is an explicit piece (must set in derived sweeper) logical, public :: implicit True if there an implicit piece (must set in derived sweeper) class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval RHS function evaluations subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Prototype The interface to the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate procedure( pf_f_comp_p ), public, deferred :: f_comp Implicit solver subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Prototype The interface to the routine to do implicit solve \n  i.e, solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate procedure, public :: sweep => imex_sweep Set the generic functions public subroutine imex_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform nsweeps SDC sweeps on level level_index and set qend appropriately.\n  Loop over sweeps\n  Loop over substeps\n  Accumulate rhs\n  Add the integral term Read more… Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to sweep real(kind=pfdp), intent(in) :: t0 time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags sweep specific flags procedure, public :: initialize => imex_initialize public subroutine imex_initialize (this, pf, level_index) Subroutine to initialize matrices and space for sweeper\n  Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize procedure, public :: evaluate => imex_evaluate public subroutine imex_evaluate (this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => imex_integrate public subroutine imex_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Subroutine to compute  Picard integral of function values Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags procedure, public :: residual => imex_residual public subroutine imex_residual (this, pf, level_index, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags procedure, public :: spreadq0 => imex_spreadq0 public subroutine imex_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => imex_evaluate_all public subroutine imex_evaluate_all (this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => imex_destroy public subroutine imex_destroy (this, pf, level_index) Subroutine to deallocate sweeper Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: imex_destroy public subroutine imex_destroy (this, pf, level_index) Subroutine to deallocate sweeper Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: imex_initialize public subroutine imex_initialize (this, pf, level_index) Subroutine to initialize matrices and space for sweeper\n  Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize Source Code type , extends ( pf_sweeper_t ), abstract :: pf_imex_sweeper_t real ( pfdp ), allocatable :: QtilE (:,:) !!  Approximate explicit quadrature rule real ( pfdp ), allocatable :: QtilI (:,:) !!  Approximate implicit quadrature rule real ( pfdp ), allocatable :: dtsdc (:) !!  SDC step sizes real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: QdiffI (:,:) !!  qmat-QtilI logical :: explicit !!  True if there is an explicit piece (must set in derived sweeper) logical :: implicit !!  True if there an implicit piece (must set in derived sweeper) class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver !>  Set the generic functions procedure :: sweep => imex_sweep procedure :: initialize => imex_initialize procedure :: evaluate => imex_evaluate procedure :: integrate => imex_integrate procedure :: residual => imex_residual procedure :: spreadq0 => imex_spreadq0 procedure :: evaluate_all => imex_evaluate_all procedure :: destroy => imex_destroy procedure :: imex_destroy procedure :: imex_initialize end type pf_imex_sweeper_t","tags":"","loc":"type/pf_imex_sweeper_t.html","title":"pf_imex_sweeper_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_misdcQ_t Multi-implicit SDC sweeper type, extends abstract sweeper Contents Variables npieces use_LUq QdiffE QdiffI QtilE QtilI dtsdc I3 rhs Type-Bound Procedures f_eval f_comp sweep initialize integrate residual spreadq0 evaluate_all evaluate destroy misdcQ_destroy misdcQ_initialize Source Code pf_misdcQ_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) class( pf_encap_t ), public, allocatable :: I3 (:) class( pf_encap_t ), public, allocatable :: rhs Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Prototype This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Prototype Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate procedure, public :: sweep => misdcQ_sweep public subroutine misdcQ_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Loop over sweeps Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => misdcQ_initialize public subroutine misdcQ_initialize (this, pf, level_index) Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: integrate => misdcQ_integrate public subroutine misdcQ_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => misdcQ_residual public subroutine misdcQ_residual (this, pf, level_index, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags procedure, public :: spreadq0 => misdcQ_spreadq0 public subroutine misdcQ_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => misdcQ_evaluate_all public subroutine misdcQ_evaluate_all (this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate => misdcQ_evaluate public subroutine misdcQ_evaluate (this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => misdcQ_destroy public subroutine misdcQ_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: misdcQ_destroy public subroutine misdcQ_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: misdcQ_initialize public subroutine misdcQ_initialize (this, pf, level_index) Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Source Code type , extends ( pf_sweeper_t ), abstract :: pf_misdcQ_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) real ( pfdp ), allocatable :: dtsdc (:) class ( pf_encap_t ), allocatable :: I3 (:) class ( pf_encap_t ), allocatable :: rhs contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdcQ_sweep procedure :: initialize => misdcQ_initialize procedure :: integrate => misdcQ_integrate procedure :: residual => misdcQ_residual procedure :: spreadq0 => misdcQ_spreadq0 procedure :: evaluate_all => misdcQ_evaluate_all procedure :: evaluate => misdcQ_evaluate procedure :: destroy => misdcQ_destroy procedure :: misdcQ_destroy procedure :: misdcQ_initialize end type pf_misdcQ_t","tags":"","loc":"type/pf_misdcq_t.html","title":"pf_misdcQ_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_misdc_t MISDC sweeper type, extends abstract sweeper Contents Variables npieces use_LUq SdiffE SdiffI Type-Bound Procedures spreadq0 f_eval f_comp sweep initialize evaluate integrate residual evaluate_all destroy misdc_destroy Source Code pf_misdc_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure( pf_spreadq0_p ), public, deferred :: spreadq0 subroutine pf_spreadq0_p(this, pf, level_index, t0, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure, public :: sweep => misdc_sweep public subroutine misdc_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: initialize => misdc_initialize public subroutine misdc_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => misdc_evaluate public subroutine misdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m procedure, public :: integrate => misdc_integrate public subroutine misdc_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) procedure, public :: residual => misdc_residual public subroutine misdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt procedure, public :: evaluate_all => misdc_evaluate_all public subroutine misdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) procedure, public :: destroy => misdc_destroy public subroutine misdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: misdc_destroy public subroutine misdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_misdc_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdc_sweep procedure :: initialize => misdc_initialize procedure :: evaluate => misdc_evaluate procedure :: integrate => misdc_integrate procedure :: residual => misdc_residual procedure :: evaluate_all => misdc_evaluate_all procedure :: destroy => misdc_destroy procedure :: misdc_destroy end type pf_misdc_t","tags":"","loc":"type/pf_misdc_t.html","title":"pf_misdc_t – LibPFASST "},{"text":"type, public, abstract :: pf_fft_abs_t Variables and storage for FFT Contents Variables nx ny nz dim Lx Ly Lz wk_1d wk_2d wk_3d Type-Bound Procedures fft_setup fft_destroy fftf fftb fft ifft conv zconv get_wk_ptr make_lap make_deriv restrict Source Code pf_fft_abs_t Components Type Visibility Attributes Name Initial integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes integer, public :: dim spatial dimension real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size complex(kind=pfdp), public, pointer :: wk_1d (:) complex(kind=pfdp), public, pointer :: wk_2d (:,:) complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) Type-Bound Procedures procedure( pf_fft_s_p ), public, deferred :: fft_setup subroutine pf_fft_s_p(this, grid_shape, dim, grid_size) Prototype Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) procedure( pf_fft_p ), public, deferred :: fft_destroy subroutine pf_fft_p(this) Prototype Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this procedure( pf_fft_p ), public, deferred :: fftf subroutine pf_fft_p(this) Prototype Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this procedure( pf_fft_p ), public, deferred :: fftb subroutine pf_fft_p(this) Prototype Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this generic, public :: fft => fft_1d, fft_2d, fft_3d, zfft_1d, zfft_2d, zfft_3d public subroutine fft_1d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) public subroutine fft_2d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) public subroutine fft_3d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) public subroutine zfft_1d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) public subroutine zfft_2d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) public subroutine zfft_3d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) generic, public :: ifft => ifft_1d, ifft_2d, ifft_3d, izfft_1d, izfft_2d, izfft_3d public subroutine ifft_1d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) real(kind=pfdp), intent(inout) :: g (:) public subroutine ifft_2d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) real(kind=pfdp), intent(inout) :: g (:,:) public subroutine ifft_3d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) real(kind=pfdp), intent(inout) :: g (:,:,:) public subroutine izfft_1d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(inout) :: g (:) public subroutine izfft_2d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(inout) :: g (:,:) public subroutine izfft_3d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(inout) :: g (:,:,:) generic, public :: conv => conv_1d, conv_2d, conv_3d public subroutine conv_1d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(inout) :: g (:) complex(kind=pfdp), intent(in) :: op (:) real(kind=pfdp), intent(inout) :: c (:) public subroutine conv_2d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(in) :: op (:,:) real(kind=pfdp), intent(inout) :: c (:,:) public subroutine conv_3d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) real(kind=pfdp), intent(inout) :: c (:,:,:) generic, public :: zconv => zconv_1d, zconv_2d, zconv_3d public subroutine zconv_1d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(in) :: op (:) complex(kind=pfdp), intent(inout) :: chat (:) public subroutine zconv_2d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(in) :: op (:,:) complex(kind=pfdp), intent(inout) :: chat (:,:) public subroutine zconv_3d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) complex(kind=pfdp), intent(inout) :: chat (:,:,:) generic, public :: get_wk_ptr => get_wk_ptr_1d, get_wk_ptr_2d, get_wk_ptr_3d public subroutine get_wk_ptr_1d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:) public subroutine get_wk_ptr_2d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:) public subroutine get_wk_ptr_3d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:,:) generic, public :: make_lap => make_lap_1d, make_lap_2d, make_lap_3d public subroutine make_lap_1d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) public subroutine make_lap_2d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) public subroutine make_lap_3d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) generic, public :: make_deriv => make_deriv_1d, make_deriv_2d, make_deriv_3d public subroutine make_deriv_1d (this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) public subroutine make_deriv_2d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir public subroutine make_deriv_3d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir generic, public :: restrict => restrict_1d, restrict_2d, restrict_3d, zrestrict_1d, zrestrict_2d, zrestrict_3d public subroutine restrict_1d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:) real(kind=pfdp), pointer :: yvec_c (:) public subroutine restrict_2d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:) real(kind=pfdp), pointer :: yvec_c (:,:) public subroutine restrict_3d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:,:) real(kind=pfdp), pointer :: yvec_c (:,:,:) public subroutine zrestrict_1d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:) complex(kind=pfdp), pointer :: yhat_c (:) public subroutine zrestrict_2d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:) complex(kind=pfdp), pointer :: yhat_c (:,:) public subroutine zrestrict_3d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:,:) complex(kind=pfdp), pointer :: yhat_c (:,:,:) Source Code type , abstract :: pf_fft_abs_t integer :: nx , ny , nz !! grid sizes integer :: dim !! spatial dimension real ( pfdp ) :: Lx , Ly , Lz !! domain size complex ( pfdp ), pointer :: wk_1d (:) ! work space complex ( pfdp ), pointer :: wk_2d (:,:) ! work space complex ( pfdp ), pointer :: wk_3d (:,:,:) ! work space contains procedure ( pf_fft_s_p ), deferred :: fft_setup procedure ( pf_fft_p ), deferred :: fft_destroy procedure ( pf_fft_p ), deferred :: fftf !  Forward FFT procedure ( pf_fft_p ), deferred :: fftb !  Inverse (backward)  FFT !  FFT procedure , private :: fft_1d , fft_2d , fft_3d , zfft_1d , zfft_2d , zfft_3d generic :: fft => fft_1d , fft_2d , fft_3d , zfft_1d , zfft_2d , zfft_3d !  Inverse FFT procedure , private :: ifft_1d , ifft_2d , ifft_3d , izfft_1d , izfft_2d , izfft_3d generic :: ifft => ifft_1d , ifft_2d , ifft_3d , izfft_1d , izfft_2d , izfft_3d !  Convolution in spectral space procedure , private :: conv_1d , conv_2d , conv_3d generic :: conv => conv_1d , conv_2d , conv_3d !  Complex convolution in real space procedure , private :: zconv_1d , zconv_2d , zconv_3d generic :: zconv => zconv_1d , zconv_2d , zconv_3d !  Convenience function to grab pointer to workspace procedure , private :: get_wk_ptr_1d , get_wk_ptr_2d , get_wk_ptr_3d generic :: get_wk_ptr => get_wk_ptr_1d , get_wk_ptr_2d , get_wk_ptr_3d !  Construct spectral Laplacian procedure , private :: make_lap_1d , make_lap_2d , make_lap_3d generic :: make_lap => make_lap_1d , make_lap_2d , make_lap_3d !  Construct spectral derivative procedure , private :: make_deriv_1d , make_deriv_2d , make_deriv_3d generic :: make_deriv => make_deriv_1d , make_deriv_2d , make_deriv_3d !  Restrict in spectral space procedure , private :: restrict_1d , restrict_2d , restrict_3d , zrestrict_1d , zrestrict_2d , zrestrict_3d generic :: restrict => restrict_1d , restrict_2d , restrict_3d , zrestrict_1d , zrestrict_2d , zrestrict_3d end type pf_fft_abs_t","tags":"","loc":"type/pf_fft_abs_t.html","title":"pf_fft_abs_t – LibPFASST "},{"text":"type, public, extends( pf_fft_abs_t ) :: pf_fft_t Variables and storage for FFTW Contents Variables nx ny nz dim Lx Ly Lz wk_1d wk_2d wk_3d ffftw ifftw normfact Type-Bound Procedures fft ifft conv zconv get_wk_ptr make_lap make_deriv restrict fft_setup fft_destroy fftf fftb interp Source Code pf_fft_t Components Type Visibility Attributes Name Initial integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes integer, public :: dim spatial dimension real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size complex(kind=pfdp), public, pointer :: wk_1d (:) complex(kind=pfdp), public, pointer :: wk_2d (:,:) complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) type(c_ptr), public :: ffftw fftw pointers type(c_ptr), public :: ifftw fftw pointers real(kind=pfdp), public :: normfact normalization factor Type-Bound Procedures generic, public :: fft => fft_1d, fft_2d, fft_3d, zfft_1d, zfft_2d, zfft_3d public subroutine fft_1d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) public subroutine fft_2d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) public subroutine fft_3d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) public subroutine zfft_1d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) public subroutine zfft_2d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) public subroutine zfft_3d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) generic, public :: ifft => ifft_1d, ifft_2d, ifft_3d, izfft_1d, izfft_2d, izfft_3d public subroutine ifft_1d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) real(kind=pfdp), intent(inout) :: g (:) public subroutine ifft_2d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) real(kind=pfdp), intent(inout) :: g (:,:) public subroutine ifft_3d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) real(kind=pfdp), intent(inout) :: g (:,:,:) public subroutine izfft_1d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(inout) :: g (:) public subroutine izfft_2d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(inout) :: g (:,:) public subroutine izfft_3d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(inout) :: g (:,:,:) generic, public :: conv => conv_1d, conv_2d, conv_3d public subroutine conv_1d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(inout) :: g (:) complex(kind=pfdp), intent(in) :: op (:) real(kind=pfdp), intent(inout) :: c (:) public subroutine conv_2d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(in) :: op (:,:) real(kind=pfdp), intent(inout) :: c (:,:) public subroutine conv_3d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) real(kind=pfdp), intent(inout) :: c (:,:,:) generic, public :: zconv => zconv_1d, zconv_2d, zconv_3d public subroutine zconv_1d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(in) :: op (:) complex(kind=pfdp), intent(inout) :: chat (:) public subroutine zconv_2d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(in) :: op (:,:) complex(kind=pfdp), intent(inout) :: chat (:,:) public subroutine zconv_3d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) complex(kind=pfdp), intent(inout) :: chat (:,:,:) generic, public :: get_wk_ptr => get_wk_ptr_1d, get_wk_ptr_2d, get_wk_ptr_3d public subroutine get_wk_ptr_1d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:) public subroutine get_wk_ptr_2d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:) public subroutine get_wk_ptr_3d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:,:) generic, public :: make_lap => make_lap_1d, make_lap_2d, make_lap_3d public subroutine make_lap_1d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) public subroutine make_lap_2d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) public subroutine make_lap_3d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) generic, public :: make_deriv => make_deriv_1d, make_deriv_2d, make_deriv_3d public subroutine make_deriv_1d (this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) public subroutine make_deriv_2d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir public subroutine make_deriv_3d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir generic, public :: restrict => restrict_1d, restrict_2d, restrict_3d, zrestrict_1d, zrestrict_2d, zrestrict_3d public subroutine restrict_1d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:) real(kind=pfdp), pointer :: yvec_c (:) public subroutine restrict_2d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:) real(kind=pfdp), pointer :: yvec_c (:,:) public subroutine restrict_3d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:,:) real(kind=pfdp), pointer :: yvec_c (:,:,:) public subroutine zrestrict_1d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:) complex(kind=pfdp), pointer :: yhat_c (:) public subroutine zrestrict_2d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:) complex(kind=pfdp), pointer :: yhat_c (:,:) public subroutine zrestrict_3d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:,:) complex(kind=pfdp), pointer :: yhat_c (:,:,:) procedure, public :: fft_setup public subroutine fft_setup (this, grid_shape, dim, grid_size) Initialize the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) procedure, public :: fft_destroy public subroutine fft_destroy (this) Destroy the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this procedure, public :: fftf public subroutine fftf (this) Routine to take foreward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this procedure, public :: fftb public subroutine fftb (this) Routine to take inverse or backward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this generic, public :: interp => interp_1d, interp_2d, interp_3d, zinterp_1d, zinterp_2d, zinterp_3d public subroutine interp_1d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:) public subroutine interp_2d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:) public subroutine interp_3d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:,:) public subroutine zinterp_1d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:) complex(kind=pfdp), pointer :: yhat_f (:) public subroutine zinterp_2d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:) complex(kind=pfdp), pointer :: yhat_f (:,:) public subroutine zinterp_3d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:,:) complex(kind=pfdp), pointer :: yhat_f (:,:,:) Source Code type , extends ( pf_fft_abs_t ) :: pf_fft_t type ( c_ptr ) :: ffftw , ifftw !! fftw pointers real ( pfdp ) :: normfact !! normalization factor contains procedure :: fft_setup procedure :: fft_destroy procedure :: fftf procedure :: fftb !  Interpolate in spectral space procedure , private :: interp_1d , interp_2d , interp_3d , zinterp_1d , zinterp_2d , zinterp_3d generic :: interp => interp_1d , interp_2d , interp_3d , zinterp_1d , zinterp_2d , zinterp_3d end type pf_fft_t","tags":"","loc":"type/pf_fft_t.html","title":"pf_fft_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_verlet_t Verlet SDC sweeper type, extends abstract sweeper Contents Variables npieces use_LUq whichQQ doLU Htol H0 Qmat QQmat Qver QQver Qtil QQtil DQver DQQver DQtil DQQtil bvec bbarvec dtsdc tsdc iqend rhs Type-Bound Procedures f_eval f_comp hamiltonian sweep initialize evaluate integrate residual spreadq0 evaluate_all destroy Source Code pf_verlet_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq integer, public :: whichQQ = 0 integer, public :: doLU real(kind=pfdp), public :: Htol real(kind=pfdp), public :: H0 real(kind=pfdp), public, ALLOCATABLE :: Qmat (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQmat (:,:) real(kind=pfdp), public, ALLOCATABLE :: Qver (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: Qtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: bvec (:) real(kind=pfdp), public, ALLOCATABLE :: bbarvec (:) real(kind=pfdp), public, allocatable :: dtsdc (:) real(kind=pfdp), public, allocatable :: tsdc (:) logical, public :: iqend class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval RHS function evaluations subroutine pf_f_eval_p(this, y, t, level_index, f) Prototype This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value procedure( pf_f_comp_p ), public, deferred :: f_comp Implicit solver subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Prototype Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate procedure( pf_hamiltonian_p ), public, deferred :: hamiltonian Hamiltonian function pf_hamiltonian_p(this, y, t, level_index) result(H) Prototype Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Variable real(kind=pfdp), intent(in) :: t Time of solve integer, intent(in) :: level_index Level index Return Value real(kind=pfdp) procedure, public :: sweep => verlet_sweep Set the generic functions public subroutine verlet_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform one SDC sweep on level level_index and set qend appropriately\n  Assign level pointer\n  Add the integral term Read more… Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => verlet_initialize public subroutine verlet_initialize (this, pf, level_index) Initialize integration matrices\n  Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: evaluate => verlet_evaluate public subroutine verlet_evaluate (this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => verlet_integrate public subroutine verlet_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Integrate (t_n to node)\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags procedure, public :: residual => verlet_residual public subroutine verlet_residual (this, pf, level_index, dt, flags) Compute residual (t_n to node)\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags procedure, public :: spreadq0 => verlet_spreadq0 public subroutine verlet_spreadq0 (this, pf, level_index, t0, flags, step) Spread the intial data for Verlet sweepers\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => verlet_evaluate_all public subroutine verlet_evaluate_all (this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => verlet_destroy public subroutine verlet_destroy (this, pf, level_index) Destroy Verlet sweeper matrices\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Source Code type , extends ( pf_sweeper_t ), abstract :: pf_verlet_t integer :: whichQQ = 0 integer :: doLU real ( pfdp ) :: Htol , H0 !  Matrices real ( pfdp ), ALLOCATABLE :: Qmat (:,:) !  Spectral matrix for v real ( pfdp ), ALLOCATABLE :: QQmat (:,:) !  Spectral matrix for x real ( pfdp ), ALLOCATABLE :: Qver (:,:) !  Verlet matrix for v (Trapezoid) real ( pfdp ), ALLOCATABLE :: QQver (:,:) !  Verlet matrix for x real ( pfdp ), ALLOCATABLE :: Qtil (:,:) !  Approximate matrix for v real ( pfdp ), ALLOCATABLE :: QQtil (:,:) !  Approximate matrix for x real ( pfdp ), ALLOCATABLE :: DQver (:,:) !  Qmat-Qver real ( pfdp ), ALLOCATABLE :: DQQver (:,:) !  QQmat-QQver real ( pfdp ), ALLOCATABLE :: DQtil (:,:) !  Qmat-Qtil real ( pfdp ), ALLOCATABLE :: DQQtil (:,:) !  QQmat-QQtil real ( pfdp ), ALLOCATABLE :: bvec (:) !  Quadrature rule for v real ( pfdp ), ALLOCATABLE :: bbarvec (:) !  Quadrature rule for x real ( pfdp ), allocatable :: dtsdc (:) !  SDC step sizes real ( pfdp ), allocatable :: tsdc (:) !  SDC times logical :: iqend !  Decide whether to set qend by another Picard class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver procedure ( pf_hamiltonian_p ), deferred :: hamiltonian !!  Hamiltonian !>  Set the generic functions procedure :: sweep => verlet_sweep procedure :: initialize => verlet_initialize procedure :: evaluate => verlet_evaluate procedure :: integrate => verlet_integrate procedure :: residual => verlet_residual procedure :: spreadq0 => verlet_spreadq0 procedure :: evaluate_all => verlet_evaluate_all procedure :: destroy => verlet_destroy end type pf_verlet_t","tags":"","loc":"type/pf_verlet_t.html","title":"pf_verlet_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_magpicard_t Magnus Picard sweeper type, extends abstract sweeper Contents Variables npieces use_LUq dtsdc magnus_order qtype dt commutator_coefs commutators omega time_ev_op Type-Bound Procedures sweep initialize evaluate integrate residual spreadq0 evaluate_all f_eval compute_single_commutators compute_omega propagate_solution destroy magpicard_destroy magpicard_initialize Source Code pf_magpicard_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: dtsdc (:) integer, public :: magnus_order integer, public :: qtype real(kind=pfdp), public :: dt real(kind=pfdp), public :: commutator_coefs (9,3,4) complex(kind=pfdp), public, allocatable :: commutators (:,:,:) class( pf_encap_t ), public, allocatable :: omega (:) class( pf_encap_t ), public, allocatable :: time_ev_op (:) Type-Bound Procedures procedure, public :: sweep => magpicard_sweep public subroutine magpicard_sweep (this, pf, level_index, t0, dt, nsweeps, flags) this loop not OMP'd because the deferred procs are OMP'd Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags procedure, public :: initialize => magpicard_initialize public subroutine magpicard_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize procedure, public :: evaluate => magpicard_evaluate public subroutine magpicard_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => magpicard_integrate public subroutine magpicard_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Compute SDC integral\n  fintSDC = \\int_{t_n}&#94;{t_m} fSDC dt Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => magpicard_residual public subroutine magpicard_residual (this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: spreadq0 => magpicard_spreadq0 public subroutine magpicard_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => magpicard_evaluate_all public subroutine magpicard_evaluate_all (this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, f) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f procedure( pf_compute_single_commutators_p ), public, deferred :: compute_single_commutators subroutine pf_compute_single_commutators_p(this, f) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: f (:,:) procedure( pf_compute_omega_p ), public, deferred :: compute_omega subroutine pf_compute_omega_p(this, omega, integrals, f, nodes, qmat, dt, this_node, coefs) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: integrals (:) class( pf_encap_t ), intent(inout) :: f (:,:) real(kind=pfdp), intent(in) :: nodes (:) real(kind=pfdp), intent(in) :: qmat (:,:) real(kind=pfdp), intent(in) :: dt integer, intent(in) :: this_node real(kind=pfdp), intent(in) :: coefs (:,:) procedure( pf_propagate_solution_p ), public, deferred :: propagate_solution subroutine pf_propagate_solution_p(this, sol_t0, sol_tn, omega, level) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: sol_t0 class( pf_encap_t ), intent(inout) :: sol_tn class( pf_encap_t ), intent(inout) :: omega integer, intent(in) :: level procedure, public :: destroy => magpicard_destroy public subroutine magpicard_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize procedure, public :: magpicard_destroy public subroutine magpicard_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize procedure, public :: magpicard_initialize public subroutine magpicard_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize Source Code type , extends ( pf_sweeper_t ), abstract :: pf_magpicard_t real ( pfdp ), allocatable :: dtsdc (:) integer :: magnus_order , qtype real ( pfdp ) :: dt , commutator_coefs ( 9 , 3 , 4 ) complex ( pfdp ), allocatable :: commutators (:,:,:) class ( pf_encap_t ), allocatable :: omega (:), time_ev_op (:) contains procedure :: sweep => magpicard_sweep procedure :: initialize => magpicard_initialize procedure :: evaluate => magpicard_evaluate procedure :: integrate => magpicard_integrate procedure :: residual => magpicard_residual procedure :: spreadq0 => magpicard_spreadq0 procedure :: evaluate_all => magpicard_evaluate_all procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_compute_single_commutators_p ), deferred :: compute_single_commutators procedure ( pf_compute_omega_p ), deferred :: compute_omega procedure ( pf_propagate_solution_p ), deferred :: propagate_solution procedure :: destroy => magpicard_destroy procedure :: magpicard_destroy procedure :: magpicard_initialize end type pf_magpicard_t","tags":"","loc":"type/pf_magpicard_t.html","title":"pf_magpicard_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_imk_t Implicit Munthe-Kaas Runge-Kutta sweeper type, extends abstract sweeper Contents Variables npieces use_LUq A QtilE QdiffE dtsdc tsdc bernoullis t0 dt qtype nterms Lax_pair use_SDC debug mkrk rk Type-Bound Procedures sweep initialize evaluate integrate residual spreadq0 evaluate_all destroy f_eval dexpinv propagate commutator_p Source Code pf_imk_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq class( pf_encap_t ), public, allocatable :: A (:) real(kind=pfdp), public, allocatable :: QtilE (:,:) Aproximate quadrature matric real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: dtsdc (:) SDC substep size real(kind=pfdp), public, allocatable :: tsdc (:) real(kind=pfdp), public :: bernoullis (20) Bernoulli numbers real(kind=pfdp), public :: t0 Time at beginning of time step real(kind=pfdp), public :: dt Time step size integer, public :: qtype integer, public :: nterms logical, public :: Lax_pair logical, public :: use_SDC logical, public :: debug logical, public :: mkrk logical, public :: rk Type-Bound Procedures procedure, public :: sweep => imk_sweep public subroutine imk_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform nsweep  sweeps on level  and set qend appropriately. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => imk_initialize public subroutine imk_initialize (this, pf, level_index) Assign explicit approximate quadrature rule\n  Make space for temporary variables Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize procedure, public :: evaluate => imk_evaluate public subroutine imk_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => imk_integrate public subroutine imk_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => imk_residual public subroutine imk_residual (this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: spreadq0 => imk_spreadq0 public subroutine imk_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => imk_evaluate_all public subroutine imk_evaluate_all (this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => imk_destroy public subroutine imk_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, f) Prototype Subroutine f_eval computes A(y,t) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer(kind=c_int), intent(in) :: level class( pf_encap_t ), intent(inout) :: f procedure( pf_dexpinv_p ), public, deferred :: dexpinv subroutine pf_dexpinv_p(this, a, omega, f) Prototype Subroutine dexpinv computes Om'=F=dexpinv_Om(A) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: f The result procedure( pf_propagate_p ), public, deferred :: propagate subroutine pf_propagate_p(this, q0, q) Prototype Subroutine propagate   computes y_m=expm(Om_m)y_0(expm(Om_m))-1 or (expm(Om_m))y_0 or Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: q0 class( pf_encap_t ), intent(inout) :: q procedure( pf_commutator_p ), public, deferred :: commutator_p subroutine pf_commutator_p(this, a, b, out, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: b class( pf_encap_t ), intent(inout) :: out integer, intent(in), optional :: flags Source Code type , extends ( pf_sweeper_t ), abstract :: pf_imk_t class ( pf_encap_t ), allocatable :: A (:) real ( pfdp ), allocatable :: QtilE (:,:) !!  Aproximate quadrature matric real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: dtsdc (:) !!  SDC substep size real ( pfdp ), allocatable :: tsdc (:) real ( pfdp ) :: bernoullis ( 20 ) !!  Bernoulli numbers real ( pfdp ) :: t0 !!  Time at beginning of time step real ( pfdp ) :: dt !!  Time step size integer :: qtype , nterms logical :: Lax_pair , use_SDC , debug , mkrk , rk contains procedure :: sweep => imk_sweep procedure :: initialize => imk_initialize procedure :: evaluate => imk_evaluate procedure :: integrate => imk_integrate procedure :: residual => imk_residual procedure :: spreadq0 => imk_spreadq0 procedure :: evaluate_all => imk_evaluate_all procedure :: destroy => imk_destroy procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_dexpinv_p ), deferred :: dexpinv procedure ( pf_propagate_p ), deferred :: propagate procedure ( pf_commutator_p ), deferred :: commutator_p end type pf_imk_t","tags":"","loc":"type/pf_imk_t.html","title":"pf_imk_t – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: zndarray_factory Factory for making zndarray Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code zndarray_factory Type-Bound Procedures procedure, public :: create_single => zndarray_create_single public subroutine zndarray_create_single (this, x, level, shape) Wrapper routine for allocation of a single zndarray type array Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => zndarray_create_array public subroutine zndarray_create_array (this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => zndarray_destroy_single public subroutine zndarray_destroy_single (this, x) Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x procedure, public :: destroy_array => zndarray_destroy_array public subroutine zndarray_destroy_array (this, x) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Source Code type , extends ( pf_factory_t ) :: zndarray_factory contains procedure :: create_single => zndarray_create_single procedure :: create_array => zndarray_create_array procedure :: destroy_single => zndarray_destroy_single procedure :: destroy_array => zndarray_destroy_array end type zndarray_factory","tags":"","loc":"type/zndarray_factory.html","title":"zndarray_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: zndarray Complex ndarray Contents Variables dim shape flatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint write_to_disk Source Code zndarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) complex(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => zndarray_setval public subroutine zndarray_setval (this, val, flags) Set solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => zndarray_copy public subroutine zndarray_copy (this, src, flags) Copy solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => zndarray_norm public function zndarray_norm (this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => zndarray_pack public subroutine zndarray_pack (this, z, flags) Pack solution q into a flat array. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => zndarray_unpack public subroutine zndarray_unpack (this, z, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => zndarray_axpy public subroutine zndarray_axpy (this, a, x, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => zndarray_eprint public subroutine zndarray_eprint (this, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this integer, intent(in), optional :: flags procedure, public :: write_to_disk public subroutine write_to_disk (this, filename) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this character(len=*), intent(in) :: filename Source Code type , extends ( pf_encap_t ) :: zndarray integer :: dim integer , allocatable :: shape (:) complex ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => zndarray_setval procedure :: copy => zndarray_copy procedure :: norm => zndarray_norm procedure :: pack => zndarray_pack procedure :: unpack => zndarray_unpack procedure :: axpy => zndarray_axpy procedure :: eprint => zndarray_eprint procedure :: write_to_disk end type zndarray","tags":"","loc":"type/zndarray.html","title":"zndarray – LibPFASST "},{"text":"type, public, bind(c) :: pf_state_t The type that holds the state of the system Contents Variables t0 dt nsteps pfblock iter step level finest_level hook proc sweep status pstatus itcnt skippedy mysteps Source Code pf_state_t Components Type Visibility Attributes Name Initial real(kind=pfdp), public :: t0 Time at beginning of this time step real(kind=pfdp), public :: dt Time step size integer, public :: nsteps total number of time steps integer, public :: pfblock pfasst block being worked on integer, public :: iter current iteration number integer, public :: step current time step number assigned to processor integer, public :: level which level is currently being operated on integer, public :: finest_level the current finest level (for variable depth V cycles) integer, public :: hook which hook integer, public :: proc which processor integer, public :: sweep sweep number integer, public :: status status (iterating, converged etc) integer, public :: pstatus previous rank's status integer, public :: itcnt total iterations by this processor integer, public :: skippedy skipped sweeps for state (for mixed integration) integer, public :: mysteps steps I did Source Code type , bind ( c ) :: pf_state_t real ( pfdp ) :: t0 !!  Time at beginning of this time step real ( pfdp ) :: dt !!  Time step size integer :: nsteps !! total number of time steps integer :: pfblock !! pfasst block being worked on integer :: iter !! current iteration number integer :: step !! current time step number assigned to processor integer :: level !! which level is currently being operated on integer :: finest_level !! the current finest level (for variable depth V cycles) integer :: hook !! which hook integer :: proc !! which processor integer :: sweep !! sweep number integer :: status !! status (iterating, converged etc) integer :: pstatus !! previous rank's status integer :: itcnt !! total iterations by this processor integer :: skippedy !! skipped sweeps for state (for mixed integration) integer :: mysteps !! steps I did end type pf_state_t","tags":"","loc":"type/pf_state_t.html","title":"pf_state_t – LibPFASST "},{"text":"type, public :: pf_hook_t Abstract hook type: hooks call diagnostic routines from various places in code Contents Variables proc Source Code pf_hook_t Components Type Visibility Attributes Name Initial procedure( pf_hook_p ), public, pointer, nopass :: proc Source Code type :: pf_hook_t procedure ( pf_hook_p ), pointer , nopass :: proc end type pf_hook_t","tags":"","loc":"type/pf_hook_t.html","title":"pf_hook_t – LibPFASST "},{"text":"type, public, abstract :: pf_sweeper_t The abstract SDC sweeper type (must be extended) Contents Variables npieces use_LUq Type-Bound Procedures sweep initialize evaluate integrate evaluate_all residual spreadq0 destroy Source Code pf_sweeper_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq Type-Bound Procedures procedure( pf_sweep_p ), public, deferred :: sweep subroutine pf_sweep_p(this, pf, level_index, t0, dt, nsweeps, flags) Prototype SDC sweeper subroutines Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags procedure( pf_initialize_p ), public, deferred :: initialize subroutine pf_initialize_p(this, pf, level_index) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure( pf_evaluate_p ), public, deferred :: evaluate subroutine pf_evaluate_p(this, pf, level_index, t, m, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_integrate_p ), public, deferred :: integrate subroutine pf_integrate_p(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt Time step size class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure( pf_evaluate_all_p ), public, deferred :: evaluate_all subroutine pf_evaluate_all_p(this, pf, level_index, t, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_residual_p ), public, deferred :: residual subroutine pf_residual_p(this, pf, level_index, dt, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step size integer, intent(in), optional :: flags procedure( pf_spreadq0_p ), public, deferred :: spreadq0 subroutine pf_spreadq0_p(this, pf, level_index, t0, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_destroy_sweeper_p ), public, deferred :: destroy subroutine pf_destroy_sweeper_p(this, pf, level_index) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Source Code type , abstract :: pf_sweeper_t integer :: npieces logical :: use_LUq contains procedure ( pf_sweep_p ), deferred :: sweep procedure ( pf_initialize_p ), deferred :: initialize procedure ( pf_evaluate_p ), deferred :: evaluate procedure ( pf_integrate_p ), deferred :: integrate procedure ( pf_evaluate_all_p ), deferred :: evaluate_all procedure ( pf_residual_p ), deferred :: residual procedure ( pf_spreadq0_p ), deferred :: spreadq0 procedure ( pf_destroy_sweeper_p ), deferred :: destroy end type pf_sweeper_t","tags":"","loc":"type/pf_sweeper_t.html","title":"pf_sweeper_t – LibPFASST "},{"text":"type, public, abstract :: pf_stepper_t The abstract time stepper type (must be extended) Contents Variables npieces order nsteps Type-Bound Procedures do_n_steps initialize destroy Source Code pf_stepper_t Components Type Visibility Attributes Name Initial integer, public :: npieces integer, public :: order integer, public :: nsteps Type-Bound Procedures procedure( pf_do_n_steps_p ), public, deferred :: do_n_steps subroutine pf_do_n_steps_p(this, pf, level_index, t0, q0, qend, big_dt, nsteps_rk) Prototype time stepper interfaces Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 class( pf_encap_t ), intent(in) :: q0 Starting value class( pf_encap_t ), intent(inout) :: qend Final value real(kind=pfdp), intent(in) :: big_dt Time step size integer, intent(in) :: nsteps_rk procedure( pf_initialize_stepper_p ), public, deferred :: initialize subroutine pf_initialize_stepper_p(this, pf, level_index) Prototype Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure( pf_destroy_stepper_p ), public, deferred :: destroy subroutine pf_destroy_stepper_p(this, pf, level_index) Prototype Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Source Code type , abstract :: pf_stepper_t integer :: npieces !  Number of pieces of rhs integer :: order !  Method order integer :: nsteps !  Number of steps per big time step contains procedure ( pf_do_n_steps_p ), deferred :: do_n_steps procedure ( pf_initialize_stepper_p ), deferred :: initialize procedure ( pf_destroy_stepper_p ), deferred :: destroy end type pf_stepper_t","tags":"","loc":"type/pf_stepper_t.html","title":"pf_stepper_t – LibPFASST "},{"text":"type, public, abstract :: pf_encap_t The abstract data type of the solution (must be extended) Contents Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code pf_encap_t Type-Bound Procedures procedure( pf_encap_setval_p ), public, deferred :: setval subroutine pf_encap_setval_p(this, val, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure( pf_encap_copy_p ), public, deferred :: copy subroutine pf_encap_copy_p(this, src, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure( pf_encap_norm_p ), public, deferred :: norm function pf_encap_norm_p(this, flags) result(norm) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure( pf_encap_pack_p ), public, deferred :: pack subroutine pf_encap_pack_p(this, z, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure( pf_encap_unpack_p ), public, deferred :: unpack subroutine pf_encap_unpack_p(this, z, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure( pf_encap_axpy_p ), public, deferred :: axpy subroutine pf_encap_axpy_p(this, a, x, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure( pf_encap_eprint_p ), public, deferred :: eprint subroutine pf_encap_eprint_p(this, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , abstract :: pf_encap_t contains procedure ( pf_encap_setval_p ), deferred :: setval procedure ( pf_encap_copy_p ), deferred :: copy procedure ( pf_encap_norm_p ), deferred :: norm procedure ( pf_encap_pack_p ), deferred :: pack procedure ( pf_encap_unpack_p ), deferred :: unpack procedure ( pf_encap_axpy_p ), deferred :: axpy procedure ( pf_encap_eprint_p ), deferred :: eprint end type pf_encap_t","tags":"","loc":"type/pf_encap_t.html","title":"pf_encap_t – LibPFASST "},{"text":"type, public, abstract :: pf_factory_t Abstract type for creation and destruction of objects Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code pf_factory_t Type-Bound Procedures procedure( pf_encap_create_single_p ), public, deferred :: create_single subroutine pf_encap_create_single_p(this, x, level, shape) Prototype encapsulation interfaces Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure( pf_encap_create_array_p ), public, deferred :: create_array subroutine pf_encap_create_array_p(this, x, n, level, shape) Prototype Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure( pf_encap_destroy_single_p ), public, deferred :: destroy_single subroutine pf_encap_destroy_single_p(this, x) Prototype Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x procedure( pf_encap_destroy_array_p ), public, deferred :: destroy_array subroutine pf_encap_destroy_array_p(this, x) Prototype Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Source Code type , abstract :: pf_factory_t contains procedure ( pf_encap_create_single_p ), deferred :: create_single procedure ( pf_encap_create_array_p ), deferred :: create_array procedure ( pf_encap_destroy_single_p ), deferred :: destroy_single procedure ( pf_encap_destroy_array_p ), deferred :: destroy_array end type pf_factory_t","tags":"","loc":"type/pf_factory_t.html","title":"pf_factory_t – LibPFASST "},{"text":"type, public, abstract :: pf_user_level_t The absract definition of level which is inherited  to include problem dependent stuff Contents Variables factory sweeper stepper Type-Bound Procedures restrict interpolate Source Code pf_user_level_t Components Type Visibility Attributes Name Initial class( pf_factory_t ), public, allocatable :: factory class( pf_sweeper_t ), public, allocatable :: sweeper class( pf_stepper_t ), public, allocatable :: stepper Type-Bound Procedures procedure( pf_transfer_p ), public, deferred :: restrict subroutine pf_transfer_p(this, f_lev, c_lev, f_vec, c_vec, t, flags) Prototype transfer interfaces used for restriction and interpolation Arguments Type Intent Optional Attributes Name class( pf_user_level_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: f_lev class( pf_level_t ), intent(inout) :: c_lev class( pf_encap_t ), intent(inout) :: f_vec class( pf_encap_t ), intent(inout) :: c_vec real(kind=pfdp), intent(in) :: t integer, intent(in), optional :: flags procedure( pf_transfer_p ), public, deferred :: interpolate subroutine pf_transfer_p(this, f_lev, c_lev, f_vec, c_vec, t, flags) Prototype transfer interfaces used for restriction and interpolation Arguments Type Intent Optional Attributes Name class( pf_user_level_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: f_lev class( pf_level_t ), intent(inout) :: c_lev class( pf_encap_t ), intent(inout) :: f_vec class( pf_encap_t ), intent(inout) :: c_vec real(kind=pfdp), intent(in) :: t integer, intent(in), optional :: flags Source Code type , abstract :: pf_user_level_t class ( pf_factory_t ), allocatable :: factory class ( pf_sweeper_t ), allocatable :: sweeper class ( pf_stepper_t ), allocatable :: stepper contains procedure ( pf_transfer_p ), deferred :: restrict procedure ( pf_transfer_p ), deferred :: interpolate end type pf_user_level_t","tags":"","loc":"type/pf_user_level_t.html","title":"pf_user_level_t – LibPFASST "},{"text":"type, public :: pf_sdcmats_t The type to store quadrature matrices Contents Variables nnodes qtype qnodes Qmat QmatFE QmatBE QmatTrap QmatVer QmatLU Smat use_proper_nodes use_composite_nodes use_no_left_q Source Code pf_sdcmats_t Components Type Visibility Attributes Name Initial integer, public :: nnodes integer, public :: qtype real(kind=pfdp), public, allocatable :: qnodes (:) real(kind=pfdp), public, allocatable :: Qmat (:,:) real(kind=pfdp), public, allocatable :: QmatFE (:,:) real(kind=pfdp), public, allocatable :: QmatBE (:,:) real(kind=pfdp), public, allocatable :: QmatTrap (:,:) real(kind=pfdp), public, allocatable :: QmatVer (:,:) real(kind=pfdp), public, allocatable :: QmatLU (:,:) real(kind=pfdp), public, allocatable :: Smat (:,:) logical, public :: use_proper_nodes = .false. logical, public :: use_composite_nodes = .false. logical, public :: use_no_left_q = .false. Source Code type :: pf_sdcmats_t integer :: nnodes !  Number of nodes integer :: qtype !  Type of nodes real ( pfdp ), allocatable :: qnodes (:) !  The quadrature nodes real ( pfdp ), allocatable :: Qmat (:,:) !  Collocation matrix real ( pfdp ), allocatable :: QmatFE (:,:) !  Forward Euler matrix real ( pfdp ), allocatable :: QmatBE (:,:) !  Backward Euler matrix real ( pfdp ), allocatable :: QmatTrap (:,:) ! Trapezoid rule matrix real ( pfdp ), allocatable :: QmatVer (:,:) ! Verlet Matrix real ( pfdp ), allocatable :: QmatLU (:,:) !  LU of Wmat real ( pfdp ), allocatable :: Smat (:,:) !  The node to node version of Qmat logical :: use_proper_nodes = . false . !  If true use gauss nodes in coarsening logical :: use_composite_nodes = . false . ! If true, finer nodes are composite logical :: use_no_left_q = . false . ! If true don't use left endpoint in rule end type pf_sdcmats_t","tags":"","loc":"type/pf_sdcmats_t.html","title":"pf_sdcmats_t – LibPFASST "},{"text":"type, public :: pf_level_t Data type of a PFASST level Contents Variables mpibuflen index nnodes nsteps_rk nsweeps nsweeps_pred Finterp error residual residual_rel ulevel send recv nodes rmat tmat nflags Q pQ R I Fflt Frkflt tauQ pFflt q0 q0_delta qend F pF interp_workspace_allocated cf_delta c_delta shape sdcmats allocated Source Code pf_level_t Components Type Visibility Attributes Name Initial integer, public :: mpibuflen = -1 size of solution in pfdp units integer, public :: index = -1 level number (1 is the coarsest) integer, public :: nnodes = -1 number of sdc nodes integer, public :: nsteps_rk = -1 number of rk steps to perform integer, public :: nsweeps = -1 number of sdc sweeps to perform integer, public :: nsweeps_pred = -1 number of coarse sdc sweeps to perform predictor in predictor logical, public :: Finterp = .false. interpolate functions instead of solutions real(kind=pfdp), public :: error holds the user defined error real(kind=pfdp), public :: residual holds the user defined residual real(kind=pfdp), public :: residual_rel holds the user defined relative residual (scaled by solution magnitude) class( pf_user_level_t ), public, allocatable :: ulevel user customized level info real(kind=pfdp), public, allocatable :: send (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: recv (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: nodes (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: rmat (:,:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: tmat (:,:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix integer, public, allocatable :: nflags (:) sdc node flags class( pf_encap_t ), public, allocatable :: Q (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: pQ (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: R (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: I (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: Fflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: Frkflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: tauQ (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: pFflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: q0 Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: q0_delta Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: qend Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, pointer :: F (:,:) Function  storage\n functions values at sdc nodes\n functions at sdc nodes, previous sweep class( pf_encap_t ), public, pointer :: pF (:,:) Function  storage\n functions values at sdc nodes\n functions at sdc nodes, previous sweep logical, public :: interp_workspace_allocated = .false. Interpolation and restriction data structures class( pf_encap_t ), public, allocatable :: cf_delta (:) class( pf_encap_t ), public, allocatable :: c_delta (:) integer, public, allocatable :: shape (:) user defined shape array type( pf_sdcmats_t ), public, allocatable :: sdcmats logical, public :: allocated = .false. Source Code type :: pf_level_t !  ===Mandatory level parameters=== integer :: mpibuflen = - 1 !! size of solution in pfdp units !  level parameters set by the pfasst_t values integer :: index = - 1 !! level number (1 is the coarsest) integer :: nnodes = - 1 !! number of sdc nodes integer :: nsteps_rk = - 1 !! number of rk steps to perform integer :: nsweeps = - 1 !! number of sdc sweeps to perform integer :: nsweeps_pred = - 1 !! number of coarse sdc sweeps to perform predictor in predictor logical :: Finterp = . false . !! interpolate functions instead of solutions !  Diagnostics real ( pfdp ) :: error !! holds the user defined error real ( pfdp ) :: residual !! holds the user defined residual real ( pfdp ) :: residual_rel !! holds the user defined relative residual (scaled by solution magnitude) class ( pf_user_level_t ), allocatable :: ulevel !!  user customized level info !>  Simple data storage at each level real ( pfdp ), allocatable :: & send (:), & !! send buffer recv (:), & !! recv buffer nodes (:), & !! list of SDC nodes rmat (:,:), & !! time restriction matrix tmat (:,:) !! time interpolation matrix integer , allocatable :: & nflags (:) !! sdc node flags !>  Solution variable storage class ( pf_encap_t ), allocatable :: & Q (:), & !! solution at sdc nodes pQ (:), & !! unknowns at sdc nodes, previous sweep R (:), & !! full residuals I (:), & !! 0 to node integrals Fflt (:), & !! functions values at sdc nodes (flat) Frkflt (:), & !!  Stage Function values tauQ (:), & !! fas correction in Q form pFflt (:), & !! functions at sdc nodes, previous sweep (flat) q0 , & !! initial condition q0_delta , & !! Space for interpolating q0, qend qend !! solution at end time !>  Function  storage class ( pf_encap_t ), pointer :: & F (:,:), & !! functions values at sdc nodes pF (:,:) !! functions at sdc nodes, previous sweep !>  Interpolation and restriction data structures logical :: interp_workspace_allocated = . false . class ( pf_encap_t ), allocatable :: & cf_delta (:), & ! delta fine in space and coarse in time c_delta (:) ! delta on the coarse level integer , allocatable :: shape (:) !! user defined shape array type ( pf_sdcmats_t ), allocatable :: sdcmats logical :: allocated = . false . end type pf_level_t","tags":"","loc":"type/pf_level_t.html","title":"pf_level_t – LibPFASST "},{"text":"type, public :: pf_comm_t Data type to define the communicator Contents Variables nproc comm recvreq sendreq statreq post recv recv_status send send_status wait broadcast Source Code pf_comm_t Components Type Visibility Attributes Name Initial integer, public :: nproc = -1 integer, public :: comm = -1 integer, public, pointer :: recvreq (:) integer, public, pointer :: sendreq (:) integer, public :: statreq procedure( pf_post_p ), public, pointer, nopass :: post Procedure interfaces procedure( pf_recv_p ), public, pointer, nopass :: recv procedure( pf_recv_status_p ), public, pointer, nopass :: recv_status procedure( pf_send_p ), public, pointer, nopass :: send procedure( pf_send_status_p ), public, pointer, nopass :: send_status procedure( pf_wait_p ), public, pointer, nopass :: wait procedure( pf_broadcast_p ), public, pointer, nopass :: broadcast Source Code type :: pf_comm_t integer :: nproc = - 1 ! total number of processors integer :: comm = - 1 ! communicator integer , pointer :: & recvreq (:), & ! receive requests (indexed by level) sendreq (:) ! send requests (indexed by level) integer :: statreq ! status send request ! fakie, needs modernization !type(c_ptr), pointer :: pfs(:)     ! pfasst objects (indexed by rank) !type(c_ptr), pointer :: pfpth(:,:) !> Procedure interfaces procedure ( pf_post_p ), pointer , nopass :: post procedure ( pf_recv_p ), pointer , nopass :: recv procedure ( pf_recv_status_p ), pointer , nopass :: recv_status procedure ( pf_send_p ), pointer , nopass :: send procedure ( pf_send_status_p ), pointer , nopass :: send_status procedure ( pf_wait_p ), pointer , nopass :: wait procedure ( pf_broadcast_p ), pointer , nopass :: broadcast end type pf_comm_t","tags":"","loc":"type/pf_comm_t.html","title":"pf_comm_t – LibPFASST "},{"text":"type, public :: pf_results_t Type for storing results for later output Contents Variables errors residuals nsteps niters nprocs p_index nblocks nsweeps rank level datpath destroy Source Code pf_results_t Components Type Visibility Attributes Name Initial real(kind=pfdp), public, allocatable :: errors (:,:,:) real(kind=pfdp), public, allocatable :: residuals (:,:,:) integer, public :: nsteps integer, public :: niters integer, public :: nprocs integer, public :: p_index integer, public :: nblocks integer, public :: nsweeps integer, public :: rank integer, public :: level character(len=128), public :: datpath procedure( pf_results_p ), public, pointer, nopass :: destroy Source Code type :: pf_results_t real ( pfdp ), allocatable :: errors (:,:,:) real ( pfdp ), allocatable :: residuals (:,:,:) !  (block,iter,sweep) integer :: nsteps integer :: niters integer :: nprocs integer :: p_index integer :: nblocks integer :: nsweeps integer :: rank integer :: level character ( len = 128 ) :: datpath procedure ( pf_results_p ), pointer , nopass :: destroy end type pf_results_t","tags":"","loc":"type/pf_results_t.html","title":"pf_results_t – LibPFASST "},{"text":"type, public :: pf_pfasst_t The main PFASST data type which includes pretty much everythingl Contents Variables nlevels niters qtype use_proper_nodes use_composite_nodes use_no_left_q nsweeps nsweeps_pred nnodes abs_res_tol rel_res_tol PFASST_pred pipeline_pred nsweeps_burn q0_style Vcycle Finterp use_LUq use_Sform taui0 use_rk_stepper nsteps_rk RK_pred debug save_residuals save_timings echo_timings save_errors rank state levels comm results hooks nhooks timers runtimes outdir Source Code pf_pfasst_t Components Type Visibility Attributes Name Initial integer, public :: nlevels = -1 === Mandatory pfasst parameters (must be set on command line or input file)  ===\n number of pfasst levels integer, public :: niters = 5 ===  Optional pfasst parameters ====\n number of PFASST iterations to do integer, public :: qtype = SDC_GAUSS_LOBATTO type of nodes logical, public :: use_proper_nodes = .false. logical, public :: use_composite_nodes = .false. logical, public :: use_no_left_q = .false. integer, public :: nsweeps (PF_MAXLEVS) = 1 number of sweeps at each levels integer, public :: nsweeps_pred (PF_MAXLEVS) = 1 number of sweeps during predictor integer, public :: nnodes (PF_MAXLEVS) = 3 number of nodes real(kind=pfdp), public :: abs_res_tol = 0.d0 absolute convergence tolerance real(kind=pfdp), public :: rel_res_tol = 0.d0 relative convergence tolerance logical, public :: PFASST_pred = .true. true if the PFASST type predictor is used logical, public :: pipeline_pred = .false. true if coarse sweeps after burn in are pipelined  (if nsweeps_pred>1 on coarse level) integer, public :: nsweeps_burn = 1 number of sdc sweeps to perform during coarse level burn in integer, public :: q0_style = 0 q0 can take 3 values\n  0:  Only the q0 at t=0 is valid  (default)\n  1:  The q0 at each processor is valid\n  2:  q0 and all nodes at each processor is valid logical, public :: Vcycle = .true. decides if Vcycles are done logical, public :: Finterp = .false. True if transfer functions operate on rhs logical, public :: use_LUq = .true. True if LU type implicit matrix is used logical, public :: use_Sform = .false. True if Qmat type of stepping is used integer, public :: taui0 = -999999 iteration cutoff for tau inclusion logical, public :: use_rk_stepper = .false. decides if RK steps are used instead of the sweeps integer, public :: nsteps_rk (PF_MAXLEVS) = 3 number of runge-kutta steps per time step logical, public :: RK_pred = .false. true if the coarse level is initialized with Runge-Kutta instead of PFASST logical, public :: debug = .false. If true, debug diagnostics are printed logical, public :: save_residuals = .false. If true, residuals are saved and output logical, public :: save_timings = .false. If true, timings are saved and  output logical, public :: echo_timings = .false. If true, timings are  output to screen logical, public :: save_errors = .false. If true, errors  are saved and output integer, public :: rank = -1 rank of current processor type( pf_state_t ), public, allocatable :: state pf objects\n  Describes where in the algorithm proc is type( pf_level_t ), public, allocatable :: levels (:) Holds the levels type( pf_comm_t ), public, pointer :: comm Points to communicator type( pf_results_t ), public, allocatable :: results (:) Hold results for each level type( pf_hook_t ), public, allocatable :: hooks (:,:,:) hooks variables\n  Holds the hooks integer, public, allocatable :: nhooks (:,:) Holds the number hooks double precision, public :: timers (100) = 0.0d0 timing variables double precision, public :: runtimes (100) = 0.0d0 character(len=256), public :: outdir output directory Source Code type :: pf_pfasst_t !> === Mandatory pfasst parameters (must be set on command line or input file)  === integer :: nlevels = - 1 !! number of pfasst levels !>  ===  Optional pfasst parameters ==== integer :: niters = 5 !! number of PFASST iterations to do integer :: qtype = SDC_GAUSS_LOBATTO !! type of nodes logical :: use_proper_nodes = . false . logical :: use_composite_nodes = . false . logical :: use_no_left_q = . false . ! --  level dependent parameters integer :: nsweeps ( PF_MAXLEVS ) = 1 !!  number of sweeps at each levels integer :: nsweeps_pred ( PF_MAXLEVS ) = 1 !!  number of sweeps during predictor integer :: nnodes ( PF_MAXLEVS ) = 3 !! number of nodes ! --  tolerances real ( pfdp ) :: abs_res_tol = 0.d0 !!  absolute convergence tolerance real ( pfdp ) :: rel_res_tol = 0.d0 !!  relative convergence tolerance ! --  predictor options  (should be set before pfasst_run is called) logical :: PFASST_pred = . true . !!  true if the PFASST type predictor is used logical :: pipeline_pred = . false . !!  true if coarse sweeps after burn in are pipelined  (if nsweeps_pred>1 on coarse level) integer :: nsweeps_burn = 1 !!  number of sdc sweeps to perform during coarse level burn in integer :: q0_style = 0 !!  q0 can take 3 values !!  0:  Only the q0 at t=0 is valid  (default) !!  1:  The q0 at each processor is valid !!  2:  q0 and all nodes at each processor is valid ! --  run options  (should be set before pfasst_run is called) logical :: Vcycle = . true . !!  decides if Vcycles are done logical :: Finterp = . false . !!  True if transfer functions operate on rhs logical :: use_LUq = . true . !!  True if LU type implicit matrix is used logical :: use_Sform = . false . !!  True if Qmat type of stepping is used integer :: taui0 = - 999999 !! iteration cutoff for tau inclusion ! -- RK and Parareal options logical :: use_rk_stepper = . false . !! decides if RK steps are used instead of the sweeps integer :: nsteps_rk ( PF_MAXLEVS ) = 3 !! number of runge-kutta steps per time step logical :: RK_pred = . false . !!  true if the coarse level is initialized with Runge-Kutta instead of PFASST ! -- misc logical :: debug = . false . !!  If true, debug diagnostics are printed ! -- controller for the results logical :: save_residuals = . false . !!  If true, residuals are saved and output logical :: save_timings = . false . !!  If true, timings are saved and  output logical :: echo_timings = . false . !!  If true, timings are  output to screen logical :: save_errors = . false . !!  If true, errors  are saved and output integer :: rank = - 1 !! rank of current processor !> pf objects type ( pf_state_t ), allocatable :: state !!  Describes where in the algorithm proc is type ( pf_level_t ), allocatable :: levels (:) !! Holds the levels type ( pf_comm_t ), pointer :: comm !! Points to communicator type ( pf_results_t ), allocatable :: results (:) !!  Hold results for each level !> hooks variables type ( pf_hook_t ), allocatable :: hooks (:,:,:) !!  Holds the hooks integer , allocatable :: nhooks (:,:) !!  Holds the number hooks !> timing variables double precision :: timers ( 100 ) = 0.0d0 double precision :: runtimes ( 100 ) = 0.0d0 !> output directory character ( len = 256 ) :: outdir end type pf_pfasst_t","tags":"","loc":"type/pf_pfasst_t.html","title":"pf_pfasst_t – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: zndsysarray_factory Type to create and destroy the arrays Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code zndsysarray_factory Type-Bound Procedures procedure, public :: create_single => zndsysarray_create_single public subroutine zndsysarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => zndsysarray_create_array public subroutine zndsysarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => zndsysarray_destroy_single public subroutine zndsysarray_destroy_single (this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x procedure, public :: destroy_array => zndsysarray_destroy_array public subroutine zndsysarray_destroy_array (this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Source Code type , extends ( pf_factory_t ) :: zndsysarray_factory contains procedure :: create_single => zndsysarray_create_single procedure :: create_array => zndsysarray_create_array procedure :: destroy_single => zndsysarray_destroy_single procedure :: destroy_array => zndsysarray_destroy_array end type zndsysarray_factory","tags":"","loc":"type/zndsysarray_factory.html","title":"zndsysarray_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: zndsysarray Type to extend the abstract encap and set procedure pointers Contents Variables dim ncomp ndof arr_shape flatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code zndsysarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public :: ncomp integer, public :: ndof integer, public, allocatable :: arr_shape (:) complex(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => zndsysarray_setval public subroutine zndsysarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => zndsysarray_copy public subroutine zndsysarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => zndsysarray_norm public function zndsysarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => zndsysarray_pack public subroutine zndsysarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => zndsysarray_unpack public subroutine zndsysarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => zndsysarray_axpy public subroutine zndsysarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => zndsysarray_eprint public subroutine zndsysarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , extends ( pf_encap_t ) :: zndsysarray integer :: dim !  The spatial dimension of each component in system integer :: ncomp !  The number of components in the system integer :: ndof !  The number of variables in each component integer , allocatable :: arr_shape (:) complex ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => zndsysarray_setval procedure :: copy => zndsysarray_copy procedure :: norm => zndsysarray_norm procedure :: pack => zndsysarray_pack procedure :: unpack => zndsysarray_unpack procedure :: axpy => zndsysarray_axpy procedure :: eprint => zndsysarray_eprint end type zndsysarray","tags":"","loc":"type/zndsysarray.html","title":"zndsysarray – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: ndsysarray_factory Type to create and destroy systems of N-dimensional arrays Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code ndsysarray_factory Type-Bound Procedures procedure, public :: create_single => ndsysarray_create_single public subroutine ndsysarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => ndsysarray_create_array public subroutine ndsysarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => ndsysarray_destroy_single public subroutine ndsysarray_destroy_single (this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x procedure, public :: destroy_array => ndsysarray_destroy_array public subroutine ndsysarray_destroy_array (this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Source Code type , extends ( pf_factory_t ) :: ndsysarray_factory contains procedure :: create_single => ndsysarray_create_single procedure :: create_array => ndsysarray_create_array procedure :: destroy_single => ndsysarray_destroy_single procedure :: destroy_array => ndsysarray_destroy_array end type ndsysarray_factory","tags":"","loc":"type/ndsysarray_factory.html","title":"ndsysarray_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: ndsysarray Type for system of  N-dimensional arrays,  extends the abstract encap type Contents Variables dim ncomp ndof arr_shape flatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code ndsysarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public :: ncomp integer, public :: ndof integer, public, allocatable :: arr_shape (:) real(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => ndsysarray_setval public subroutine ndsysarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => ndsysarray_copy public subroutine ndsysarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => ndsysarray_norm public function ndsysarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => ndsysarray_pack public subroutine ndsysarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => ndsysarray_unpack public subroutine ndsysarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => ndsysarray_axpy public subroutine ndsysarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => ndsysarray_eprint public subroutine ndsysarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , extends ( pf_encap_t ) :: ndsysarray integer :: dim !  The spatial dimension of each component in system integer :: ncomp !  The number of components in the system integer :: ndof !  The number of variables in each component integer , allocatable :: arr_shape (:) real ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => ndsysarray_setval procedure :: copy => ndsysarray_copy procedure :: norm => ndsysarray_norm procedure :: pack => ndsysarray_pack procedure :: unpack => ndsysarray_unpack procedure :: axpy => ndsysarray_axpy procedure :: eprint => ndsysarray_eprint end type ndsysarray","tags":"","loc":"type/ndsysarray.html","title":"ndsysarray – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_imexQ_oc_t IMEX SDC sweeper type for optimal control, extends abstract sweeper Contents Variables npieces use_LUq QtilE QtilI dtsdc QdiffE QdiffI explicit implicit rhs Type-Bound Procedures f_eval f_comp sweep initialize evaluate integrate residual evaluate_all spreadq0 destroy imexQ_oc_destroy imexQ_oc_initialize Source Code pf_imexQ_oc_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QtilE (:,:) Approximate explcit quadrature rule real(kind=pfdp), public, allocatable :: QtilI (:,:) Approximate implcit quadrature rule real(kind=pfdp), public, allocatable :: dtsdc (:) SDC step sizes real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: QdiffI (:,:) qmat-QtilI logical, public :: explicit = .true. Is there an explicit piece logical, public :: implicit = .true. Is there an implicit piece class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval RHS function evaluations subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Prototype Evaluae f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags integer, intent(in), optional :: idx integer, intent(in), optional :: step procedure( pf_f_comp_p ), public, deferred :: f_comp Implicit solver subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Prototype Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags procedure, public :: sweep => imexQ_oc_sweep Set the generic functions public subroutine imexQ_oc_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Loop over sweeps Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level this is real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => imexQ_oc_initialize public subroutine imexQ_oc_initialize (this, pf, level_index) Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: evaluate => imexQ_oc_evaluate public subroutine imexQ_oc_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => imexQ_oc_integrate public subroutine imexQ_oc_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => imexQ_oc_residual public subroutine imexQ_oc_residual (this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: evaluate_all => imexQ_oc_evaluate_all public subroutine imexQ_oc_evaluate_all (this, pf, level_index, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: spreadq0 => imexQ_oc_spreadq0 public subroutine imexQ_oc_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => imexQ_oc_destroy public subroutine imexQ_oc_destroy (this, pf, level_index) Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: imexQ_oc_destroy public subroutine imexQ_oc_destroy (this, pf, level_index) Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: imexQ_oc_initialize public subroutine imexQ_oc_initialize (this, pf, level_index) Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Source Code type , extends ( pf_sweeper_t ), abstract :: pf_imexQ_oc_t real ( pfdp ), allocatable :: QtilE (:,:) !!  Approximate explcit quadrature rule real ( pfdp ), allocatable :: QtilI (:,:) !!  Approximate implcit quadrature rule real ( pfdp ), allocatable :: dtsdc (:) !!  SDC step sizes real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: QdiffI (:,:) !!  qmat-QtilI logical :: explicit = . true . !!  Is there an explicit piece logical :: implicit = . true . !!  Is there an implicit piece class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver !>  Set the generic functions procedure :: sweep => imexQ_oc_sweep procedure :: initialize => imexQ_oc_initialize procedure :: evaluate => imexQ_oc_evaluate procedure :: integrate => imexQ_oc_integrate procedure :: residual => imexQ_oc_residual procedure :: evaluate_all => imexQ_oc_evaluate_all procedure :: spreadq0 => imexQ_oc_spreadq0 procedure :: destroy => imexQ_oc_destroy procedure :: imexQ_oc_destroy procedure :: imexQ_oc_initialize end type pf_imexQ_oc_t","tags":"","loc":"type/pf_imexq_oc_t.html","title":"pf_imexQ_oc_t – LibPFASST "},{"text":"type, public, extends( pf_fft_abs_t ) :: pf_fft_t Variables and storage for FFT Contents Variables nx ny nz dim Lx Ly Lz wk_1d wk_2d wk_3d lensavx lensavy lensavz normfact wsavex wsavey wsavez workhatx workhaty workhatz Type-Bound Procedures fft ifft conv zconv get_wk_ptr make_lap make_deriv restrict fft_setup fft_destroy fftf fftb interp Source Code pf_fft_t Components Type Visibility Attributes Name Initial integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes integer, public :: dim spatial dimension real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size complex(kind=pfdp), public, pointer :: wk_1d (:) complex(kind=pfdp), public, pointer :: wk_2d (:,:) complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) integer, public :: lensavx workspace lengths integer, public :: lensavy workspace lengths integer, public :: lensavz workspace lengths real(kind=pfdp), public :: normfact normalization factor real(kind=pfdp), public, allocatable :: wsavex (:) real(kind=pfdp), public, allocatable :: wsavey (:) real(kind=pfdp), public, allocatable :: wsavez (:) complex(kind=pfdp), public, pointer :: workhatx (:) complex(kind=pfdp), public, pointer :: workhaty (:) complex(kind=pfdp), public, pointer :: workhatz (:) Type-Bound Procedures generic, public :: fft => fft_1d, fft_2d, fft_3d, zfft_1d, zfft_2d, zfft_3d public subroutine fft_1d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) public subroutine fft_2d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) public subroutine fft_3d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) public subroutine zfft_1d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) public subroutine zfft_2d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) public subroutine zfft_3d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) generic, public :: ifft => ifft_1d, ifft_2d, ifft_3d, izfft_1d, izfft_2d, izfft_3d public subroutine ifft_1d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) real(kind=pfdp), intent(inout) :: g (:) public subroutine ifft_2d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) real(kind=pfdp), intent(inout) :: g (:,:) public subroutine ifft_3d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) real(kind=pfdp), intent(inout) :: g (:,:,:) public subroutine izfft_1d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(inout) :: g (:) public subroutine izfft_2d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(inout) :: g (:,:) public subroutine izfft_3d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(inout) :: g (:,:,:) generic, public :: conv => conv_1d, conv_2d, conv_3d public subroutine conv_1d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(inout) :: g (:) complex(kind=pfdp), intent(in) :: op (:) real(kind=pfdp), intent(inout) :: c (:) public subroutine conv_2d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(in) :: op (:,:) real(kind=pfdp), intent(inout) :: c (:,:) public subroutine conv_3d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) real(kind=pfdp), intent(inout) :: c (:,:,:) generic, public :: zconv => zconv_1d, zconv_2d, zconv_3d public subroutine zconv_1d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(in) :: op (:) complex(kind=pfdp), intent(inout) :: chat (:) public subroutine zconv_2d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(in) :: op (:,:) complex(kind=pfdp), intent(inout) :: chat (:,:) public subroutine zconv_3d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) complex(kind=pfdp), intent(inout) :: chat (:,:,:) generic, public :: get_wk_ptr => get_wk_ptr_1d, get_wk_ptr_2d, get_wk_ptr_3d public subroutine get_wk_ptr_1d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:) public subroutine get_wk_ptr_2d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:) public subroutine get_wk_ptr_3d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:,:) generic, public :: make_lap => make_lap_1d, make_lap_2d, make_lap_3d public subroutine make_lap_1d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) public subroutine make_lap_2d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) public subroutine make_lap_3d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) generic, public :: make_deriv => make_deriv_1d, make_deriv_2d, make_deriv_3d public subroutine make_deriv_1d (this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) public subroutine make_deriv_2d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir public subroutine make_deriv_3d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir generic, public :: restrict => restrict_1d, restrict_2d, restrict_3d, zrestrict_1d, zrestrict_2d, zrestrict_3d public subroutine restrict_1d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:) real(kind=pfdp), pointer :: yvec_c (:) public subroutine restrict_2d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:) real(kind=pfdp), pointer :: yvec_c (:,:) public subroutine restrict_3d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:,:) real(kind=pfdp), pointer :: yvec_c (:,:,:) public subroutine zrestrict_1d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:) complex(kind=pfdp), pointer :: yhat_c (:) public subroutine zrestrict_2d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:) complex(kind=pfdp), pointer :: yhat_c (:,:) public subroutine zrestrict_3d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:,:) complex(kind=pfdp), pointer :: yhat_c (:,:,:) procedure, public :: fft_setup public subroutine fft_setup (this, grid_shape, dim, grid_size) Allocate and initialize FFT structure Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) procedure, public :: fft_destroy public subroutine fft_destroy (this) Deallocate and destroy fft structures Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this procedure, public :: fftf public subroutine fftf (this) Forward fft call Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this procedure, public :: fftb public subroutine fftb (this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this generic, public :: interp => interp_1d, interp_2d, interp_3d, zinterp_1d, zinterp_2d, zinterp_3d public subroutine interp_1d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:) public subroutine interp_2d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:) public subroutine interp_3d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:,:) public subroutine zinterp_1d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:) complex(kind=pfdp), pointer :: yhat_f (:) public subroutine zinterp_2d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:) complex(kind=pfdp), pointer :: yhat_f (:,:) public subroutine zinterp_3d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:,:) complex(kind=pfdp), pointer :: yhat_f (:,:,:) Source Code type , extends ( pf_fft_abs_t ) :: pf_fft_t integer :: lensavx , lensavy , lensavz !! workspace lengths real ( pfdp ) :: normfact !! normalization factor real ( pfdp ), allocatable :: wsavex (:) ! work space real ( pfdp ), allocatable :: wsavey (:) ! work space real ( pfdp ), allocatable :: wsavez (:) ! work space complex ( pfdp ), pointer :: workhatx (:) ! work space complex ( pfdp ), pointer :: workhaty (:) ! work space complex ( pfdp ), pointer :: workhatz (:) ! work space contains procedure :: fft_setup procedure :: fft_destroy procedure :: fftf !  Forward FFT procedure :: fftb !  Inverse (backward)  FFT !  Interpolate in spectral space procedure , private :: interp_1d , interp_2d , interp_3d , zinterp_1d , zinterp_2d , zinterp_3d generic :: interp => interp_1d , interp_2d , interp_3d , zinterp_1d , zinterp_2d , zinterp_3d end type pf_fft_t","tags":"","loc":"type/pf_fft_t~2.html","title":"pf_fft_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_amisdc_t Asynchronous multi-implicit sweeper type (old style) Contents Variables npieces use_LUq SdiffE SdiffI Type-Bound Procedures spreadq0 f1eval f2eval f2comp f3eval f3comp sweep initialize evaluate integrate residual evaluate_all destroy amisdc_destroy Source Code pf_amisdc_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure( pf_spreadq0_p ), public, deferred :: spreadq0 subroutine pf_spreadq0_p(this, pf, level_index, t0, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_f1eval_p ), public, deferred :: f1eval subroutine pf_f1eval_p(this, y, t, level, f1) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f1 procedure( pf_f2eval_p ), public, deferred :: f2eval subroutine pf_f2eval_p(this, y, t, level, f2) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 procedure( pf_f2comp_p ), public, deferred :: f2comp subroutine pf_f2comp_p(this, y, t, dt, rhs, level, f2) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 procedure( pf_f3eval_p ), public, deferred :: f3eval subroutine pf_f3eval_p(this, y, t, level, f3) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 procedure( pf_f3comp_p ), public, deferred :: f3comp subroutine pf_f3comp_p(this, y, t, dt, rhs, level, f3) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 procedure, public :: sweep => amisdc_sweep public subroutine amisdc_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: initialize => amisdc_initialize public subroutine amisdc_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => amisdc_evaluate public subroutine amisdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m procedure, public :: integrate => amisdc_integrate public subroutine amisdc_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) procedure, public :: residual => amisdc_residual public subroutine amisdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt procedure, public :: evaluate_all => amisdc_evaluate_all public subroutine amisdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) procedure, public :: destroy => amisdc_destroy public subroutine amisdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: amisdc_destroy public subroutine amisdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_amisdc_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f1eval_p ), deferred :: f1eval procedure ( pf_f2eval_p ), deferred :: f2eval procedure ( pf_f2comp_p ), deferred :: f2comp procedure ( pf_f3eval_p ), deferred :: f3eval procedure ( pf_f3comp_p ), deferred :: f3comp procedure :: sweep => amisdc_sweep procedure :: initialize => amisdc_initialize procedure :: evaluate => amisdc_evaluate procedure :: integrate => amisdc_integrate procedure :: residual => amisdc_residual procedure :: evaluate_all => amisdc_evaluate_all procedure :: destroy => amisdc_destroy procedure :: amisdc_destroy end type pf_amisdc_t","tags":"","loc":"type/pf_amisdc_t.html","title":"pf_amisdc_t – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: ndarray_factory Type to create and destroy N-dimenstional arrays Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code ndarray_factory Type-Bound Procedures procedure, public :: create_single => ndarray_create_single public subroutine ndarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => ndarray_create_array public subroutine ndarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => ndarray_destroy_single public subroutine ndarray_destroy_single (this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x procedure, public :: destroy_array => ndarray_destroy_array public subroutine ndarray_destroy_array (this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Source Code type , extends ( pf_factory_t ) :: ndarray_factory contains procedure :: create_single => ndarray_create_single procedure :: create_array => ndarray_create_array procedure :: destroy_single => ndarray_destroy_single procedure :: destroy_array => ndarray_destroy_array end type ndarray_factory","tags":"","loc":"type/ndarray_factory.html","title":"ndarray_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: ndarray N-dimensional array type,  extends the abstract encap type Contents Variables dim shape flatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code ndarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) real(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => ndarray_setval public subroutine ndarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => ndarray_copy public subroutine ndarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => ndarray_norm public function ndarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => ndarray_pack public subroutine ndarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => ndarray_unpack public subroutine ndarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => ndarray_axpy public subroutine ndarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => ndarray_eprint public subroutine ndarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , extends ( pf_encap_t ) :: ndarray integer :: dim integer , allocatable :: shape (:) real ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => ndarray_setval procedure :: copy => ndarray_copy procedure :: norm => ndarray_norm procedure :: pack => ndarray_pack procedure :: unpack => ndarray_unpack procedure :: axpy => ndarray_axpy procedure :: eprint => ndarray_eprint end type ndarray","tags":"","loc":"type/ndarray.html","title":"ndarray – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_misdcQ_oc_t Multi-implicit SDC sweeper type for optimal control, extends abstract sweeper Contents Variables npieces use_LUq QdiffE QdiffI QtilE QtilI dtsdc I3 rhs Type-Bound Procedures f_eval f_comp sweep initialize integrate residual spreadq0 evaluate_all evaluate destroy misdcQ_oc_destroy misdcQ_oc_initialize Source Code pf_misdcQ_oc_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) class( pf_encap_t ), public, allocatable :: I3 (:) class( pf_encap_t ), public, allocatable :: rhs Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Prototype This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two\n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward integer, intent(in), optional :: idx index of quadrature node integer, intent(in), optional :: step time step for sequential version procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Prototype Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward procedure, public :: sweep => misdcQ_oc_sweep public subroutine misdcQ_oc_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags procedure, public :: initialize => misdcQ_oc_initialize public subroutine misdcQ_oc_initialize (this, pf, level_index) Make space for rhs Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: integrate => misdcQ_oc_integrate public subroutine misdcQ_oc_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => misdcQ_oc_residual public subroutine misdcQ_oc_residual (this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: spreadq0 => misdcQ_oc_spreadq0 public subroutine misdcQ_oc_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => misdcQ_oc_evaluate_all public subroutine misdcQ_oc_evaluate_all (this, pf, level_index, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate => misdcQ_oc_evaluate public subroutine misdcQ_oc_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => misdcQ_oc_destroy public subroutine misdcQ_oc_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: misdcQ_oc_destroy public subroutine misdcQ_oc_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: misdcQ_oc_initialize public subroutine misdcQ_oc_initialize (this, pf, level_index) Make space for rhs Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Source Code type , extends ( pf_sweeper_t ), abstract :: pf_misdcQ_oc_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) real ( pfdp ), allocatable :: dtsdc (:) class ( pf_encap_t ), allocatable :: I3 (:) class ( pf_encap_t ), allocatable :: rhs contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdcQ_oc_sweep procedure :: initialize => misdcQ_oc_initialize procedure :: integrate => misdcQ_oc_integrate procedure :: residual => misdcQ_oc_residual procedure :: spreadq0 => misdcQ_oc_spreadq0 procedure :: evaluate_all => misdcQ_oc_evaluate_all procedure :: evaluate => misdcQ_oc_evaluate procedure :: destroy => misdcQ_oc_destroy procedure :: misdcQ_oc_destroy procedure :: misdcQ_oc_initialize end type pf_misdcQ_oc_t","tags":"","loc":"type/pf_misdcq_oc_t.html","title":"pf_misdcQ_oc_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_exp_t Exponential SDC sweeper type, extends abstract pf_sweeper_t Contents Variables npieces use_LUq w nodes eta b f_old newF use_phib Type-Bound Procedures f_eval phib swpPhib resPhib initialize sweep evaluate integrate residual spreadq0 evaluate_all destroy exp_destroy exp_initialize Source Code pf_exp_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: w (:,:,:) real(kind=pfdp), public, allocatable :: nodes (:) real(kind=pfdp), public, allocatable :: eta (:) class( pf_encap_t ), public, allocatable :: b (:) class( pf_encap_t ), public, allocatable :: f_old (:) class( pf_encap_t ), public, allocatable :: newF logical, public :: use_phib = .true. Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, n) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n procedure( pf_phib ), public, deferred :: phib subroutine pf_phib(this, t, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure( pf_swpPhib ), public, deferred :: swpPhib subroutine pf_swpPhib(this, j, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure( pf_resPhib ), public, deferred :: resPhib subroutine pf_resPhib(this, j, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure, public :: initialize => exp_initialize public subroutine exp_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: sweep => exp_sweep public subroutine exp_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: evaluate => exp_evaluate public subroutine exp_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => exp_integrate public subroutine exp_integrate (this, pf, level_index, qSDC, fSDC, dt, fintsdc, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags procedure, public :: residual => exp_residual public subroutine exp_residual (this, pf, level_index, dt, flags) Compute the integral of F from t_n to t_m at each node Read more… Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: spreadq0 => exp_spreadq0 public subroutine exp_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => exp_evaluate_all public subroutine exp_evaluate_all (this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => exp_destroy public subroutine exp_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: exp_destroy public subroutine exp_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index procedure, public :: exp_initialize public subroutine exp_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Source Code type , extends ( pf_sweeper_t ), abstract :: pf_exp_t real ( pfdp ), allocatable :: w (:,:,:) ! weights real ( pfdp ), allocatable :: nodes (:) ! nodes real ( pfdp ), allocatable :: eta (:) ! normalized substeps (on interval [0, 1]) class ( pf_encap_t ), allocatable :: b (:) ! scratch space for computing nonlinear derivatives class ( pf_encap_t ), allocatable :: f_old (:) ! scratch space for storing nonlinear terms class ( pf_encap_t ), allocatable :: newF ! scratch space for storing new function evaluations LOGICAL :: use_phib = . true . ! if TRUE calls phib otherwise calls swpPhib and resPhib (reset in derived sweeper) contains ! specialized procedures for exponential integrator procedure ( pf_f_eval_p ), deferred :: f_eval ! computes nonlinear term in equation procedure ( pf_phib ), deferred :: phib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i procedure ( pf_swpPhib ), deferred :: swpPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n,j} for j = 1, ... q - 1 procedure ( pf_resPhib ), deferred :: resPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n} for j = 1, ... q - 1 procedure , private :: weights procedure , private :: LocalDerivsAtNode ! generic functions procedure :: initialize => exp_initialize procedure :: sweep => exp_sweep procedure :: evaluate => exp_evaluate procedure :: integrate => exp_integrate procedure :: residual => exp_residual procedure :: spreadq0 => exp_spreadq0 procedure :: evaluate_all => exp_evaluate_all procedure :: destroy => exp_destroy ! functions that can be accessed directly by types that inherit pf_exp_t procedure :: exp_destroy procedure :: exp_initialize end type pf_exp_t","tags":"","loc":"type/pf_exp_t.html","title":"pf_exp_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_amisdc_t ) :: pf_amisdcQ_t Asynchronous multi-implicit sweeper type Contents Variables npieces use_LUq SdiffE SdiffI QdiffE QdiffI QtilE QtilI use_LUq_ Type-Bound Procedures spreadq0 f1eval f2eval f2comp f3eval f3comp evaluate residual evaluate_all amisdc_destroy sweep initialize integrate destroy sweep_coupled_implicit_terms sweep_decoupled_implicit_terms amisdcQ_destroy amisdcQ_initialize Source Code pf_amisdcQ_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) logical, public :: use_LUq_ = .true. Type-Bound Procedures procedure( pf_spreadq0_p ), public, deferred :: spreadq0 subroutine pf_spreadq0_p(this, pf, level_index, t0, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_f1eval_p ), public, deferred :: f1eval subroutine pf_f1eval_p(this, y, t, level, f1) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f1 procedure( pf_f2eval_p ), public, deferred :: f2eval subroutine pf_f2eval_p(this, y, t, level, f2) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 procedure( pf_f2comp_p ), public, deferred :: f2comp subroutine pf_f2comp_p(this, y, t, dt, rhs, level, f2) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 procedure( pf_f3eval_p ), public, deferred :: f3eval subroutine pf_f3eval_p(this, y, t, level, f3) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 procedure( pf_f3comp_p ), public, deferred :: f3comp subroutine pf_f3comp_p(this, y, t, dt, rhs, level, f3) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 procedure, public :: evaluate => amisdc_evaluate public subroutine amisdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m procedure, public :: residual => amisdc_residual public subroutine amisdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt procedure, public :: evaluate_all => amisdc_evaluate_all public subroutine amisdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) procedure, public :: amisdc_destroy public subroutine amisdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: sweep => amisdcQ_sweep public subroutine amisdcQ_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: initialize => amisdcQ_initialize public subroutine amisdcQ_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev procedure, public :: integrate => amisdcQ_integrate public subroutine amisdcQ_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(in) :: lev class(pf_encap_t), intent(in) :: qSDC (:) class(pf_encap_t), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class(pf_encap_t), intent(inout) :: fintSDC (:) procedure, public :: destroy => amisdcQ_destroy public subroutine amisdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev procedure, public :: sweep_coupled_implicit_terms public subroutine sweep_coupled_implicit_terms (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: sweep_decoupled_implicit_terms public subroutine sweep_decoupled_implicit_terms (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: amisdcQ_destroy public subroutine amisdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev procedure, public :: amisdcQ_initialize public subroutine amisdcQ_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev Source Code type , extends ( pf_amisdc_t ), abstract :: pf_amisdcQ_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) logical :: use_LUq_ = . true . contains procedure :: sweep => amisdcQ_sweep procedure :: initialize => amisdcQ_initialize procedure :: integrate => amisdcQ_integrate procedure :: destroy => amisdcQ_destroy procedure :: sweep_coupled_implicit_terms procedure :: sweep_decoupled_implicit_terms procedure :: amisdcQ_destroy procedure :: amisdcQ_initialize end type pf_amisdcQ_t","tags":"","loc":"type/pf_amisdcq_t.html","title":"pf_amisdcQ_t – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: ndarray_oc_factory Type to create and destroy N-dimenstional arrays for optimal control Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code ndarray_oc_factory Type-Bound Procedures procedure, public :: create_single => ndarray_oc_create_single public subroutine ndarray_oc_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => ndarray_oc_create_array public subroutine ndarray_oc_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => ndarray_oc_destroy_single public subroutine ndarray_oc_destroy_single (this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x procedure, public :: destroy_array => ndarray_oc_destroy_array public subroutine ndarray_oc_destroy_array (this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Source Code type , extends ( pf_factory_t ) :: ndarray_oc_factory contains procedure :: create_single => ndarray_oc_create_single procedure :: create_array => ndarray_oc_create_array procedure :: destroy_single => ndarray_oc_destroy_single procedure :: destroy_array => ndarray_oc_destroy_array end type ndarray_oc_factory","tags":"","loc":"type/ndarray_oc_factory.html","title":"ndarray_oc_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: ndarray_oc N-dimensional array type for optimal control,  extends the abstract encap type Contents Variables dim shape yflatarray pflatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code ndarray_oc Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) real(kind=pfdp), public, allocatable :: yflatarray (:) real(kind=pfdp), public, allocatable :: pflatarray (:) Type-Bound Procedures procedure, public :: setval => ndarray_oc_setval public subroutine ndarray_oc_setval (this, val, flags) Subroutine to set array to a scalar  value. Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => ndarray_oc_copy public subroutine ndarray_oc_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => ndarray_oc_norm public function ndarray_oc_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => ndarray_oc_pack public subroutine ndarray_oc_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => ndarray_oc_unpack public subroutine ndarray_oc_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => ndarray_oc_axpy public subroutine ndarray_oc_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => ndarray_oc_eprint public subroutine ndarray_oc_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , extends ( pf_encap_t ) :: ndarray_oc integer :: dim integer , allocatable :: shape (:) real ( pfdp ), allocatable :: yflatarray (:) real ( pfdp ), allocatable :: pflatarray (:) contains procedure :: setval => ndarray_oc_setval procedure :: copy => ndarray_oc_copy procedure :: norm => ndarray_oc_norm procedure :: pack => ndarray_oc_pack procedure :: unpack => ndarray_oc_unpack procedure :: axpy => ndarray_oc_axpy procedure :: eprint => ndarray_oc_eprint end type ndarray_oc","tags":"","loc":"type/ndarray_oc.html","title":"ndarray_oc – LibPFASST "},{"text":"subroutine CFFTB1(N, C, CH, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: CH real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/cfftb1.html","title":"CFFTB1 – LibPFASST"},{"text":"subroutine CFFTF1(N, C, CH, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: CH real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/cfftf1.html","title":"CFFTF1 – LibPFASST"},{"text":"subroutine CFFTI1(N, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/cffti1.html","title":"CFFTI1 – LibPFASST"},{"text":"subroutine PASSB2(IDO, L1, CC, CH, WA1) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 Contents None","tags":"","loc":"proc/passb2.html","title":"PASSB2 – LibPFASST"},{"text":"subroutine PASSB3(IDO, L1, CC, CH, WA1, WA2) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 Contents None","tags":"","loc":"proc/passb3.html","title":"PASSB3 – LibPFASST"},{"text":"subroutine PASSB4(IDO, L1, CC, CH, WA1, WA2, WA3) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 Contents None","tags":"","loc":"proc/passb4.html","title":"PASSB4 – LibPFASST"},{"text":"subroutine PASSB5(IDO, L1, CC, CH, WA1, WA2, WA3, WA4) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 real :: WA4 Contents None","tags":"","loc":"proc/passb5.html","title":"PASSB5 – LibPFASST"},{"text":"subroutine PASSB(NAC, IDO, IP, L1, IDL1, CC, C1, C2, CH, CH2, WA) Arguments Type Intent Optional Attributes Name integer :: NAC integer :: IDO integer :: IP integer :: L1 integer :: IDL1 real :: CC real :: C1 real :: C2 real :: CH real :: CH2 real :: WA Contents None","tags":"","loc":"proc/passb.html","title":"PASSB – LibPFASST"},{"text":"subroutine PASSF2(IDO, L1, CC, CH, WA1) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 Contents None","tags":"","loc":"proc/passf2.html","title":"PASSF2 – LibPFASST"},{"text":"subroutine PASSF3(IDO, L1, CC, CH, WA1, WA2) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 Contents None","tags":"","loc":"proc/passf3.html","title":"PASSF3 – LibPFASST"},{"text":"subroutine PASSF4(IDO, L1, CC, CH, WA1, WA2, WA3) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 Contents None","tags":"","loc":"proc/passf4.html","title":"PASSF4 – LibPFASST"},{"text":"subroutine PASSF5(IDO, L1, CC, CH, WA1, WA2, WA3, WA4) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 real :: WA4 Contents None","tags":"","loc":"proc/passf5.html","title":"PASSF5 – LibPFASST"},{"text":"subroutine PASSF(NAC, IDO, IP, L1, IDL1, CC, C1, C2, CH, CH2, WA) Arguments Type Intent Optional Attributes Name integer :: NAC integer :: IDO integer :: IP integer :: L1 integer :: IDL1 real :: CC real :: C1 real :: C2 real :: CH real :: CH2 real :: WA Contents None","tags":"","loc":"proc/passf.html","title":"PASSF – LibPFASST"},{"text":"subroutine RADB2(IDO, L1, CC, CH, WA1) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 Contents None","tags":"","loc":"proc/radb2.html","title":"RADB2 – LibPFASST"},{"text":"subroutine RADB3(IDO, L1, CC, CH, WA1, WA2) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 Contents None","tags":"","loc":"proc/radb3.html","title":"RADB3 – LibPFASST"},{"text":"subroutine RADB4(IDO, L1, CC, CH, WA1, WA2, WA3) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 Contents None","tags":"","loc":"proc/radb4.html","title":"RADB4 – LibPFASST"},{"text":"subroutine RADB5(IDO, L1, CC, CH, WA1, WA2, WA3, WA4) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 real :: WA4 Contents None","tags":"","loc":"proc/radb5.html","title":"RADB5 – LibPFASST"},{"text":"subroutine RADBG(IDO, IP, L1, IDL1, CC, C1, C2, CH, CH2, WA) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: IP integer :: L1 integer :: IDL1 real :: CC real :: C1 real :: C2 real :: CH real :: CH2 real :: WA Contents None","tags":"","loc":"proc/radbg.html","title":"RADBG – LibPFASST"},{"text":"subroutine RADF2(IDO, L1, CC, CH, WA1) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 Contents None","tags":"","loc":"proc/radf2.html","title":"RADF2 – LibPFASST"},{"text":"subroutine RADF3(IDO, L1, CC, CH, WA1, WA2) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 Contents None","tags":"","loc":"proc/radf3.html","title":"RADF3 – LibPFASST"},{"text":"subroutine RADF4(IDO, L1, CC, CH, WA1, WA2, WA3) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 Contents None","tags":"","loc":"proc/radf4.html","title":"RADF4 – LibPFASST"},{"text":"subroutine RADF5(IDO, L1, CC, CH, WA1, WA2, WA3, WA4) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 real :: WA4 Contents None","tags":"","loc":"proc/radf5.html","title":"RADF5 – LibPFASST"},{"text":"subroutine RADFG(IDO, IP, L1, IDL1, CC, C1, C2, CH, CH2, WA) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: IP integer :: L1 integer :: IDL1 real :: CC real :: C1 real :: C2 real :: CH real :: CH2 real :: WA Contents None","tags":"","loc":"proc/radfg.html","title":"RADFG – LibPFASST"},{"text":"subroutine RFFTB1(N, C, CH, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: CH real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/rfftb1.html","title":"RFFTB1 – LibPFASST"},{"text":"subroutine RFFTF1(N, C, CH, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: CH real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/rfftf1.html","title":"RFFTF1 – LibPFASST"},{"text":"subroutine RFFTI1(N, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/rffti1.html","title":"RFFTI1 – LibPFASST"},{"text":"subroutine ZFFTB(N, C, WSAVE) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: WSAVE Contents None","tags":"","loc":"proc/zfftb.html","title":"ZFFTB – LibPFASST"},{"text":"subroutine ZFFTF(N, C, WSAVE) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: WSAVE Contents None","tags":"","loc":"proc/zfftf.html","title":"ZFFTF – LibPFASST"},{"text":"subroutine ZFFTI(N, WSAVE) Arguments Type Intent Optional Attributes Name integer :: N real :: WSAVE Contents None","tags":"","loc":"proc/zffti.html","title":"ZFFTI – LibPFASST"},{"text":"public subroutine ark_do_n_steps(this, pf, level_index, t0, q0, qend, big_dt, nsteps_rk) Uses pf_mod_timer pf_mod_hooks Perform N steps of ark on level level_index and set qend appropriately.\n Assign pointer to appropriate level Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Level of the index to step on real(kind=pfdp), intent(in) :: t0 Time at start of time interval class( pf_encap_t ), intent(in) :: q0 Starting value class( pf_encap_t ), intent(inout) :: qend Final value real(kind=pfdp), intent(in) :: big_dt Size of time interval to integrato on integer, intent(in) :: nsteps_rk Number of steps to use Contents Source Code ark_do_n_steps Source Code subroutine ark_do_n_steps ( this , pf , level_index , t0 , q0 , qend , big_dt , nsteps_rk ) use pf_mod_timer use pf_mod_hooks class ( pf_ark_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 !!  Time at start of time interval class ( pf_encap_t ), intent ( in ) :: q0 !!  Starting value class ( pf_encap_t ), intent ( inout ) :: qend !!  Final value real ( pfdp ), intent ( in ) :: big_dt !!  Size of time interval to integrato on integer , intent ( in ) :: level_index !!  Level of the index to step on integer , intent ( in ) :: nsteps_rk !!  Number of steps to use class ( pf_level_t ), pointer :: lev !!  Pointer to level level_index integer :: j , m , n !!  Loop counters real ( pfdp ) :: tn !!  Time at beginning of RKstep real ( pfdp ) :: tc !!  Time at  RK stage real ( pfdp ) :: dt !!  Size of each ark step lev => pf % levels ( level_index ) !! Assign pointer to appropriate level dt = big_dt / real ( nsteps_rk , pfdp ) ! Set the internal time step size based on the number of rk steps call this % q0 % copy ( q0 ) do n = 1 , nsteps_rk ! Loop over time steps tn = t0 + dt * real ( n - 1 , pfdp ) ! Reset initial condition if ( n > 1 ) call this % q0 % copy ( this % qend ) ! this assumes that cvec(1) == 0 if ( this % explicit ) & call this % f_eval ( this % q0 , tn + dt * this % cvec ( 1 ), level_index , this % F ( 1 , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( this % q0 , tn + dt * this % cvec ( 1 ), level_index , this % F ( 1 , 2 ), 2 ) ! Loop over stage values do m = 1 , this % nstages - 1 ! Set current time tc = tn + dt * this % cvec ( m + 1 ) ! Initialize the right-hand size for each stage call this % rhs % copy ( this % q0 ) do j = 1 , m ! Add explicit rhs if ( this % explicit ) & call this % rhs % axpy ( dt * this % AmatE ( m + 1 , j ), this % F ( j , 1 )) ! Add implicit rhs if ( this % implicit ) & call this % rhs % axpy ( dt * this % AmatI ( m + 1 , j ), this % F ( j , 2 )) end do ! Solve the implicit system if ( this % implicit . and . this % AmatI ( m + 1 , m + 1 ) /= 0 ) then call this % f_comp ( this % qtemp , tc , dt * this % AmatI ( m + 1 , m + 1 ), this % rhs , level_index , this % F ( m + 1 , 2 ), 2 ) else call this % qtemp % copy ( this % rhs ) end if ! Reevaluate explicit rhs with the new solution if ( this % explicit ) & call this % f_eval ( this % qtemp , tc , level_index , this % F ( m + 1 , 1 ), 1 ) end do ! End loop over stage values ! Compute final value using quadrature rule call this % qend % copy ( this % q0 ) ! Loop over stage values one more time do j = 1 , this % nstages ! Add explicit terms if ( this % explicit ) & call this % qend % axpy ( dt * this % bvecE ( j ), this % F ( j , 1 )) ! Add implicit terms if ( this % implicit ) & call this % qend % axpy ( dt * this % bvecI ( j ), this % F ( j , 2 )) end do ! End loop over stage values end do ! End Loop over time steps call qend % copy ( this % qend ) end subroutine ark_do_n_steps","tags":"","loc":"proc/ark_do_n_steps.html","title":"ark_do_n_steps – LibPFASST"},{"text":"public subroutine ark_initialize(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize Contents Source Code ark_initialize Source Code subroutine ark_initialize ( this , pf , level_index ) class ( pf_ark_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize integer :: nstages , npieces , i !  Local copies for convenience real ( pfdp ) :: gamma , delta type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer !  The implicit and explicit flags should be set before calling initialize npieces = 1 if ( this % implicit . eqv . . true . . and . this % explicit . eqv . . true .) npieces = 2 select case ( this % order ) case ( 1 ) !  Forward-backward Euler nstages = 2 case ( 2 ) !  Ascher-Ruuth-Spiteri nstages = 3 case ( 3 ) ! Third-order Kennedy-Carpenter nstages = 4 case ( 4 ) ! Fourth-order Kennedy-Carpenter nstages = 6 case DEFAULT stop \"ark_initialize: This RK order is not supported\" call exit ( 0 ) end select this % nstages = nstages this % npieces = npieces allocate ( this % AmatE ( nstages , nstages )) !  Explicit Butcher matrix allocate ( this % AmatI ( nstages , nstages )) !  Implicit Butcher matrix allocate ( this % cvec ( nstages )) !  stage times allocate ( this % bvecE ( nstages )) !  quadrature weights on explicit allocate ( this % bvecI ( nstages )) !  quadrature weights on implicit this % AmatE = 0.0_pfdp this % AmatI = 0.0_pfdp this % bvecE = 0.0_pfdp this % bvecI = 0.0_pfdp this % cvec = 0.0_pfdp select case ( this % order ) case ( 1 ) !  Forward-backward Euler this % AmatE ( 2 , 1 ) = ONE this % AmatI ( 2 , 2 ) = ONE this % cvec = ( / ZERO , ONE / ) this % bvecE = ( / ONE , ZERO / ) this % bvecI = ( / ZERO , ONE / ) case ( 2 ) !  Ascher-Ruuth-Spiteri gamma = ( TWO - sqrt ( TWO )) / TWO delta = - TWO * sqrt ( TWO ) / THREE this % AmatE ( 2 , 1 ) = gamma this % AmatE ( 3 , 1 ) = delta this % AmatE ( 3 , 2 ) = ONE - delta this % AmatI ( 2 , 2 ) = gamma this % AmatI ( 3 , 2 ) = ONE - gamma this % AmatI ( 3 , 3 ) = gamma this % cvec = ( / ZERO , gamma , ONE / ) this % bvecE = ( / ZERO , ONE - gamma , gamma / ) this % bvecI = this % bvecE case ( 3 ) ! Third-order Kennedy-Carpenter this % AmatE ( 2 , 1 ) = 176773220590 3.0_pfdp / 202783664111 8.0_pfdp this % AmatE ( 3 , 1 ) = 553582888582 5.0_pfdp / 1049269177363 7.0_pfdp this % AmatE ( 3 , 2 ) = 78802234243 7.0_pfdp / 1088263485894 0.0_pfdp this % AmatE ( 4 , 1 ) = 648598928062 9.0_pfdp / 1625170173562 2.0_pfdp this % AmatE ( 4 , 2 ) = - 424626684708 9.0_pfdp / 970447391861 9.0_pfdp this % AmatE ( 4 , 3 ) = 1075544844929 2.0_pfdp / 1035709742484 1.0_pfdp this % AmatI ( 2 , 1 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 2 , 2 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 3 , 1 ) = 274623878971 9.0_pfdp / 1065886856070 8.0_pfdp this % AmatI ( 3 , 2 ) = - 64016744523 7.0_pfdp / 684562943199 7.0_pfdp this % AmatI ( 3 , 3 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 4 , 1 ) = 147126639957 9.0_pfdp / 784085678865 4.0_pfdp this % AmatI ( 4 , 2 ) = - 448244416785 8.0_pfdp / 752975506669 7.0_pfdp this % AmatI ( 4 , 3 ) = 1126623926642 8.0_pfdp / 1159328672282 1.0_pfdp this % AmatI ( 4 , 4 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % cvec = ( / 0.0_pfdp , 176773220590 3.0_pfdp / 202783664111 8.0_pfdp , 3.0_pfdp / 5.0_pfdp , 1.0_pfdp / ) this % bvecE = ( / 147126639957 9.0_pfdp / 784085678865 4.0_pfdp , - 448244416785 8.0_pfdp / 752975506669 7.0_pfdp ,& 1126623926642 8.0_pfdp / 1159328672282 1.0_pfdp , 176773220590 3.0_pfdp / 405567328223 6.0_pfdp / ) this % bvecI = this % bvecE case ( 4 ) ! Fourth-order Kennedy-Carpenter this % AmatE ( 2 , 1 ) = 0.5_pfdp this % AmatE ( 3 , 1 ) = 1386 1.0_pfdp / 6250 0.0_pfdp this % AmatE ( 3 , 2 ) = 688 9.0_pfdp / 6250 0.0_pfdp this % AmatE ( 4 , 1 ) = - 11692331627 5.0_pfdp / 239368406146 8.0_pfdp this % AmatE ( 4 , 2 ) = - 273121846731 7.0_pfdp / 1536804210183 1.0_pfdp this % AmatE ( 4 , 3 ) = 940804670208 9.0_pfdp / 1111317113920 9.0_pfdp this % AmatE ( 5 , 1 ) = - 45108634878 8.0_pfdp / 290242868990 9.0_pfdp this % AmatE ( 5 , 2 ) = - 268234879257 2.0_pfdp / 751979568189 7.0_pfdp this % AmatE ( 5 , 3 ) = 1266286877508 2.0_pfdp / 1196047911538 3.0_pfdp this % AmatE ( 5 , 4 ) = 335581797596 5.0_pfdp / 1106085150927 1.0_pfdp this % AmatE ( 6 , 1 ) = 64784517918 8.0_pfdp / 321632005775 1.0_pfdp this % AmatE ( 6 , 2 ) = 7328151925 0.0_pfdp / 838263948453 3.0_pfdp this % AmatE ( 6 , 3 ) = 55253951339 1.0_pfdp / 345466838623 3.0_pfdp this % AmatE ( 6 , 4 ) = 335451267163 9.0_pfdp / 830676392457 3.0_pfdp this % AmatE ( 6 , 5 ) = 404 0.0_pfdp / 1787 1.0_pfdp this % AmatI ( 2 , 1 ) = 0.25_pfdp this % AmatI ( 2 , 2 ) = 0.25_pfdp this % AmatI ( 3 , 1 ) = 861 1.0_pfdp / 6250 0.0_pfdp this % AmatI ( 3 , 2 ) = - 174 3.0_pfdp / 3125 0.0_pfdp this % AmatI ( 3 , 3 ) = 0.25_pfdp this % AmatI ( 4 , 1 ) = 501202 9.0_pfdp / 3465250 0.0_pfdp this % AmatI ( 4 , 2 ) = - 65444 1.0_pfdp / 292250 0.0_pfdp this % AmatI ( 4 , 3 ) = 17437 5.0_pfdp / 38810 8.0_pfdp this % AmatI ( 4 , 4 ) = 0.25_pfdp this % AmatI ( 5 , 1 ) = 1526708280 9.0_pfdp / 15537626560 0.0_pfdp this % AmatI ( 5 , 2 ) = - 7144340 1.0_pfdp / 12077440 0.0_pfdp this % AmatI ( 5 , 3 ) = 73087887 5.0_pfdp / 90218476 8.0_pfdp this % AmatI ( 5 , 4 ) = 228539 5.0_pfdp / 807091 2.0_pfdp this % AmatI ( 5 , 5 ) = 0.25_pfdp this % AmatI ( 6 , 1 ) = 8288 9.0_pfdp / 52489 2.0_pfdp this % AmatI ( 6 , 2 ) = 0.0_pfdp this % AmatI ( 6 , 3 ) = 1562 5.0_pfdp / 8366 4.0_pfdp this % AmatI ( 6 , 4 ) = 6987 5.0_pfdp / 10267 2.0_pfdp this % AmatI ( 6 , 5 ) = - 226 0.0_pfdp / 821 1.0_pfdp this % AmatI ( 6 , 6 ) = 0.25_pfdp this % cvec = ( / 0.0_pfdp , 0.5_pfdp , 8 3.0_pfdp / 25 0.0_pfdp , & 3 1.0_pfdp / 5 0.0_pfdp , 1 7.0_pfdp / 2 0.0_pfdp , 1.0_pfdp / ) this % bvecE = ( / 8288 9.0_pfdp / 52489 2.0_pfdp , 0.0_pfdp , 1562 5.0_pfdp / 8366 4.0_pfdp , & 6987 5.0_pfdp / 10267 2.0_pfdp , - 226 0.0_pfdp / 821 1.0_pfdp , 0.25_pfdp / ) this % bvecI = this % bvecE case DEFAULT stop \"ark_initialize: This RK order is not supported\" call exit ( 0 ) end select ! Allocate space for local variables call lev % ulevel % factory % create_single ( this % rhs , level_index , lev % shape ) call lev % ulevel % factory % create_single ( this % q0 , level_index , lev % shape ) call lev % ulevel % factory % create_single ( this % qend , level_index , lev % shape ) call lev % ulevel % factory % create_single ( this % qtemp , level_index , lev % shape ) call lev % ulevel % factory % create_array ( lev % Frkflt , nstages * npieces , level_index , lev % shape ) do i = 1 , nstages * npieces call lev % Frkflt ( i )% setval ( 0.0_pfdp , 0 ) end do this % F ( 1 : nstages , 1 : npieces ) => lev % Frkflt end subroutine ark_initialize","tags":"","loc":"proc/ark_initialize.html","title":"ark_initialize – LibPFASST"},{"text":"public subroutine ark_destroy(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code ark_destroy Source Code subroutine ark_destroy ( this , pf , level_index ) class ( pf_ark_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % AmatE ) deallocate ( this % AmatI ) deallocate ( this % bvecE ) deallocate ( this % bvecI ) deallocate ( this % cvec ) call lev % ulevel % factory % destroy_single ( this % qend ) call lev % ulevel % factory % destroy_single ( this % q0 ) call lev % ulevel % factory % destroy_single ( this % rhs ) call lev % ulevel % factory % destroy_single ( this % qtemp ) call lev % ulevel % factory % destroy_array ( lev % Frkflt ) end subroutine ark_destroy","tags":"","loc":"proc/ark_destroy.html","title":"ark_destroy – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_eval_p.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dtq class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_comp_p.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine imex_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks Perform nsweeps SDC sweeps on level level_index and set qend appropriately.\n  Loop over sweeps\n  Loop over substeps\n  Accumulate rhs\n  Add the integral term Add the starting value\n  Solve for the implicit piece\n  Compute explicit function on new value End substep loop Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to sweep real(kind=pfdp), intent(in) :: t0 time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags sweep specific flags Contents Source Code imex_sweep Source Code subroutine imex_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to sweep real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !!  sweep specific flags !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level integer :: m , n , k !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( level_index ) !  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) !  Add terms from previous iteration  (not passing CI tests) !do m = 1, lev%nnodes-1 !   call lev%I(m)%setval(0.0_pfdp) !end do !if (this%explicit) call pf_apply_mat(lev%I, dt, this%QdiffE, lev%F(:,1), .false.) !if (this%implicit) call pf_apply_mat(lev%I, dt, this%QdiffI, lev%F(:,2), .false.) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) if ( this % explicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) end do end if if ( this % implicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 )) end do end if end do !  Add the tau FAS correction if ( level_index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) if ( m > 1 . and . pf % use_Sform ) then call lev % I ( m )% axpy ( - 1.0_pfdp , lev % tauQ ( m - 1 )) end if end do end if !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) end if t = t0 ! do the sub-stepping in sweep do m = 1 , lev % nnodes - 1 !!  Loop over substeps t = t + dt * this % dtsdc ( m ) !>  Accumulate rhs call this % rhs % setval ( 0.0_pfdp ) do n = 1 , m if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do !>  Add the integral term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m )) !>  Add the starting value if ( pf % use_Sform ) then call this % rhs % axpy ( 1.0_pfdp , lev % Q ( m )) else call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 )) end if !>  Solve for the implicit piece if ( this % implicit ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) else call lev % Q ( m + 1 )% copy ( this % rhs ) end if !>  Compute explicit function on new value if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) end do !!  End substep loop call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imex_sweep","tags":"","loc":"proc/imex_sweep.html","title":"imex_sweep – LibPFASST"},{"text":"public subroutine imex_initialize(this, pf, level_index) Uses pf_mod_quadrature Subroutine to initialize matrices and space for sweeper\n  Array of substep sizes Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize Contents Source Code imex_initialize Source Code subroutine imex_initialize ( this , pf , level_index ) use pf_mod_quadrature class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize type ( pf_level_t ), pointer :: lev !  Current level integer :: nnodes , ierr lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 2 !  The default is to use both pieces, but can be overriddent in local sweeper this % explicit = . TRUE . this % implicit = . TRUE . nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for QdiffE\" allocate ( this % QdiffI ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for QdiffI\" allocate ( this % QtilE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for QtilE\" allocate ( this % QtilI ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for QtilI\" allocate ( this % dtsdc ( nnodes - 1 ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imex_initialize for dtsdc\" this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes this % dtsdc = lev % sdcmats % qnodes ( 2 : nnodes ) - lev % sdcmats % qnodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI if ( pf % use_Sform ) then this % QdiffE ( 2 : nnodes - 1 ,:) = this % QdiffE ( 2 : nnodes - 1 ,:) - this % QdiffE ( 1 : nnodes - 2 ,:) this % QdiffI ( 2 : nnodes - 1 ,:) = this % QdiffI ( 2 : nnodes - 1 ,:) - this % QdiffI ( 1 : nnodes - 2 ,:) this % QtilE ( 2 : nnodes - 1 ,:) = this % QtilE ( 2 : nnodes - 1 ,:) - this % QtilE ( 1 : nnodes - 2 ,:) this % QtilI ( 2 : nnodes - 1 ,:) = this % QtilI ( 2 : nnodes - 1 ,:) - this % QtilI ( 1 : nnodes - 2 ,:) end if !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine imex_initialize","tags":"","loc":"proc/imex_initialize.html","title":"imex_initialize – LibPFASST"},{"text":"public subroutine imex_destroy(this, pf, level_index) Subroutine to deallocate sweeper Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code imex_destroy Source Code subroutine imex_destroy ( this , pf , level_index ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine imex_destroy","tags":"","loc":"proc/imex_destroy.html","title":"imex_destroy – LibPFASST"},{"text":"public subroutine imex_integrate(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Subroutine to compute  Picard integral of function values Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags Contents Source Code imex_integrate Source Code subroutine imex_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags integer :: n , m type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes if ( this % explicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 1 )) if ( this % implicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 2 )) end do end do !    if (this%explicit) call pf_apply_mat(fintSDC, dt, lev%sdcmats%Qmat, fSDC(:,1), .false.) !    if (this%implicit) call pf_apply_mat(fintSDC, dt, lev%sdcmats%Qmat, fSDC(:,2), .false.) end subroutine imex_integrate","tags":"","loc":"proc/imex_integrate.html","title":"imex_integrate – LibPFASST"},{"text":"public subroutine imex_residual(this, pf, level_index, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags Contents Source Code imex_residual Source Code subroutine imex_residual ( this , pf , level_index , dt , flags ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags call pf_generic_residual ( this , pf , level_index , dt ) end subroutine imex_residual","tags":"","loc":"proc/imex_residual.html","title":"imex_residual – LibPFASST"},{"text":"public subroutine imex_spreadq0(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imex_spreadq0 Source Code subroutine imex_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine imex_spreadq0","tags":"","loc":"proc/imex_spreadq0.html","title":"imex_spreadq0 – LibPFASST"},{"text":"public subroutine imex_evaluate(this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imex_evaluate Source Code subroutine imex_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) end subroutine imex_evaluate","tags":"","loc":"proc/imex_evaluate.html","title":"imex_evaluate – LibPFASST"},{"text":"public subroutine imex_evaluate_all(this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imex_evaluate_all Source Code subroutine imex_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_imex_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine imex_evaluate_all","tags":"","loc":"proc/imex_evaluate_all.html","title":"imex_evaluate_all – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate Description The interface to the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~2.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate Description The interface to the routine to do implicit solve \n  i.e, solve the equation y - dtq*f_2(y) =rhs","tags":"","loc":"interface/pf_f_comp_p~2.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine misdcQ_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks Loop over sweeps Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Contents Source Code misdcQ_sweep Source Code subroutine misdcQ_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables integer :: m , n , k real ( pfdp ) :: t type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) call this % I3 ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 )) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( m , n ), lev % F ( n , 3 )) call this % I3 ( m )% axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 )) !  Note we have to leave off the -dt*Qtil here and put it in after f2comp end do if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do ! do the time-stepping if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 ) endif t = t0 do m = 1 , lev % nnodes - 1 t = t + dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m )) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 )) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( Lev % Q ( m + 1 )) do n = 1 , m call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 3 ), 3 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 ) end do call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine misdcQ_sweep","tags":"","loc":"proc/misdcq_sweep.html","title":"misdcQ_sweep – LibPFASST"},{"text":"public subroutine misdcQ_initialize(this, pf, level_index) Array of substep sizes Make space for rhs Make space for extra integration piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code misdcQ_initialize Source Code subroutine misdcQ_initialize ( this , pf , level_index ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index integer :: m , n , nnodes type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) ! S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) ! S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) ! S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) ! S-BE allocate ( this % dtsdc ( nnodes - 1 )) this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) !>  Make space for extra integration piece call lev % ulevel % factory % create_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) end subroutine misdcQ_initialize","tags":"","loc":"proc/misdcq_initialize.html","title":"misdcQ_initialize – LibPFASST"},{"text":"public subroutine misdcQ_destroy(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code misdcQ_destroy Source Code subroutine misdcQ_destroy ( this , pf , level_index ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % I3 ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine misdcQ_destroy","tags":"","loc":"proc/misdcq_destroy.html","title":"misdcQ_destroy – LibPFASST"},{"text":"public subroutine misdcQ_integrate(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code misdcQ_integrate Source Code subroutine misdcQ_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: n , m , p type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine misdcQ_integrate","tags":"","loc":"proc/misdcq_integrate.html","title":"misdcQ_integrate – LibPFASST"},{"text":"public subroutine misdcQ_evaluate(this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_evaluate Source Code subroutine misdcQ_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 ) end subroutine misdcQ_evaluate","tags":"","loc":"proc/misdcq_evaluate.html","title":"misdcQ_evaluate – LibPFASST"},{"text":"public subroutine misdcQ_evaluate_all(this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_evaluate_all Source Code subroutine misdcQ_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine misdcQ_evaluate_all","tags":"","loc":"proc/misdcq_evaluate_all.html","title":"misdcQ_evaluate_all – LibPFASST"},{"text":"public subroutine misdcQ_residual(this, pf, level_index, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags Contents Source Code misdcQ_residual Source Code subroutine misdcQ_residual ( this , pf , level_index , dt , flags ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags call pf_generic_residual ( this , pf , level_index , dt ) end subroutine misdcQ_residual","tags":"","loc":"proc/misdcq_residual.html","title":"misdcQ_residual – LibPFASST"},{"text":"public subroutine misdcQ_spreadq0(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_spreadq0 Source Code subroutine misdcQ_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine misdcQ_spreadq0","tags":"","loc":"proc/misdcq_spreadq0.html","title":"misdcQ_spreadq0 – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate Description This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~3.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate Description Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece","tags":"","loc":"interface/pf_f_comp_p~3.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine misdc_sweep(this, pf, lev, t0, dt) Uses pf_mod_timer Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Contents Source Code misdc_sweep Source Code subroutine misdc_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_misdc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: S3 (:) class ( pf_encap_t ), allocatable :: rhs call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * this % SdiffI ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call misdc_evaluate ( this , lev , t , 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 ) call lev % ulevel % factory % create_single ( rhs , lev % index , lev % shape ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhs % copy ( lev % Q ( m )) call rhs % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhs % axpy ( 1.0_pfdp , lev % S ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) !  Now we need to do the final subtraction for the f3 piece call rhs % copy ( Lev % Q ( m + 1 )) call rhs % axpy ( - 1.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 3 )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 3 ), 3 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 ) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! done call lev % ulevel % factory % destroy_single ( rhs , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine misdc_sweep","tags":"","loc":"proc/misdc_sweep.html","title":"misdc_sweep – LibPFASST"},{"text":"public subroutine misdc_evaluate(this, lev, t, m) Uses pf_mod_dtype Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m Contents Source Code misdc_evaluate Source Code subroutine misdc_evaluate ( this , lev , t , m ) use pf_mod_dtype class ( pf_misdc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 ) end subroutine misdc_evaluate","tags":"","loc":"proc/misdc_evaluate.html","title":"misdc_evaluate – LibPFASST"},{"text":"public subroutine misdc_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code misdc_initialize Source Code subroutine misdc_initialize ( this , lev ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine misdc_initialize","tags":"","loc":"proc/misdc_initialize.html","title":"misdc_initialize – LibPFASST"},{"text":"public subroutine misdc_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code misdc_destroy Source Code subroutine misdc_destroy ( this , lev ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine misdc_destroy","tags":"","loc":"proc/misdc_destroy.html","title":"misdc_destroy – LibPFASST"},{"text":"public subroutine misdc_integrate(this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) Contents Source Code misdc_integrate Source Code subroutine misdc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine misdc_integrate","tags":"","loc":"proc/misdc_integrate.html","title":"misdc_integrate – LibPFASST"},{"text":"public subroutine misdc_residual(this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt Contents Source Code misdc_residual Source Code subroutine misdc_residual ( this , lev , dt ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine misdc_residual","tags":"","loc":"proc/misdc_residual.html","title":"misdc_residual – LibPFASST"},{"text":"public subroutine misdc_evaluate_all(this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) Contents Source Code misdc_evaluate_all Source Code subroutine misdc_evaluate_all ( this , lev , t ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine misdc_evaluate_all","tags":"","loc":"proc/misdc_evaluate_all.html","title":"misdc_evaluate_all – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_eval_p~4.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_comp_p~4.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine get_wk_ptr_1d(this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:) Contents Source Code get_wk_ptr_1d Source Code subroutine get_wk_ptr_1d ( this , wk ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer , intent ( inout ) :: wk (:) ! work space wk => this % wk_1d end subroutine get_wk_ptr_1d","tags":"","loc":"proc/get_wk_ptr_1d.html","title":"get_wk_ptr_1d – LibPFASST"},{"text":"public subroutine get_wk_ptr_2d(this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:) Contents Source Code get_wk_ptr_2d Source Code subroutine get_wk_ptr_2d ( this , wk ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer , intent ( inout ) :: wk (:,:) ! work space wk => this % wk_2d end subroutine get_wk_ptr_2d","tags":"","loc":"proc/get_wk_ptr_2d.html","title":"get_wk_ptr_2d – LibPFASST"},{"text":"public subroutine get_wk_ptr_3d(this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:,:) Contents Source Code get_wk_ptr_3d Source Code subroutine get_wk_ptr_3d ( this , wk ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer , intent ( inout ) :: wk (:,:,:) ! work space wk => this % wk_3d end subroutine get_wk_ptr_3d","tags":"","loc":"proc/get_wk_ptr_3d.html","title":"get_wk_ptr_3d – LibPFASST"},{"text":"public subroutine fft_1d(this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) Contents Source Code fft_1d Source Code subroutine fft_1d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:) complex ( pfdp ), intent ( inout ) :: ghat (:) this % wk_1d = g call this % fftf () ghat = this % wk_1d end subroutine fft_1d","tags":"","loc":"proc/fft_1d.html","title":"fft_1d – LibPFASST"},{"text":"public subroutine fft_2d(this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) Contents Source Code fft_2d Source Code subroutine fft_2d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:,:) complex ( pfdp ), intent ( inout ) :: ghat (:,:) this % wk_2d = g call this % fftf () ghat = this % wk_2d end subroutine fft_2d","tags":"","loc":"proc/fft_2d.html","title":"fft_2d – LibPFASST"},{"text":"public subroutine fft_3d(this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) Contents Source Code fft_3d Source Code subroutine fft_3d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:,:,:) complex ( pfdp ), intent ( inout ) :: ghat (:,:,:) this % wk_3d = g call this % fftf () ghat = this % wk_3d end subroutine fft_3d","tags":"","loc":"proc/fft_3d.html","title":"fft_3d – LibPFASST"},{"text":"public subroutine ifft_1d(this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) real(kind=pfdp), intent(inout) :: g (:) Contents Source Code ifft_1d Source Code subroutine ifft_1d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ) :: g (:) complex ( pfdp ), intent ( in ) :: ghat (:) this % wk_1d = ghat call this % fftb () g = real ( this % wk_1d , pfdp ) end subroutine ifft_1d","tags":"","loc":"proc/ifft_1d.html","title":"ifft_1d – LibPFASST"},{"text":"public subroutine ifft_2d(this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) real(kind=pfdp), intent(inout) :: g (:,:) Contents Source Code ifft_2d Source Code subroutine ifft_2d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ) :: g (:,:) complex ( pfdp ), intent ( in ) :: ghat (:,:) this % wk_2d = ghat call this % fftb () g = real ( this % wk_2d , pfdp ) end subroutine ifft_2d","tags":"","loc":"proc/ifft_2d.html","title":"ifft_2d – LibPFASST"},{"text":"public subroutine ifft_3d(this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) real(kind=pfdp), intent(inout) :: g (:,:,:) Contents Source Code ifft_3d Source Code subroutine ifft_3d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ) :: g (:,:,:) complex ( pfdp ), intent ( in ) :: ghat (:,:,:) this % wk_3d = ghat call this % fftb () g = real ( this % wk_3d ) end subroutine ifft_3d","tags":"","loc":"proc/ifft_3d.html","title":"ifft_3d – LibPFASST"},{"text":"public subroutine zfft_1d(this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) Contents Source Code zfft_1d Source Code subroutine zfft_1d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:) complex ( pfdp ), intent ( inout ) :: ghat (:) this % wk_1d = g call this % fftf () ghat = this % wk_1d end subroutine zfft_1d","tags":"","loc":"proc/zfft_1d.html","title":"zfft_1d – LibPFASST"},{"text":"public subroutine zfft_2d(this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) Contents Source Code zfft_2d Source Code subroutine zfft_2d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:) complex ( pfdp ), intent ( inout ) :: ghat (:,:) this % wk_2d = g call this % fftf () ghat = this % wk_2d end subroutine zfft_2d","tags":"","loc":"proc/zfft_2d.html","title":"zfft_2d – LibPFASST"},{"text":"public subroutine zfft_3d(this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) Contents Source Code zfft_3d Source Code subroutine zfft_3d ( this , g , ghat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:,:) complex ( pfdp ), intent ( inout ) :: ghat (:,:,:) this % wk_3d = g call this % fftf () ghat = this % wk_3d end subroutine zfft_3d","tags":"","loc":"proc/zfft_3d.html","title":"zfft_3d – LibPFASST"},{"text":"public subroutine izfft_1d(this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(inout) :: g (:) Contents Source Code izfft_1d Source Code subroutine izfft_1d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: g (:) complex ( pfdp ), intent ( in ) :: ghat (:) this % wk_1d = ghat call this % fftb () g = this % wk_1d end subroutine izfft_1d","tags":"","loc":"proc/izfft_1d.html","title":"izfft_1d – LibPFASST"},{"text":"public subroutine izfft_2d(this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(inout) :: g (:,:) Contents Source Code izfft_2d Source Code subroutine izfft_2d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: g (:,:) complex ( pfdp ), intent ( in ) :: ghat (:,:) this % wk_2d = ghat call this % fftb () g = this % wk_2d end subroutine izfft_2d","tags":"","loc":"proc/izfft_2d.html","title":"izfft_2d – LibPFASST"},{"text":"public subroutine izfft_3d(this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(inout) :: g (:,:,:) Contents Source Code izfft_3d Source Code subroutine izfft_3d ( this , ghat , g ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: g (:,:,:) complex ( pfdp ), intent ( in ) :: ghat (:,:,:) this % wk_3d = ghat call this % fftb () g = this % wk_3d end subroutine izfft_3d","tags":"","loc":"proc/izfft_3d.html","title":"izfft_3d – LibPFASST"},{"text":"public subroutine conv_1d(this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(inout) :: g (:) complex(kind=pfdp), intent(in) :: op (:) real(kind=pfdp), intent(inout) :: c (:) Contents Source Code conv_1d Source Code subroutine conv_1d ( this , g , op , c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ) :: g (:) complex ( pfdp ), intent ( in ) :: op (:) real ( pfdp ), intent ( inout ) :: c (:) this % wk_1d = g call this % fftf () this % wk_1d = this % wk_1d * op call this % fftb () c = real ( this % wk_1d , pfdp ) end subroutine conv_1d","tags":"","loc":"proc/conv_1d.html","title":"conv_1d – LibPFASST"},{"text":"public subroutine conv_2d(this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(in) :: op (:,:) real(kind=pfdp), intent(inout) :: c (:,:) Contents Source Code conv_2d Source Code subroutine conv_2d ( this , g , op , c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:,:) complex ( pfdp ), intent ( in ) :: op (:,:) real ( pfdp ), intent ( inout ) :: c (:,:) this % wk_2d = g ! Compute Convolution call this % fftf () this % wk_2d = this % wk_2d * op call this % fftb () c = real ( this % wk_2d , pfdp ) end subroutine conv_2d","tags":"","loc":"proc/conv_2d.html","title":"conv_2d – LibPFASST"},{"text":"public subroutine conv_3d(this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) real(kind=pfdp), intent(inout) :: c (:,:,:) Contents Source Code conv_3d Source Code subroutine conv_3d ( this , g , op , c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: g (:,:,:) complex ( pfdp ), intent ( in ) :: op (:,:,:) real ( pfdp ), intent ( inout ) :: c (:,:,:) this % wk_3d = g call this % fftf () this % wk_3d = this % wk_3d * op call this % fftb () c = real ( this % wk_3d , pfdp ) end subroutine conv_3d","tags":"","loc":"proc/conv_3d.html","title":"conv_3d – LibPFASST"},{"text":"public subroutine zconv_1d(this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(in) :: op (:) complex(kind=pfdp), intent(inout) :: chat (:) Contents Source Code zconv_1d Source Code subroutine zconv_1d ( this , ghat , op , chat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: ghat (:), op (:) complex ( pfdp ), intent ( inout ) :: chat (:) this % wk_1d = ghat call this % fftb () this % wk_1d = this % wk_1d * op call this % fftf () chat = this % wk_1d end subroutine zconv_1d","tags":"","loc":"proc/zconv_1d.html","title":"zconv_1d – LibPFASST"},{"text":"public subroutine zconv_2d(this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(in) :: op (:,:) complex(kind=pfdp), intent(inout) :: chat (:,:) Contents Source Code zconv_2d Source Code subroutine zconv_2d ( this , ghat , op , chat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: ghat (:,:), op (:,:) complex ( pfdp ), intent ( inout ) :: chat (:,:) this % wk_2d = ghat call this % fftb () this % wk_2d = this % wk_2d * op call this % fftf () chat = this % wk_2d end subroutine zconv_2d","tags":"","loc":"proc/zconv_2d.html","title":"zconv_2d – LibPFASST"},{"text":"public subroutine zconv_3d(this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) complex(kind=pfdp), intent(inout) :: chat (:,:,:) Contents Source Code zconv_3d Source Code subroutine zconv_3d ( this , ghat , op , chat ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: ghat (:,:,:), op (:,:,:) complex ( pfdp ), intent ( inout ) :: chat (:,:,:) this % wk_3d = ghat call this % fftb () this % wk_3d = this % wk_3d * op call this % fftf () chat = this % wk_3d end subroutine zconv_3d","tags":"","loc":"proc/zconv_3d.html","title":"zconv_3d – LibPFASST"},{"text":"public subroutine make_lap_1d(this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) Contents Source Code make_lap_1d Source Code subroutine make_lap_1d ( this , lap ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:) integer :: i , nx real ( pfdp ) :: kx , Lx nx = this % nx Lx = this % Lx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i ) = - kx ** 2 end do end subroutine make_lap_1d","tags":"","loc":"proc/make_lap_1d.html","title":"make_lap_1d – LibPFASST"},{"text":"public subroutine make_deriv_1d(this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) Contents Source Code make_deriv_1d Source Code subroutine make_deriv_1d ( this , ddx ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: ddx (:) integer :: i , nx real ( pfdp ) :: kx , Lx nx = this % nx Lx = this % Lx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if ddx ( i ) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do end subroutine make_deriv_1d","tags":"","loc":"proc/make_deriv_1d.html","title":"make_deriv_1d – LibPFASST"},{"text":"public subroutine make_lap_2d(this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) Contents Source Code make_lap_2d Source Code subroutine make_lap_2d ( this , lap ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:) integer :: i , j , nx , ny real ( pfdp ) :: kx , ky , Lx , Ly nx = this % nx ny = this % ny Lx = this % Lx Ly = this % Ly do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i , j ) = - ( kx ** 2 + ky ** 2 ) end do end do end subroutine make_lap_2d","tags":"","loc":"proc/make_lap_2d.html","title":"make_lap_2d – LibPFASST"},{"text":"public subroutine make_deriv_2d(this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir Contents Source Code make_deriv_2d Source Code subroutine make_deriv_2d ( this , deriv , dir ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:) integer , intent ( in ) :: dir integer :: i , j , nx , ny real ( pfdp ) :: kx , ky , Lx , Ly nx = this % nx ny = this % ny Lx = this % Lx Ly = this % Ly do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if if ( dir . eq . 1 ) then deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * kx else deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * ky endif end do end do end subroutine make_deriv_2d","tags":"","loc":"proc/make_deriv_2d.html","title":"make_deriv_2d – LibPFASST"},{"text":"public subroutine make_deriv_3d(this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir Contents Source Code make_deriv_3d Source Code subroutine make_deriv_3d ( this , deriv , dir ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:,:) integer , intent ( in ) :: dir integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz , Lx , Ly , Lz nx = this % nx ny = this % ny nz = this % nz Lx = this % Lx Ly = this % Ly Lz = this % Lz select case ( dir ) case ( 1 ) do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if deriv ( i ,:,:) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do case ( 2 ) do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if deriv (:, j ,:) = ( 0.0_pfdp , 1.0_pfdp ) * ky end do case ( 3 ) do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / Lz * dble ( k - 1 ) else kz = two_pi / Lz * dble ( - nz + k - 1 ) end if deriv (:,:, k ) = ( 0.0_pfdp , 1.0_pfdp ) * kz end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , dir ) end select end subroutine make_deriv_3d","tags":"","loc":"proc/make_deriv_3d.html","title":"make_deriv_3d – LibPFASST"},{"text":"public subroutine make_lap_3d(this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) Contents Source Code make_lap_3d Source Code subroutine make_lap_3d ( this , lap ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:,:) integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz , Lx , Ly , Lz nx = this % nx ny = this % ny nz = this % nz Lx = this % Lx Ly = this % Ly Lz = this % Lz do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / Lz * dble ( k - 1 ) else kz = two_pi / Lz * dble ( - nz + k - 1 ) end if do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i , j , k ) = - ( kx ** 2 + ky ** 2 + kz ** 2 ) end do end do end do end subroutine make_lap_3d","tags":"","loc":"proc/make_lap_3d.html","title":"make_lap_3d – LibPFASST"},{"text":"public subroutine restrict_1d(this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:) real(kind=pfdp), pointer :: yvec_c (:) Contents Source Code restrict_1d Source Code subroutine restrict_1d ( this , yvec_f , yvec_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), pointer :: yvec_f (:), yvec_c (:) integer :: nx_f , nx_c , irat nx_f = size ( yvec_f ) nx_c = size ( yvec_c ) irat = nx_f / nx_c yvec_c = yvec_f ( :: irat ) end subroutine restrict_1d","tags":"","loc":"proc/restrict_1d.html","title":"restrict_1d – LibPFASST"},{"text":"public subroutine restrict_2d(this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:) real(kind=pfdp), pointer :: yvec_c (:,:) Contents Source Code restrict_2d Source Code subroutine restrict_2d ( this , yvec_f , yvec_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), pointer :: yvec_f (:,:), yvec_c (:,:) integer :: nx_f ( 2 ), nx_c ( 2 ), irat , jrat nx_f = shape ( yvec_f ) nx_c = shape ( yvec_c ) irat = nx_f ( 1 ) / nx_c ( 1 ) jrat = nx_f ( 2 ) / nx_c ( 2 ) yvec_c = yvec_f ( :: irat , :: jrat ) end subroutine restrict_2d","tags":"","loc":"proc/restrict_2d.html","title":"restrict_2d – LibPFASST"},{"text":"public subroutine restrict_3d(this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:,:) real(kind=pfdp), pointer :: yvec_c (:,:,:) Contents Source Code restrict_3d Source Code subroutine restrict_3d ( this , yvec_f , yvec_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this real ( pfdp ), pointer :: yvec_f (:,:,:), yvec_c (:,:,:) integer :: nx_f ( 3 ), nx_c ( 3 ) integer :: irat , jrat , krat nx_f = shape ( yvec_f ) nx_c = shape ( yvec_c ) irat = nx_f ( 1 ) / nx_c ( 1 ) jrat = nx_f ( 2 ) / nx_c ( 2 ) krat = nx_f ( 3 ) / nx_c ( 3 ) yvec_c = yvec_f ( :: irat , :: jrat , :: krat ) end subroutine restrict_3d","tags":"","loc":"proc/restrict_3d.html","title":"restrict_3d – LibPFASST"},{"text":"public subroutine zrestrict_1d(this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:) complex(kind=pfdp), pointer :: yhat_c (:) Contents Source Code zrestrict_1d Source Code subroutine zrestrict_1d ( this , yhat_f , yhat_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:), yhat_c (:) integer :: nx_f , nx_c nx_f = size ( yhat_f ) nx_c = size ( yhat_c ) yhat_c = 0.0_pfdp yhat_c ( 1 : nx_c / 2 ) = yhat_f ( 1 : nx_c / 2 ) yhat_c ( nx_c / 2 + 2 : nx_c ) = yhat_f ( nx_f - nx_c / 2 + 2 : nx_f ) end subroutine zrestrict_1d","tags":"","loc":"proc/zrestrict_1d.html","title":"zrestrict_1d – LibPFASST"},{"text":"public subroutine zrestrict_2d(this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:) complex(kind=pfdp), pointer :: yhat_c (:,:) Contents Source Code zrestrict_2d Source Code subroutine zrestrict_2d ( this , yhat_f , yhat_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:), yhat_c (:,:) integer :: nx_f ( 2 ), nx_c ( 2 ), nf1 , nf2 , nc1 , nc2 nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 yhat_c = 0.0_pfdp yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) = yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 ) = yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 ) yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 )) = yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 )) yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 )) = yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 )) end subroutine zrestrict_2d","tags":"","loc":"proc/zrestrict_2d.html","title":"zrestrict_2d – LibPFASST"},{"text":"public subroutine zrestrict_3d(this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:,:) complex(kind=pfdp), pointer :: yhat_c (:,:,:) Contents Source Code zrestrict_3d Source Code subroutine zrestrict_3d ( this , yhat_f , yhat_c ) class ( pf_fft_abs_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:,:), yhat_c (:,:,:) integer :: nx_f ( 3 ), nx_c ( 3 ), nf1 , nf2 , nf3 , nc1 , nc2 , nc3 yhat_c = 0.0_pfdp nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nf3 = nx_f ( 3 ) - nx_c ( 3 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 nc3 = nx_c ( 3 ) / 2 + 2 yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) = yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) = yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) = yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) = yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) end subroutine zrestrict_3d","tags":"","loc":"proc/zrestrict_3d.html","title":"zrestrict_3d – LibPFASST"},{"text":"interface public subroutine pf_fft_s_p(this, grid_shape, dim, grid_size) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim)","tags":"","loc":"interface/pf_fft_s_p.html","title":"pf_fft_s_p – LibPFASST"},{"text":"interface public subroutine pf_fft_p(this) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this","tags":"","loc":"interface/pf_fft_p.html","title":"pf_fft_p – LibPFASST"},{"text":"public subroutine pf_pfasst_create(pf, comm, nlevels, fname, nocmd) Uses pf_mod_hooks Create a PFASST object\n gather some input from a file and command line\n  fname  present,  read inputs from a file (and maybe command line)\n  fname not present, only call read_opts if we want command line read\n  set communicator Set up the mpi communicator\n  allocate level pointers\n  loop over levels to set parameters\n  allocate hooks\n  allocate status Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst object type( pf_comm_t ), intent(inout), target :: comm Communicator integer, intent(in), optional :: nlevels number of pfasst levels character(len=*), intent(in), optional :: fname Input file for pfasst parameters logical, intent(in), optional :: nocmd Determines if command line variables are to be read Contents Source Code pf_pfasst_create Source Code subroutine pf_pfasst_create ( pf , comm , nlevels , fname , nocmd ) use pf_mod_hooks , only : PF_MAX_HOOK type ( pf_pfasst_t ), intent ( inout ) :: pf !! Main pfasst object type ( pf_comm_t ), intent ( inout ), target :: comm !! Communicator integer , intent ( in ), optional :: nlevels !! number of pfasst levels character ( len =* ), intent ( in ), optional :: fname !! Input file for pfasst parameters logical , intent ( in ), optional :: nocmd !! Determines if command line variables are to be read logical :: read_cmd !! Local version of nocmd integer :: ierr integer :: l !!  Loop variable for levels if ( present ( nlevels )) pf % nlevels = nlevels pf % outdir = \"dat/\" !> gather some input from a file and command line read_cmd = . true . if ( present ( nocmd )) then if ( nocmd ) read_cmd = . false . end if if ( present ( fname )) then !!  fname  present,  read inputs from a file (and maybe command line) call pf_read_opts ( pf , read_cmd , fname ) else !!  fname not present, only call read_opts if we want command line read if ( read_cmd ) call pf_read_opts ( pf , read_cmd ) end if !>  set communicator pf % comm => comm !>  Set up the mpi communicator call pf_mpi_setup ( pf % comm , pf , ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"ERROR: mpi_setup failed\" ) if ( pf % rank < 0 ) then call pf_stop ( __ FILE__ , __ LINE__ ,& \"Invalid PF rank: did you call setup correctly?\" ) end if !>  allocate level pointers allocate ( pf % levels ( pf % nlevels ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error\" , pf % nlevels ) !>  loop over levels to set parameters do l = 1 , pf % nlevels pf % levels ( l )% index = l pf % levels ( l )% nsweeps = pf % nsweeps ( l ) pf % levels ( l )% nsweeps_pred = pf % nsweeps_pred ( l ) pf % levels ( l )% nnodes = pf % nnodes ( l ) pf % levels ( l )% Finterp = pf % Finterp pf % levels ( l )% nsteps_rk = pf % nsteps_rk ( l ) end do !>  allocate hooks allocate ( pf % hooks ( pf % nlevels , PF_MAX_HOOK , PF_MAX_HOOKS ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error hooks\" ) allocate ( pf % nhooks ( pf % nlevels , PF_MAX_HOOK ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error nhooks\" ) pf % nhooks = 0 !>  allocate status allocate ( pf % state , stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error state\" ) pf % state % pstatus = 0 pf % state % status = 0 end subroutine pf_pfasst_create","tags":"","loc":"proc/pf_pfasst_create.html","title":"pf_pfasst_create – LibPFASST"},{"text":"public subroutine pf_level_set_size(pf, level_index, shape_in, buflen_in) Helper routine to set the size and mpi buffer length for regular grids Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst structure integer, intent(in) :: level_index integer, intent(in) :: shape_in (:) integer, intent(in), optional :: buflen_in Contents Source Code pf_level_set_size Source Code subroutine pf_level_set_size ( pf , level_index , shape_in , buflen_in ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  Main pfasst structure integer , intent ( in ) :: level_index integer , intent ( in ) :: shape_in (:) integer , intent ( in ), optional :: buflen_in integer :: buflen_local ! Allocate and set shape array for the level allocate ( pf % levels ( level_index )% shape ( size ( shape_in ))) pf % levels ( level_index )% shape = shape_in !  Set the size of mpi buffer buflen_local = product ( shape_in ) if ( present ( buflen_in )) buflen_local = buflen_in pf % levels ( level_index )% mpibuflen = buflen_local end subroutine pf_level_set_size","tags":"","loc":"proc/pf_level_set_size.html","title":"pf_level_set_size – LibPFASST"},{"text":"public subroutine pf_pfasst_setup(pf) Setup both the PFASST object and the comm object\n  loop over levels to set parameters\n  set default finest level\n  Loop over levels setting interpolation and restriction matrices (in time) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf Main pfasst structure Contents Source Code pf_pfasst_setup Source Code subroutine pf_pfasst_setup ( pf ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  Main pfasst structure class ( pf_level_t ), pointer :: lev_fine , lev_coarse !!  Pointers to level structures for brevity integer :: l !!  Level loop index integer :: ierr !!  error flag !>  loop over levels to set parameters do l = 1 , pf % nlevels call pf_level_setup ( pf , l ) end do !>  set default finest level pf % state % finest_level = pf % nlevels !>  Loop over levels setting interpolation and restriction matrices (in time) do l = pf % nlevels , 2 , - 1 lev_fine => pf % levels ( l ); lev_coarse => pf % levels ( l - 1 ) allocate ( lev_fine % tmat ( lev_fine % nnodes , lev_coarse % nnodes ), stat = ierr ) if ( ierr /= 0 ) & call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" , lev_fine % nnodes ) allocate ( lev_fine % rmat ( lev_coarse % nnodes , lev_fine % nnodes ), stat = ierr ) if ( ierr /= 0 ) & call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" , lev_fine % nnodes ) ! with the RK stepper, no need to interpolate and restrict in time ! we only copy the first node and last node betweem levels if ( pf % use_rk_stepper . eqv . . true .) then lev_fine % tmat = 0.0_pfdp lev_fine % rmat = 0.0_pfdp lev_fine % tmat ( 1 , 1 ) = 1.0_pfdp lev_fine % tmat ( lev_fine % nnodes , lev_coarse % nnodes ) = 1.0_pfdp lev_fine % rmat ( 1 , 1 ) = 1.0_pfdp lev_fine % rmat ( lev_coarse % nnodes , lev_fine % nnodes ) = 1.0_pfdp else ! else compute the interpolation matrix call pf_time_interpolation_matrix ( lev_fine % nodes , lev_fine % nnodes , lev_coarse % nodes , lev_coarse % nnodes , lev_fine % tmat ) call pf_time_interpolation_matrix ( lev_coarse % nodes , lev_coarse % nnodes , lev_fine % nodes , lev_fine % nnodes , lev_fine % rmat ) endif end do end subroutine pf_pfasst_setup","tags":"","loc":"proc/pf_pfasst_setup.html","title":"pf_pfasst_setup – LibPFASST"},{"text":"public subroutine pf_level_setup(pf, level_index) Uses pf_mod_quadrature Setup (allocate) PFASST level\n If the level is already setup, calling this again will allocate\n (or deallocate) tauQ appropriately.\n  Assign level pointer do some sanity checks\n (re)allocate tauQ \n skip the rest if we're already allocated\n allocate flat buffers for send, and recv\n allocate nodes, flags, and integration matrices\n  Allocate and compute all the matrices\n  initialize sweeper\n allocate solution and function arrays Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf Main pfasst structure integer, intent(in) :: level_index level to set up Contents Source Code pf_level_setup Source Code subroutine pf_level_setup ( pf , level_index ) use pf_mod_quadrature type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  Main pfasst structure integer , intent ( in ) :: level_index !!  level to set up class ( pf_level_t ), pointer :: lev !!  Level to set up integer :: mpibuflen , nnodes , npieces , nnodes0 integer :: i , ierr lev => pf % levels ( level_index ) !!  Assign level pointer !> do some sanity checks mpibuflen = lev % mpibuflen if ( mpibuflen <= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , 'allocate fail' , mpibuflen ) nnodes = lev % nnodes if ( nnodes <= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , 'allocate fail' , nnodes ) lev % residual = - 1.0_pfdp !> (re)allocate tauQ if (( lev % index < pf % nlevels ) . and . (. not . allocated ( lev % tauQ ))) then call lev % ulevel % factory % create_array ( lev % tauQ , nnodes - 1 , lev % index , lev % shape ) end if !> skip the rest if we're already allocated if ( lev % allocated ) return lev % allocated = . true . !> allocate flat buffers for send, and recv allocate ( lev % send ( mpibuflen ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) allocate ( lev % recv ( mpibuflen ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) !> allocate nodes, flags, and integration matrices allocate ( lev % nodes ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) allocate ( lev % nflags ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) lev % nflags = 0 !>  Allocate and compute all the matrices allocate ( lev % sdcmats , stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error sdcmats\" ) call pf_init_sdcmats ( pf , lev % sdcmats , nnodes , lev % nflags ) lev % nodes = lev % sdcmats % qnodes !>  initialize sweeper lev % ulevel % sweeper % use_LUq = pf % use_LUq call lev % ulevel % sweeper % initialize ( pf , level_index ) if ( pf % use_rk_stepper ) call lev % ulevel % stepper % initialize ( pf , level_index ) !> allocate solution and function arrays npieces = lev % ulevel % sweeper % npieces call lev % ulevel % factory % create_array ( lev % Q , nnodes , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( lev % Fflt , nnodes * npieces , lev % index , lev % shape ) do i = 1 , nnodes * npieces call lev % Fflt ( i )% setval ( 0.0_pfdp , 0 ) end do lev % F ( 1 : nnodes , 1 : npieces ) => lev % Fflt call lev % ulevel % factory % create_array ( lev % I , nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( lev % R , nnodes - 1 , lev % index , lev % shape ) !  Need space for old function values in im sweepers call lev % ulevel % factory % create_array ( lev % pFflt , nnodes * npieces , lev % index , lev % shape ) lev % pF ( 1 : nnodes , 1 : npieces ) => lev % pFflt if ( lev % index < pf % nlevels ) then call lev % ulevel % factory % create_array ( lev % pQ , nnodes , lev % index , lev % shape ) end if call lev % ulevel % factory % create_single ( lev % qend , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( lev % q0 , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( lev % q0_delta , lev % index , lev % shape ) end subroutine pf_level_setup","tags":"","loc":"proc/pf_level_setup.html","title":"pf_level_setup – LibPFASST"},{"text":"public subroutine pf_pfasst_destroy(pf) Deallocate PFASST object\n  destroy all levels\n  deallocate pfasst pointer arrays Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst structure Contents Source Code pf_pfasst_destroy Source Code subroutine pf_pfasst_destroy ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  Main pfasst structure integer :: l !>  destroy all levels do l = 1 , pf % nlevels call pf_level_destroy ( pf , l ) end do !>  deallocate pfasst pointer arrays deallocate ( pf % levels ) deallocate ( pf % hooks ) deallocate ( pf % nhooks ) deallocate ( pf % state ) call pf_mpi_destroy ( pf % comm ) end subroutine pf_pfasst_destroy","tags":"","loc":"proc/pf_pfasst_destroy.html","title":"pf_pfasst_destroy – LibPFASST"},{"text":"public subroutine pf_level_destroy(pf, level_index) Uses pf_mod_quadrature Deallocate PFASST level\n  Assign level pointer deallocate flat buffers for communcition\n deallocate nodes, flags, and integration matrices\n deallocate solution and function storage destroy the sweeper deallocate misc. arrays Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf Main pfasst structure integer, intent(in) :: level_index Contents Source Code pf_level_destroy Source Code subroutine pf_level_destroy ( pf , level_index ) use pf_mod_quadrature type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  Main pfasst structure integer , intent ( in ) :: level_index integer :: npieces !!  local copy of number of function pieces class ( pf_level_t ), pointer :: lev !!  points to current level lev => pf % levels ( level_index ) !!  Assign level pointer if (. not . lev % allocated ) return !> deallocate flat buffers for communcition deallocate ( lev % send ) deallocate ( lev % recv ) !> deallocate nodes, flags, and integration matrices deallocate ( lev % nodes ) deallocate ( lev % nflags ) call pf_destroy_sdcmats ( lev % sdcmats ) deallocate ( lev % sdcmats ) !> deallocate solution and function storage npieces = lev % ulevel % sweeper % npieces if (( lev % index < pf % nlevels ) . and . allocated ( lev % tauQ )) then call lev % ulevel % factory % destroy_array ( lev % tauQ ) end if call lev % ulevel % factory % destroy_array ( lev % Q ) call lev % ulevel % factory % destroy_array ( lev % Fflt ) call lev % ulevel % factory % destroy_array ( lev % I ) call lev % ulevel % factory % destroy_array ( lev % R ) call lev % ulevel % factory % destroy_array ( lev % pFflt ) if ( lev % index < pf % nlevels ) then call lev % ulevel % factory % destroy_array ( lev % pQ ) end if if ( lev % interp_workspace_allocated . eqv . . true .) then call lev % ulevel % factory % destroy_array ( lev % c_delta ) call lev % ulevel % factory % destroy_array ( lev % cf_delta ) lev % interp_workspace_allocated = . false . endif !> destroy the sweeper call lev % ulevel % sweeper % destroy ( pf , level_index ) !> deallocate misc. arrays if ( allocated ( lev % shape )) then deallocate ( lev % shape ) end if if ( allocated ( lev % tmat )) then deallocate ( lev % tmat ) end if if ( allocated ( lev % rmat )) then deallocate ( lev % rmat ) end if end subroutine pf_level_destroy","tags":"","loc":"proc/pf_level_destroy.html","title":"pf_level_destroy – LibPFASST"},{"text":"public subroutine pf_read_opts(pf, read_cmd, fname) Subroutine to read pfasst options from file and command line\n define the namelist for reading\n set local variables to pf_pfasst defaults\n open the file \"fname\" and read the pfasst namelist\n overwrite parameters defined on  command line\n re-assign the pfasst internals\n  Sanity check Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf logical, intent(in) :: read_cmd character(len=*), intent(in), optional :: fname Contents Source Code pf_read_opts Source Code subroutine pf_read_opts ( pf , read_cmd , fname ) type ( pf_pfasst_t ), intent ( inout ) :: pf logical , intent ( in ) :: read_cmd character ( len =* ), intent ( in ), optional :: fname ! local versions of pfasst parameters integer :: niters , nlevels , qtype integer :: nsweeps ( PF_MAXLEVS ) integer :: nsweeps_pred ( PF_MAXLEVS ) integer :: nnodes ( PF_MAXLEVS ) integer :: nsteps_rk ( PF_MAXLEVS ) real ( pfdp ) :: abs_res_tol , rel_res_tol logical :: PFASST_pred , RK_pred , pipeline_pred integer :: nsweeps_burn , q0_style , taui0 logical :: Vcycle , Finterp , use_LUq , use_Sform logical :: debug , use_rk_stepper logical :: save_timings , echo_timings , save_residuals , save_errors logical :: use_no_left_q , use_composite_nodes , use_proper_nodes ! stuff for reading the command line integer , parameter :: un = 9 integer :: i , ios , stat character ( len = 128 ) :: arg character ( len = 256 ) :: istring ! stores command line argument character ( len = 1024 ) :: message ! use for i/o error messages character ( len = 256 ) :: outdir !> define the namelist for reading namelist / pf_params / niters , nlevels , qtype , nsweeps , nsweeps_pred , nnodes , nsteps_rk , abs_res_tol , rel_res_tol namelist / pf_params / PFASST_pred , RK_pred , pipeline_pred , nsweeps_burn , q0_style , taui0 namelist / pf_params / Vcycle , Finterp , use_LUq , use_Sform , echo_timings , debug , save_timings , save_residuals , save_errors , use_rk_stepper namelist / pf_params / use_no_left_q , use_composite_nodes , use_proper_nodes , outdir !> set local variables to pf_pfasst defaults nlevels = pf % nlevels niters = pf % niters qtype = pf % qtype nsweeps = pf % nsweeps nsweeps_pred = pf % nsweeps_pred nnodes = pf % nnodes abs_res_tol = pf % abs_res_tol rel_res_tol = pf % rel_res_tol pfasst_pred = pf % pfasst_pred pipeline_pred = pf % pipeline_pred nsweeps_burn = pf % nsweeps_burn q0_style = pf % q0_style Vcycle = pf % Vcycle Finterp = pf % Finterp use_LUq = pf % use_LUq use_Sform = pf % use_Sform taui0 = pf % taui0 outdir = pf % outdir debug = pf % debug save_residuals = pf % save_residuals save_errors = pf % save_errors save_timings = pf % save_timings echo_timings = pf % echo_timings nsteps_rk = pf % nsteps_rk rk_pred = pf % rk_pred use_rk_stepper = pf % use_rk_stepper use_no_left_q = pf % use_no_left_q use_composite_nodes = pf % use_composite_nodes use_proper_nodes = pf % use_proper_nodes !> open the file \"fname\" and read the pfasst namelist if ( present ( fname )) then open ( unit = un , file = fname , status = 'old' , action = 'read' ) read ( unit = un , nml = pf_params ) close ( unit = un ) end if !> overwrite parameters defined on  command line if ( read_cmd ) then i = 0 do call get_command_argument ( i , arg , status = stat ) if ( len_trim ( arg ) == 0 ) exit if ( i > 1 ) then istring = \"&pf_params \" // trim ( arg ) // \" /\" read ( istring , nml = pf_params , iostat = ios , iomsg = message ) ! internal read of namelist end if i = i + 1 end do end if !> re-assign the pfasst internals pf % nlevels = nlevels pf % niters = niters pf % qtype = qtype pf % nsweeps = nsweeps pf % nsweeps_pred = nsweeps_pred pf % nnodes = nnodes pf % abs_res_tol = abs_res_tol pf % rel_res_tol = rel_res_tol pf % pfasst_pred = pfasst_pred pf % pipeline_pred = pipeline_pred pf % nsweeps_burn = nsweeps_burn pf % q0_style = q0_style pf % Vcycle = Vcycle pf % Finterp = Finterp pf % use_LUq = use_LUq pf % use_Sform = use_Sform pf % taui0 = taui0 pf % outdir = outdir pf % debug = debug pf % echo_timings = echo_timings pf % save_residuals = save_residuals pf % save_timings = save_timings pf % save_errors = save_errors pf % use_rk_stepper = use_rk_stepper pf % nsteps_rk = nsteps_rk pf % rk_pred = rk_pred pf % use_no_left_q = use_no_left_q pf % use_composite_nodes = use_composite_nodes pf % use_proper_nodes = use_proper_nodes !>  Sanity check if ( pf % nlevels < 1 ) then call pf_stop ( __ FILE__ , __ LINE__ , 'Bad specification for nlevels' , pf % nlevels ) endif end subroutine pf_read_opts","tags":"","loc":"proc/pf_read_opts.html","title":"pf_read_opts – LibPFASST"},{"text":"public subroutine pf_print_options(pf, un_opt, show_mats_opt) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in), optional :: un_opt logical, intent(in), optional :: show_mats_opt Contents Source Code pf_print_options Source Code subroutine pf_print_options ( pf , un_opt , show_mats_opt ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ), optional :: un_opt logical , intent ( in ), optional :: show_mats_opt integer :: un = 6 logical :: show_mats = . FALSE . integer :: l , i character ( 8 ) :: date character ( 10 ) :: time if ( pf % rank /= 0 ) return if ( present ( un_opt )) un = un_opt write ( un , * ) '==================================================' write ( un , * ) 'PFASST Configuration' write ( un , * ) '--------------------' call date_and_time ( date = date , time = time ) write ( un , * ) 'date:        ' , date write ( un , * ) 'time:        ' , time write ( un , * ) 'double precision:   ' , pfdp , '  bytes' write ( un , * ) 'quad precision:   ' , pfqp , '  bytes' write ( un , * ) 'nlevels:     ' , pf % nlevels , '! number of pfasst levels' write ( un , * ) 'nprocs:      ' , pf % comm % nproc , '! number of pfasst \"time\" processors' if ( pf % comm % nproc == 1 ) then write ( un , * ) '            ' , '             ' , ' ! since 1 time proc is being used, this is a serial sdc run' else write ( un , * ) '            ' , '             ' , ' ! since >1 time procs are being used, this is a parallel pfasst run' end if write ( un , * ) 'niters:      ' , pf % niters , '! maximum number of sdc/pfasst iterations' select case ( pf % qtype ) case ( SDC_GAUSS_LEGENDRE ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Legendre nodes are used' case ( SDC_GAUSS_LOBATTO ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Lobatto nodes are used' case ( SDC_GAUSS_RADAU ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Radua nodes are used' case ( SDC_CLENSHAW_CURTIS ) write ( un , * ) 'qtype:' , pf % qtype , '! Clenshaw Curtis nodes are used' case ( SDC_UNIFORM ) write ( un , * ) 'qtype:' , pf % qtype , '! Uniform  nodes are used' case ( SDC_CHEBYSHEV ) write ( un , * ) 'qtype:' , pf % qtype , '! Chebyshev  nodes are used' case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , pf % qtype ) end select if ( pf % use_proper_nodes ) write ( un , * ) 'Using proper node nesting' if ( pf % use_composite_nodes ) write ( un , * ) 'Using composite node nesting' if ( pf % use_no_left_q ) write ( un , * ) ' Skipping left end point in quadruture rule ' write ( un , * ) 'nnodes:      ' , pf % levels ( 1 : pf % nlevels )% nnodes , '! number of sdc nodes per level' write ( un , * ) 'mpibuflen:   ' , pf % levels ( 1 : pf % nlevels )% mpibuflen , '! size of data send between time steps' write ( un , * ) 'nsweeps:     ' , pf % levels ( 1 : pf % nlevels )% nsweeps , '! number of sdc sweeps performed per visit to each level' write ( un , * ) 'nsweeps_pred:     ' , pf % levels ( 1 : pf % nlevels )% nsweeps_pred , '! number of sdc sweeps in predictor' write ( un , * ) 'taui0:     ' , pf % taui0 , '! cutoff for tau correction' write ( un , * ) 'abs_res_tol:' , pf % abs_res_tol , '! absolute residual tolerance: ' write ( un , * ) 'rel_res_tol:' , pf % rel_res_tol , '! relative residual tolerance: ' if ( pf % use_Luq ) then write ( un , * ) 'Implicit matrix is LU  ' else write ( un , * ) 'Implicit matrix is backward Euler  ' end if if ( pf % use_Sform ) then write ( un , * ) 'The Smat form of stepping is being done' else write ( un , * ) 'The Qmat form of stepping is being done' end if if ( pf % Vcycle ) then write ( un , * ) 'V-cycling is on' else write ( un , * ) 'V-cycling is off, fine level is pipelining' end if if ( pf % rk_pred ) then write ( un , * ) 'Runge-Kutta used for predictor' else if ( pf % pipeline_pred ) then write ( un , * ) 'Predictor pipelining is ON    ' else write ( un , * ) 'Predictor pipelining is OFF    ' end if if ( pf % PFASST_pred ) then write ( un , * ) 'PFASST Predictor style  ' else write ( un , * ) 'Serial Predictor style  ' end if endif if ( pf % debug ) write ( un , * ) 'Debug mode is on ' write ( un , * ) 'Output directory ' , pf % outdir write ( un , * ) '' if ( present ( show_mats_opt )) show_mats = show_mats_opt if ( show_mats ) then do l = 1 , pf % nlevels print * , \"Level\" , l print * , \"-----------------\" print * , \"  nodes\" print * , pf % levels ( l )% nodes print * , \"  Q\" do i = 1 , pf % levels ( l )% nnodes - 1 print * , pf % levels ( l )% sdcmats % qmat ( i ,:) end do end do end if end subroutine pf_print_options","tags":"","loc":"proc/pf_print_options.html","title":"pf_print_options – LibPFASST"},{"text":"public subroutine pf_time_interpolation_matrix(f_nodes, f_nnodes, c_nodes, c_nnodes, tmat) Subroutine to make the matrices for interpolation  between noodes Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: f_nodes (0:f_nnodes-1) quadrature nodes on fine  level integer, intent(in) :: f_nnodes number of nodes on fine level real(kind=pfdp), intent(in) :: c_nodes (0:c_nnodes-1) quadrature nodes on coarse  level integer, intent(in) :: c_nnodes number of nodes on coarse  level real(kind=pfdp), intent(out) :: tmat (0:f_nnodes-1,0:c_nnodes-1) Interpolation matrix to compute Contents Source Code pf_time_interpolation_matrix Source Code subroutine pf_time_interpolation_matrix ( f_nodes , f_nnodes , c_nodes , c_nnodes , tmat ) integer , intent ( in ) :: f_nnodes !!  number of nodes on fine level integer , intent ( in ) :: c_nnodes !!  number of nodes on coarse  level real ( pfdp ), intent ( in ) :: f_nodes ( 0 : f_nnodes - 1 ) !!  quadrature nodes on fine  level real ( pfdp ), intent ( in ) :: c_nodes ( 0 : c_nnodes - 1 ) !!  quadrature nodes on coarse  level real ( pfdp ), intent ( out ) :: tmat ( 0 : f_nnodes - 1 , 0 : c_nnodes - 1 ) !!  Interpolation matrix to compute integer :: i , j , k real ( pfqp ) :: xi , num , den do i = 0 , f_nnodes - 1 xi = real ( f_nodes ( i ), pfqp ) do j = 0 , c_nnodes - 1 den = 1.0_pfqp num = 1.0_pfqp do k = 0 , c_nnodes - 1 if ( k == j ) cycle den = den * real ( c_nodes ( j ) - c_nodes ( k ), pfqp ) num = num * real ( xi - c_nodes ( k ), pfqp ) end do tmat ( i , j ) = real ( num / den , pfdp ) end do end do end subroutine pf_time_interpolation_matrix","tags":"","loc":"proc/pf_time_interpolation_matrix.html","title":"pf_time_interpolation_matrix – LibPFASST"},{"text":"public subroutine pf_initialize_results(pf) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Contents Source Code pf_initialize_results Source Code subroutine pf_initialize_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: level_index ALLOCATE ( pf % results ( pf % nlevels )) do level_index = 1 , pf % nlevels call initialize_results ( pf % results ( level_index ), pf % state % nsteps , pf % niters , pf % comm % nproc , pf % nsweeps ( level_index ), pf % rank , level_index , pf % outdir , pf % save_residuals ) end do end subroutine pf_initialize_results","tags":"","loc":"proc/pf_initialize_results.html","title":"pf_initialize_results – LibPFASST"},{"text":"public subroutine pf_dump_results(pf) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Contents Source Code pf_dump_results Source Code subroutine pf_dump_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: level_index if ( pf % save_residuals ) then do level_index = 1 , pf % nlevels call dump_resids ( pf % results ( level_index )) end do end if if ( pf % save_errors ) then do level_index = 1 , pf % nlevels call dump_errors ( pf % results ( level_index )) end do end if if ( pf % save_timings ) then call dump_timings ( pf ) end if end subroutine pf_dump_results","tags":"","loc":"proc/pf_dump_results.html","title":"pf_dump_results – LibPFASST"},{"text":"public subroutine pf_destroy_results(pf) Subroutine to destroy the results Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Contents Source Code pf_destroy_results Source Code subroutine pf_destroy_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: level_index do level_index = 1 , pf % nlevels call destroy_results ( pf % results ( level_index )) end do end subroutine pf_destroy_results","tags":"","loc":"proc/pf_destroy_results.html","title":"pf_destroy_results – LibPFASST"},{"text":"public subroutine fft_setup(this, grid_shape, dim, grid_size) Initialize the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) Contents Source Code fft_setup Source Code subroutine fft_setup ( this , grid_shape , dim , grid_size ) class ( pf_fft_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) integer :: nx , ny , nz real ( pfdp ) :: kx , ky type ( c_ptr ) :: wk this % dim = dim nx = grid_shape ( 1 ) this % nx = nx ! Defaults for grid_size this % Lx = 1.0_pfdp this % Ly = 1.0_pfdp this % Lz = 1.0_pfdp select case ( dim ) case ( 1 ) if ( present ( grid_size )) this % Lx = grid_size ( 1 ) this % normfact = real ( nx , pfdp ) wk = fftw_alloc_complex ( int ( nx , c_size_t )) call c_f_pointer ( wk , this % wk_1d , [ nx ]) this % ffftw = fftw_plan_dft_1d ( nx , & this % wk_1d , this % wk_1d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifftw = fftw_plan_dft_1d ( nx , & this % wk_1d , this % wk_1d , FFTW_BACKWARD , FFTW_ESTIMATE ) case ( 2 ) if ( present ( grid_size )) then this % Lx = grid_size ( 1 ) this % Ly = grid_size ( 2 ) end if ny = grid_shape ( 2 ) this % ny = ny this % normfact = real ( nx * ny , pfdp ) ! create in-place, complex fft plans wk = fftw_alloc_complex ( int ( nx * ny , c_size_t )) call c_f_pointer ( wk , this % wk_2d , [ nx , ny ]) this % ffftw = fftw_plan_dft_2d ( nx , ny , & this % wk_2d , this % wk_2d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifftw = fftw_plan_dft_2d ( nx , ny , & this % wk_2d , this % wk_2d , FFTW_BACKWARD , FFTW_ESTIMATE ) case ( 3 ) if ( present ( grid_size )) then this % Lx = grid_size ( 1 ) this % Ly = grid_size ( 2 ) this % Lz = grid_size ( 3 ) end if ny = grid_shape ( 2 ) nz = grid_shape ( 3 ) this % ny = ny this % nz = nz this % normfact = real ( nx * ny * nz , pfdp ) wk = fftw_alloc_complex ( int ( nx * ny * nz , c_size_t )) call c_f_pointer ( wk , this % wk_3d , [ nx , ny , nz ]) this % ffftw = fftw_plan_dft_3d ( nx , ny , nz , & this % wk_3d , this % wk_3d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifftw = fftw_plan_dft_3d ( nx , ny , nz , & this % wk_3d , this % wk_3d , FFTW_BACKWARD , FFTW_ESTIMATE ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_setup","tags":"","loc":"proc/fft_setup.html","title":"fft_setup – LibPFASST"},{"text":"public subroutine fft_destroy(this) Destroy the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Contents Source Code fft_destroy Source Code subroutine fft_destroy ( this ) class ( pf_fft_t ), intent ( inout ) :: this call fftw_destroy_plan ( this % ffftw ) call fftw_destroy_plan ( this % ifftw ) select case ( this % dim ) case ( 1 ) deallocate ( this % wk_1d ) case ( 2 ) deallocate ( this % wk_2d ) case ( 3 ) deallocate ( this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_destroy","tags":"","loc":"proc/fft_destroy.html","title":"fft_destroy – LibPFASST"},{"text":"public subroutine fftf(this) Routine to take foreward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Contents Source Code fftf Source Code subroutine fftf ( this ) class ( pf_fft_t ), intent ( inout ) :: this select case ( this % dim ) case ( 1 ) this % wk_1d = this % wk_1d / this % normfact call fftw_execute_dft ( this % ffftw , this % wk_1d , this % wk_1d ) case ( 2 ) this % wk_2d = this % wk_2d / this % normfact call fftw_execute_dft ( this % ffftw , this % wk_2d , this % wk_2d ) case ( 3 ) this % wk_3d = this % wk_3d / this % normfact call fftw_execute_dft ( this % ffftw , this % wk_3d , this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftf","tags":"","loc":"proc/fftf.html","title":"fftf – LibPFASST"},{"text":"public subroutine fftb(this) Routine to take inverse or backward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Contents Source Code fftb Source Code subroutine fftb ( this ) class ( pf_fft_t ), intent ( inout ) :: this !  Normalize the fft select case ( this % dim ) case ( 1 ) call fftw_execute_dft ( this % ifftw , this % wk_1d , this % wk_1d ) case ( 2 ) call fftw_execute_dft ( this % ifftw , this % wk_2d , this % wk_2d ) case ( 3 ) call fftw_execute_dft ( this % ifftw , this % wk_3d , this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftb","tags":"","loc":"proc/fftb.html","title":"fftb – LibPFASST"},{"text":"public subroutine interp_1d(this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:) Contents Source Code interp_1d Source Code subroutine interp_1d ( this , yvec_c , fft_f , yvec_f ) !      use pf_mod_fftpackage, only: pf_fft_t !        class(pf_fft_abs_t), intent(inout) :: this class ( pf_fft_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f integer :: nx_f , nx_c complex ( pfdp ), pointer :: wk_f (:), wk_c (:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_1d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f ) end subroutine interp_1d","tags":"","loc":"proc/interp_1d.html","title":"interp_1d – LibPFASST"},{"text":"public subroutine interp_2d(this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:) Contents Source Code interp_2d Source Code subroutine interp_2d ( this , yvec_c , fft_f , yvec_f ) class ( pf_fft_t ), intent ( inout ) :: this !    class(pf_fft_abs_t), intent(inout) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:,:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:,:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f complex ( pfdp ), pointer :: wk_f (:,:), wk_c (:,:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_2d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f ) end subroutine interp_2d","tags":"","loc":"proc/interp_2d.html","title":"interp_2d – LibPFASST"},{"text":"public subroutine interp_3d(this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:,:) Contents Source Code interp_3d Source Code subroutine interp_3d ( this , yvec_c , fft_f , yvec_f ) class ( pf_fft_t ), intent ( inout ) :: this !   class(pf_fft_abs_t), intent(inout) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:,:,:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:,:,:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f complex ( pfdp ), pointer :: wk_f (:,:,:), wk_c (:,:,:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_3d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f ) end subroutine interp_3d","tags":"","loc":"proc/interp_3d.html","title":"interp_3d – LibPFASST"},{"text":"public subroutine zinterp_1d(this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:) complex(kind=pfdp), pointer :: yhat_f (:) Contents Source Code zinterp_1d Source Code subroutine zinterp_1d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:), yhat_c (:) integer :: nx_f , nx_c nx_f = size ( yhat_f ) nx_c = size ( yhat_c ) yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c / 2 ) = yhat_c ( 1 : nx_c / 2 ) yhat_f ( nx_f - nx_c / 2 + 2 : nx_f ) = yhat_c ( nx_c / 2 + 2 : nx_c ) end subroutine zinterp_1d","tags":"","loc":"proc/zinterp_1d.html","title":"zinterp_1d – LibPFASST"},{"text":"public subroutine zinterp_2d(this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:) complex(kind=pfdp), pointer :: yhat_f (:,:) Contents Source Code zinterp_2d Source Code subroutine zinterp_2d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:), yhat_c (:,:) integer :: nx_f ( 2 ), nx_c ( 2 ), nf1 , nf2 , nc1 , nc2 nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 )) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 )) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 )) end subroutine zinterp_2d","tags":"","loc":"proc/zinterp_2d.html","title":"zinterp_2d – LibPFASST"},{"text":"public subroutine zinterp_3d(this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:,:) complex(kind=pfdp), pointer :: yhat_f (:,:,:) Contents Source Code zinterp_3d Source Code subroutine zinterp_3d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:,:), yhat_c (:,:,:) integer :: nx_f ( 3 ), nx_c ( 3 ), nf1 , nf2 , nf3 , nc1 , nc2 , nc3 nx_f = size ( yhat_f ) nx_c = size ( yhat_c ) yhat_f = 0.0_pfdp nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nf3 = nx_f ( 3 ) - nx_c ( 3 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 nc3 = nx_c ( 3 ) / 2 + 2 yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) end subroutine zinterp_3d","tags":"","loc":"proc/zinterp_3d.html","title":"zinterp_3d – LibPFASST"},{"text":"public subroutine verlet_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks Perform one SDC sweep on level level_index and set qend appropriately\n  Assign level pointer\n  Add the integral term Add the starting value Add the dt*v_0 End substep loop Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Contents Source Code verlet_sweep Source Code subroutine verlet_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: k , m , n , nnodes real ( pfdp ) :: t , dtmhalf , dtsq real ( pfdp ) :: H lev => pf % levels ( level_index ) !!  Assign level pointer nnodes = lev % nnodes call start_timer ( pf , TLEVEL + lev % index - 1 ) ! ! check hamiltonian ! !    call this%hamiltonian(t0+dt, Lev%qend, encapctx%m,H) !    print *,'Ham=',H,this%Htol,this%H0 !    if ((pf%state%iter > 1) .and. (abs(H-this%H0) < this%Htol)) then !       call Lev%encap%copy(Lev%qend, Lev%Q(nnodes)) !          print *, 'Skipping SDC sweep' !       return !    end if ! ! compute integrals and add fas correction ! dtsq = dt * dt do k = 1 , nsweeps pf % state % sweep = k do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) if ( pf % state % iter . eq . 1 ) then !  Do verlet on the first iteration do n = 1 , nnodes call lev % I ( m )% axpy ( dt * this % DQver ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dtsq * this % DQQver ( m , n ), lev % F ( n , 1 ), 2 ) end do else do n = 1 , nnodes call lev % I ( m )% axpy ( dt * this % DQtil ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dtsq * this % DQQtil ( m , n ), lev % F ( n , 1 ), 2 ) end do end if if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) end if t = t0 ! do the sub-stepping in sweep do m = 1 , nnodes - 1 t = t + dt * this % dtsdc ( m ) dtmhalf = 0.5d0 * dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp ) !  Lower triangular verlet to  new piece if ( pf % state % iter . eq . 1 ) then do n = 1 , m call this % rhs % axpy ( dtsq * this % QQver ( m , n ), lev % F ( n , 1 ), 2 ) end do else do n = 1 , m call this % rhs % axpy ( dtsq * this % QQtil ( m , n ), lev % F ( n , 1 ), 2 ) end do endif !>  Add the integral term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) !>  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 2 ) !>  Add the dt*v_0 call this % rhs % axpy ( t - t0 , lev % Q ( 1 ), 12 ) !  Update position term call lev % Q ( m + 1 )% copy ( this % rhs , 2 ) !  update function values call this % f_eval ( Lev % Q ( m + 1 ), t , lev % index , Lev % F ( m + 1 , 1 )) !  Now do the v peice call this % rhs % setval ( 0.0_pfdp , 1 ) !  Lower triangular verlet to  new piece if ( pf % state % iter . eq . 1 ) then do n = 1 , m + 1 call this % rhs % axpy ( dt * this % Qver ( m , n ), Lev % F ( n , 1 ), 1 ) end do else do n = 1 , m + 1 call this % rhs % axpy ( dt * this % Qtil ( m , n ), Lev % F ( n , 1 ), 1 ) end do end if call this % rhs % axpy ( 1.0_pfdp , Lev % I ( m ), 1 ); call this % rhs % axpy ( 1.0_pfdp , Lev % Q ( 1 ), 1 ) !  Start m+1 with value from 1 call lev % Q ( m + 1 )% copy ( this % rhs , 1 ) end do !!  End substep loop !  Set the value of qend !  If Gauss nodes, we must do integration !  unless the sweep was an initial Verlet !  For Lobatto nodes, we have a choice of whether to just use the !  value at the last node, or recompute it. !       if (this%iqend .and. pf%state%iter .gt. 1) then !          call Lev%encap%copy(Lev%qend, Lev%Q(1)) !          call Lev%encap%axpy(Lev%qend, dt, Lev%Q(1), 12)  !  Add the dt*v_0 term !          m = nnodes !          do n = 1, nnodes !             call Lev%encap%axpy(Lev%qend, dt*this%Qmat(m,n), Lev%F(n,1),1) !             call Lev%encap%axpy(Lev%qend, dtsq*this%QQmat(m,n), Lev%F(n,1),2) !          end do !          if (associated(Lev%tauQ)) then !             call Lev%encap%axpy(Lev%qend, 1.0_pfdp, Lev%tauQ(nnodes-1)) !             !          print *,'XXXXXXXXXXX  need code in verlet.f90' !          end if !       else !          call Lev%encap%copy(Lev%qend, Lev%Q(nnodes)) !       end if call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! end loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine verlet_sweep","tags":"","loc":"proc/verlet_sweep.html","title":"verlet_sweep – LibPFASST"},{"text":"public subroutine verlet_initialize(this, pf, level_index) Initialize integration matrices\n  Assign level pointer Array of substep sizes\n$       do i = 1,nnodes\n$          do j = 1,nnodes\n$             this%QQmat(i,j) =  this%bvec(j)*(1.0_pfdp-this%Qmat(j,i)/this%bvec(i))\n$          end do\n$       end do\n$       this%QQmat = matmul(this%QQmat,this%Qmat)\n  Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code verlet_initialize Source Code subroutine verlet_initialize ( this , pf , level_index ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index integer :: i , j , nnodes , ierr real ( pfdp ), allocatable :: qtemp (:,:) real ( pfdp ), allocatable :: qtemp2 (:,:) type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer this % npieces = 1 nnodes = Lev % nnodes allocate ( this % Qmat ( nnodes - 1 , nnodes ), stat = ierr ) !  0  to node integral if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qmat\" allocate ( this % QQmat ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node double integral (like Qmat*Qmat) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQmat\" allocate ( this % Qtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0  to node integral  approximation of Qmat if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qtil\" allocate ( this % QQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node QQmat  aproximation if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQtil\" allocate ( this % Qver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node verlet  aproximation (trap) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qver\" allocate ( this % QQver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node verlet  aproximation if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQver\" allocate ( this % DQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node Qmat-Qtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQtil\" allocate ( this % DQQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  node to node QQmat-QQtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQQtil\" allocate ( this % DQver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node Qmat-Qtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQtil\" allocate ( this % DQQver ( nnodes - 1 , nnodes ), stat = ierr ) !  node to node QQmat-QQtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQQtil\" allocate ( this % bvec ( nnodes ), stat = ierr ) !  Integration rule for v if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DStil\" allocate ( this % bbarvec ( nnodes ), stat = ierr ) !  Integration rule for x if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DSStil\" allocate ( this % dtsdc ( nnodes - 1 ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for dtsdc\" allocate ( this % tsdc ( nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for tsdc\" !>  Array of substep sizes this % dtsdc = lev % sdcmats % qnodes ( 2 : nnodes ) - lev % sdcmats % qnodes ( 1 : nnodes - 1 ) this % tsdc = lev % sdcmats % qnodes - lev % sdcmats % qnodes ( 1 ) !  Build Q from qmat this % Qmat = lev % sdcmats % qmat !   I just use qmat now? !  The quadrature rule is the last row of Q this % bvec = this % Qmat ( nnodes - 1 ,:); allocate ( qtemp ( nnodes , nnodes ), stat = ierr ) allocate ( qtemp2 ( nnodes , nnodes ), stat = ierr ) !  form the QQ matrix depending on what you want select case ( this % whichQQ ) case ( 0 ) !  Collocation (make it the product) print * , 'Making QQ by collocation Q*Q' print * , size ( this % Qmat ) qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = lev % sdcmats % qmat qtemp = matmul ( qtemp , qtemp ) this % QQmat = qtemp ( 2 : nnodes ,:) print * , shape ( this % QQmat ) case ( 1 ) !  Make the pair like in Lobatto A/B pair print * , 'Making QQ by collocation Lobatto pair' qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = this % Qmat qtemp2 = 0.0_pfdp do i = 1 , nnodes do j = 1 , nnodes qtemp2 ( i , j ) = this % bvec ( j ) * ( 1.0_pfdp - qtemp ( j , i ) / this % bvec ( i )) end do end do qtemp2 = matmul ( qtemp , qtemp2 ) this % QQmat = 0.0_pfdp this % QQmat = qtemp2 ( 2 : nnodes ,:) this % bbarvec = this % QQmat ( nnodes - 1 ,:); case ( 2 ) !  Make the pair like in Lobatto B/A pair print * , 'Error Making QQ by collocation Lobatto pair' !!$       do i = 1,nnodes !!$          do j = 1,nnodes !!$             this%QQmat(i,j) =  this%bvec(j)*(1.0_pfdp-this%Qmat(j,i)/this%bvec(i)) !!$          end do !!$       end do !!$       this%QQmat = matmul(this%QQmat,this%Qmat) case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % whichQQ ) end select ! 0 to node this % Qver = lev % sdcmats % qmatTrap qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = lev % sdcmats % qmatFE qtemp2 ( 2 : nnodes ,:) = lev % sdcmats % qmatTrap qtemp = matmul ( qtemp , qtemp2 ) this % QQver = qtemp ( 2 : nnodes ,:) + 0.5_pfdp * lev % sdcmats % qmatFE * lev % sdcmats % qmatFE !  Get LU matrices if desired !    if (this%use_LUq .eq. 1) then !       print *,'Doing LU with doLU=',this%doLU !       call myLUq(SDCmats%qmat,SDCmats%qmatLU,nnodes,0) !       call pf_myLUexp(this%QQmat,L,U,nnodes,this%doLU) !      this%QQLU=U !      print *, 'U from LU',this%QQLU !   else this % Qtil = this % Qver !  Normal verlet all the time this % QQtil = this % QQver !  Normal verlet all the time !   end if this % Qver = 0.0d0 !  Normal verlet all the time this % QQver = 0.0d0 !  Normal verlet all the time this % Qtil = this % Qver !  Normal verlet all the time this % QQtil = this % QQver !  Normal verlet all the time ! !  Make differences this % DQtil = this % Qmat - this % Qtil this % DQQtil = this % QQmat - this % QQtil this % DQver = this % Qmat - this % Qver this % DQQver = this % QQmat - this % QQver deallocate ( qtemp ) deallocate ( qtemp2 ) !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine verlet_initialize","tags":"","loc":"proc/verlet_initialize.html","title":"verlet_initialize – LibPFASST"},{"text":"public subroutine verlet_integrate(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Integrate (t_n to node)\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags Contents Source Code verlet_integrate Source Code subroutine verlet_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags integer :: n , m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) call fintSDC ( n )% axpy ( dt * this % tsdc ( n + 1 ), qSDC ( 1 ), 12 ) !  Add the dt*v_0 term do m = 1 , lev % nnodes call fintSDC ( n )% axpy ( dt * this % Qmat ( n , m ), fSDC ( m , 1 ), 1 ) call fintSDC ( n )% axpy ( dt * dt * this % QQmat ( n , m ), fSDC ( m , 1 ), 2 ) end do end do end subroutine verlet_integrate","tags":"","loc":"proc/verlet_integrate.html","title":"verlet_integrate – LibPFASST"},{"text":"public subroutine verlet_residual(this, pf, level_index, dt, flags) Compute residual (t_n to node)\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags Contents Source Code verlet_residual Source Code subroutine verlet_residual ( this , pf , level_index , dt , flags ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags integer :: n , m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer call this % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I , flags ) ! add tau if ( level_index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine verlet_residual","tags":"","loc":"proc/verlet_residual.html","title":"verlet_residual – LibPFASST"},{"text":"public subroutine verlet_destroy(this, pf, level_index) Destroy Verlet sweeper matrices\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code verlet_destroy Source Code subroutine verlet_destroy ( this , pf , level_index ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer deallocate ( this % Qmat ) deallocate ( this % QQmat ) deallocate ( this % Qtil ) deallocate ( this % QQtil ) deallocate ( this % Qver ) deallocate ( this % QQver ) deallocate ( this % DQtil ) deallocate ( this % DQQtil ) deallocate ( this % DQver ) deallocate ( this % DQQver ) deallocate ( this % bvec ) deallocate ( this % bbarvec ) deallocate ( this % dtsdc ) deallocate ( this % tsdc ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine verlet_destroy","tags":"","loc":"proc/verlet_destroy.html","title":"verlet_destroy – LibPFASST"},{"text":"public subroutine verlet_spreadq0(this, pf, level_index, t0, flags, step) Spread the intial data for Verlet sweepers\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code verlet_spreadq0 Source Code subroutine verlet_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine verlet_spreadq0","tags":"","loc":"proc/verlet_spreadq0.html","title":"verlet_spreadq0 – LibPFASST"},{"text":"public subroutine verlet_evaluate(this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code verlet_evaluate Source Code subroutine verlet_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine verlet_evaluate","tags":"","loc":"proc/verlet_evaluate.html","title":"verlet_evaluate – LibPFASST"},{"text":"public subroutine verlet_evaluate_all(this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code verlet_evaluate_all Source Code subroutine verlet_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !!  Assign level pointer call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine verlet_evaluate_all","tags":"","loc":"proc/verlet_evaluate_all.html","title":"verlet_evaluate_all – LibPFASST"},{"text":"interface public function pf_hamiltonian_p(this, y, t, level_index) result(H) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Variable real(kind=pfdp), intent(in) :: t Time of solve integer, intent(in) :: level_index Level index Return Value real(kind=pfdp)","tags":"","loc":"interface/pf_hamiltonian_p.html","title":"pf_hamiltonian_p – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value Description This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~5.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate Description Solve the equation y - dtq*f_2(y) =rhs","tags":"","loc":"interface/pf_f_comp_p~5.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine magpicard_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks this loop not OMP'd because the deferred procs are OMP'd Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags Contents Source Code magpicard_sweep Source Code subroutine magpicard_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt , t0 integer , intent ( in ) :: level_index integer , intent ( in ) :: nsweeps integer , optional , intent ( in ) :: flags class ( pf_level_t ), pointer :: lev integer :: m , nnodes , k real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call call_hooks ( pf , level_index , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 ) call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps pf % state % sweep = k ! Copy values into residual do m = 1 , nnodes - 1 call lev % R ( m )% copy ( lev % Q ( m + 1 )) end do t = t0 !$omp parallel do private(m, t) do m = 1 , nnodes !          t = t + dt*this%dtsdc(m) t = t0 + dt * lev % nodes ( m ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end do !$omp end parallel do !$omp barrier call magpicard_integrate ( this , pf , level_index , lev % Q , lev % F , dt , lev % I ) if ( this % magnus_order > 1 . and . nnodes > 2 ) then call start_timer ( pf , TAUX ) call this % compute_single_commutators ( lev % F ) call end_timer ( pf , TAUX ) endif !! this loop not OMP'd because the deferred procs are OMP'd do m = 1 , nnodes - 1 call start_timer ( pf , TAUX + 1 ) call this % compute_omega ( this % omega ( m ), lev % I , lev % F , & lev % nodes , lev % sdcmats % qmat , dt , m , this % commutator_coefs (:,:, m )) call end_timer ( pf , TAUX + 1 ) end do !$omp parallel do private(m) do m = 1 , nnodes - 1 call this % propagate_solution ( lev % Q ( 1 ), lev % Q ( m + 1 ), this % omega ( m ), lev % index ) end do !$omp end parallel do call pf_residual ( pf , level_index , dt ) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! Loop over sweeps call lev % qend % copy ( lev % Q ( nnodes )) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine magpicard_sweep","tags":"","loc":"proc/magpicard_sweep.html","title":"magpicard_sweep – LibPFASST"},{"text":"public subroutine magpicard_initialize(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize Contents Source Code magpicard_initialize Source Code subroutine magpicard_initialize ( this , pf , level_index ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize integer :: m , nnodes type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer this % commutator_coefs = 0.0_pfdp this % npieces = 1 nnodes = lev % nnodes allocate ( this % dtsdc ( nnodes - 1 )) this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) !  SDC time step size (unscaled) call get_commutator_coefs ( this % qtype , nnodes , this % dt , this % commutator_coefs ) call lev % ulevel % factory % create_array ( this % omega , nnodes - 1 , & lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % time_ev_op , nnodes - 1 , & lev % index , lev % shape ) do m = 1 , nnodes - 1 call this % omega ( m )% setval ( 0.0_pfdp ) call this % time_ev_op ( m )% setval ( 0.0_pfdp ) end do end subroutine magpicard_initialize","tags":"","loc":"proc/magpicard_initialize.html","title":"magpicard_initialize – LibPFASST"},{"text":"public subroutine magpicard_integrate(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Compute SDC integral\n  fintSDC = \\int_{t_n}&#94;{t_m} fSDC dt Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code magpicard_integrate Source Code subroutine magpicard_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: j , m type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer do m = 1 , lev % nnodes - 1 call fintSDC ( m )% setval ( 0.0_pfdp ) do j = 1 , lev % nnodes call fintSDC ( m )% axpy ( dt * lev % sdcmats % qmat ( m , j ), fSDC ( j , 1 )) end do end do end subroutine magpicard_integrate","tags":"","loc":"proc/magpicard_integrate.html","title":"magpicard_integrate – LibPFASST"},{"text":"public subroutine magpicard_evaluate(this, pf, level_index, t, m, flags, step) Uses pf_mod_dtype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code magpicard_evaluate Source Code subroutine magpicard_evaluate ( this , pf , level_index , t , m , flags , step ) use pf_mod_dtype class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine magpicard_evaluate","tags":"","loc":"proc/magpicard_evaluate.html","title":"magpicard_evaluate – LibPFASST"},{"text":"public subroutine magpicard_evaluate_all(this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code magpicard_evaluate_all Source Code subroutine magpicard_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine magpicard_evaluate_all","tags":"","loc":"proc/magpicard_evaluate_all.html","title":"magpicard_evaluate_all – LibPFASST"},{"text":"public subroutine magpicard_residual(this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code magpicard_residual Source Code subroutine magpicard_residual ( this , pf , level_index , dt , flags ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer do m = 1 , lev % nnodes - 1 call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do lev % residual = lev % R ( lev % nnodes - 1 )% norm () end subroutine magpicard_residual","tags":"","loc":"proc/magpicard_residual.html","title":"magpicard_residual – LibPFASST"},{"text":"public subroutine magpicard_spreadq0(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code magpicard_spreadq0 Source Code subroutine magpicard_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine magpicard_spreadq0","tags":"","loc":"proc/magpicard_spreadq0.html","title":"magpicard_spreadq0 – LibPFASST"},{"text":"public subroutine magpicard_destroy(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize Contents Source Code magpicard_destroy Source Code subroutine magpicard_destroy ( this , pf , level_index ) class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % omega ) call lev % ulevel % factory % destroy_array ( this % time_ev_op ) end subroutine magpicard_destroy","tags":"","loc":"proc/magpicard_destroy.html","title":"magpicard_destroy – LibPFASST"},{"text":"public subroutine get_commutator_coefs(qtype, nnodes, dt, coefs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: qtype integer, intent(in) :: nnodes real(kind=pfdp), intent(in) :: dt real(kind=pfdp), intent(inout) :: coefs (:,:,:) Contents Source Code get_commutator_coefs Source Code subroutine get_commutator_coefs ( qtype , nnodes , dt , coefs ) integer , intent ( in ) :: qtype , nnodes real ( pfdp ), intent ( in ) :: dt real ( pfdp ), intent ( inout ) :: coefs (:,:,:) ! coefs has the structure coefs(coefs, magnus_order, node) ! for a given node, pass subroutines the coefs for a magnus order, then ! loop over coefs if ( qtype == 1 ) then ! we're talking Lobatto nodes, where nnodes=3 includes, t0, t_1/2, tn ! need some way to differentiate whether you want full collocation or not ! coefs(1:3, 1, 1) = dt**2 * [real(8)::11/480., -1/480., 1/480.] ! coefs(1:3, 1, 2) = dt**2 * [real(8)::1/15., 1/60., 1/15.] coefs ( 1 , 1 , 1 ) = - 1 / 4 8.d0 * dt ** 2 coefs ( 2 , 1 , 2 ) = - 1 / 1 2.d0 * dt ** 2 elseif ( qtype == 5 ) then coefs ( 1 : 3 , 1 , 1 ) = 1.d-3 * [ real ( 8 ) :: - 0.708256232441739d0 , 0.201427439334681d0 , - 0.002608155816283d0 ] coefs ( 1 : 3 , 1 , 2 ) = [ real ( 8 ) :: - 0.035291589565775d0 , 0.004482619613666d0 , - 0.000569367343553d0 ] coefs ( 1 : 3 , 1 , 3 ) = [ real ( 8 ) :: - 0.078891497044705d0 , - 0.018131905893999d0 , - 0.035152700676886d0 ] coefs ( 1 : 3 , 1 , 4 ) = [ real ( 8 ) :: - 0.071721913818656d0 , - 0.035860956909328d0 , - 0.071721913818656d0 ] coefs (:, 1 ,:) = dt ** 2 * coefs (:, 1 ,:) coefs (:, 2 , 1 ) = & [ real ( 8 ) :: 1.466782892818107d-6 , - 2.546845448743404d-6 , 7.18855795894042d-7 , & - 3.065370250683271d-7 , 6.962336322868984d-7 , - 1.96845581200288d-7 , & - 2.262216360714434d-8 , - 2.72797194008496d-9 , 8.54843541920492d-10 ] coefs (:, 2 , 2 ) = & [ real ( 8 ) :: 0.001040114336531742d0 , - 0.001714330280871491d0 , 0.0001980882752518163d0 , & - 0.00006910549596945875d0 , 0.0002905401601450182d0 , - 0.00003465884693947625d0 , & 0.0000924518848932026d0 , 0.0000125950571649574d0 , - 2.4709074423913880d-6 ] coefs (:, 2 , 3 ) = & [ real ( 8 ) :: 0.004148295975360902d0 , - 0.006387421893168941d0 , - 0.003594231910817328d0 , & 0.000997378110327084d0 , 0.0001241530237557625d0 , - 0.0003805975423160699d0 , & 0.003718384934573079d0 , 0.001693514295056844d0 , - 0.001060408584538103d0 ] coefs (:, 2 , 4 ) = & [ real ( 8 ) :: 0.003453850676072909d0 , - 0.005584950029394391d0 , - 0.007128159905937654d0 , & 0.001653439153439147d0 , 0.0d0 , - 0.001653439153439143d0 , & 0.007128159905937675d0 , 0.005584950029394475d0 , - 0.003453850676072897d0 ] coefs (:, 2 ,:) = dt ** 3 * coefs (:, 2 ,:) coefs ( 1 , 3 , 4 ) = dt ** 4 / 6 0.d0 else stop 'oh no! unsupported qtype' endif end subroutine get_commutator_coefs","tags":"","loc":"proc/get_commutator_coefs.html","title":"get_commutator_coefs – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, f) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f","tags":"","loc":"interface/pf_f_eval_p~6.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_compute_single_commutators_p(this, f) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: f (:,:)","tags":"","loc":"interface/pf_compute_single_commutators_p.html","title":"pf_compute_single_commutators_p – LibPFASST"},{"text":"interface public subroutine pf_compute_omega_p(this, omega, integrals, f, nodes, qmat, dt, this_node, coefs) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: integrals (:) class( pf_encap_t ), intent(inout) :: f (:,:) real(kind=pfdp), intent(in) :: nodes (:) real(kind=pfdp), intent(in) :: qmat (:,:) real(kind=pfdp), intent(in) :: dt integer, intent(in) :: this_node real(kind=pfdp), intent(in) :: coefs (:,:)","tags":"","loc":"interface/pf_compute_omega_p.html","title":"pf_compute_omega_p – LibPFASST"},{"text":"interface public subroutine pf_propagate_solution_p(this, sol_t0, sol_tn, omega, level) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: sol_t0 class( pf_encap_t ), intent(inout) :: sol_tn class( pf_encap_t ), intent(inout) :: omega integer, intent(in) :: level","tags":"","loc":"interface/pf_propagate_solution_p.html","title":"pf_propagate_solution_p – LibPFASST"},{"text":"public subroutine pf_mpi_create(pf_comm, mpi_comm) Subroutine to create an MPI based PFASST communicator using the MPI communicator mpi_comm .\n assign communicator assign number of processors assign procedure pointers Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(out) :: pf_comm integer, intent(in) :: mpi_comm Contents Source Code pf_mpi_create Source Code subroutine pf_mpi_create ( pf_comm , mpi_comm ) type ( pf_comm_t ), intent ( out ) :: pf_comm integer , intent ( in ) :: mpi_comm integer :: ierror pf_comm % comm = mpi_comm !! assign communicator !> assign number of processors call mpi_comm_size ( mpi_comm , pf_comm % nproc , ierror ) !>  assign procedure pointers pf_comm % post => pf_mpi_post pf_comm % recv => pf_mpi_recv pf_comm % send => pf_mpi_send pf_comm % wait => pf_mpi_wait pf_comm % broadcast => pf_mpi_broadcast pf_comm % recv_status => pf_mpi_recv_status pf_comm % send_status => pf_mpi_send_status end subroutine pf_mpi_create","tags":"","loc":"proc/pf_mpi_create.html","title":"pf_mpi_create – LibPFASST"},{"text":"public subroutine pf_mpi_setup(pf_comm, pf, ierror) Uses pf_mod_mpi Subroutine to set up the PFASST communicator.\n This should be called soon after adding levels to the PFASST controller \n  set the rank allocate arrarys for and and receive requests Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(inout) :: pf_comm communicator type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(inout) :: ierror error flag Contents Source Code pf_mpi_setup Source Code subroutine pf_mpi_setup ( pf_comm , pf , ierror ) use pf_mod_mpi , only : MPI_REQUEST_NULL type ( pf_comm_t ), intent ( inout ) :: pf_comm !!  communicator type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( inout ) :: ierror !!  error flag !>  set the rank call mpi_comm_rank ( pf_comm % comm , pf % rank , ierror ) !>  allocate arrarys for and and receive requests allocate ( pf_comm % recvreq ( pf % nlevels )) allocate ( pf_comm % sendreq ( pf % nlevels )) pf_comm % sendreq = MPI_REQUEST_NULL pf_comm % statreq = - 66 !Tells the first send_status not to wait for previous one to arrive end subroutine pf_mpi_setup","tags":"","loc":"proc/pf_mpi_setup.html","title":"pf_mpi_setup – LibPFASST"},{"text":"public subroutine pf_mpi_destroy(pf_comm) Subroutine to destroy the PFASST communicator. Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(inout) :: pf_comm Contents Source Code pf_mpi_destroy Source Code subroutine pf_mpi_destroy ( pf_comm ) type ( pf_comm_t ), intent ( inout ) :: pf_comm deallocate ( pf_comm % recvreq ) deallocate ( pf_comm % sendreq ) end subroutine pf_mpi_destroy","tags":"","loc":"proc/pf_mpi_destroy.html","title":"pf_mpi_destroy – LibPFASST"},{"text":"public subroutine pf_mpi_post(pf, level, tag, ierror, source) Subroutine to post receive requests. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf class( pf_level_t ), intent(inout) :: level level to send from integer, intent(in) :: tag message tag integer, intent(inout) :: ierror error flag integer, intent(in) :: source Contents Source Code pf_mpi_post Source Code subroutine pf_mpi_post ( pf , level , tag , ierror , source ) type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level !!  level to send from integer , intent ( in ) :: tag !!  message tag integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source call mpi_irecv ( level % recv , level % mpibuflen , myMPI_Datatype , & source , tag , pf % comm % comm , pf % comm % recvreq ( level % index ), ierror ) end subroutine pf_mpi_post","tags":"","loc":"proc/pf_mpi_post.html","title":"pf_mpi_post – LibPFASST"},{"text":"public subroutine pf_mpi_send_status(pf, tag, istatus, ierror, dest) Uses pf_mod_mpi Subroutine to send convergence status information Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: tag message tag integer, intent(in) :: istatus status flag to send integer, intent(inout) :: ierror error flag integer, intent(in) :: dest Contents Source Code pf_mpi_send_status Source Code subroutine pf_mpi_send_status ( pf , tag , istatus , ierror , dest ) use pf_mod_mpi , only : MPI_INTEGER , MPI_STATUS_SIZE , MPI_REQUEST_NULL type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: tag !!  message tag integer , intent ( in ) :: istatus !!  status flag to send integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: dest integer :: stat ( MPI_STATUS_SIZE ) integer :: message message = istatus if ( pf % comm % statreq /= - 66 ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'waiting in send_status with statreq' , pf % comm % statreq call mpi_wait ( pf % comm % statreq , stat , ierror ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'done waiting in send_status' end if call mpi_issend ( message , 1 , MPI_INTEGER , & dest , tag , pf % comm % comm , pf % comm % statreq , ierror ) end subroutine pf_mpi_send_status","tags":"","loc":"proc/pf_mpi_send_status.html","title":"pf_mpi_send_status – LibPFASST"},{"text":"public subroutine pf_mpi_recv_status(pf, tag, istatus, ierror, source) Uses pf_mod_mpi Subroutine to receive convergence status information Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: tag message tag integer, intent(inout) :: istatus status flag to receive integer, intent(inout) :: ierror error flag integer, intent(in) :: source Contents Source Code pf_mpi_recv_status Source Code subroutine pf_mpi_recv_status ( pf , tag , istatus , ierror , source ) use pf_mod_mpi , only : MPI_INTEGER , MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: tag !!  message tag integer , intent ( inout ) :: istatus !!  status flag to receive integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source integer :: stat ( MPI_STATUS_SIZE ) integer :: message ! Get the message call mpi_recv ( message , 1 , MPI_INTEGER , source , tag , pf % comm % comm , stat , ierror ) istatus = message end subroutine pf_mpi_recv_status","tags":"","loc":"proc/pf_mpi_recv_status.html","title":"pf_mpi_recv_status – LibPFASST"},{"text":"public subroutine pf_mpi_send(pf, level, tag, blocking, ierror, dest) Uses pf_mod_mpi Subroutine to send solutions Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: level level to send from integer, intent(in) :: tag message tag logical, intent(in) :: blocking true if send is blocking integer, intent(inout) :: ierror error flag integer, intent(in) :: dest Contents Source Code pf_mpi_send Source Code subroutine pf_mpi_send ( pf , level , tag , blocking , ierror , dest ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: level !!  level to send from integer , intent ( in ) :: tag !!  message tag logical , intent ( in ) :: blocking !!  true if send is blocking integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: dest integer :: stat ( MPI_STATUS_SIZE ) if ( blocking ) then call mpi_send ( level % send , level % mpibuflen , myMPI_Datatype , & dest , tag , pf % comm % comm , stat , ierror ) else call mpi_isend ( level % send , level % mpibuflen , myMPI_Datatype , & dest , tag , pf % comm % comm , pf % comm % sendreq ( level % index ), ierror ) end if end subroutine pf_mpi_send","tags":"","loc":"proc/pf_mpi_send.html","title":"pf_mpi_send – LibPFASST"},{"text":"public subroutine pf_mpi_recv(pf, level, tag, blocking, ierror, source) Uses pf_mod_mpi Subroutine to receive solutions\n Note when blocking == .false. this is actually a wait because the\n nonblocking receive  should have already been posted Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: level level to recieve into integer, intent(in) :: tag message tag logical, intent(in) :: blocking true if receive is blocking integer, intent(inout) :: ierror error flag integer, intent(in) :: source Contents Source Code pf_mpi_recv Source Code subroutine pf_mpi_recv ( pf , level , tag , blocking , ierror , source ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: level !!  level to recieve into integer , intent ( in ) :: tag !!  message tag logical , intent ( in ) :: blocking !!  true if receive is blocking integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source integer :: stat ( MPI_STATUS_SIZE ) if ( blocking ) then call mpi_recv ( level % recv , level % mpibuflen , myMPI_Datatype , & source , tag , pf % comm % comm , stat , ierror ) else call mpi_wait ( pf % comm % recvreq ( level % index ), stat , ierror ) end if end subroutine pf_mpi_recv","tags":"","loc":"proc/pf_mpi_recv.html","title":"pf_mpi_recv – LibPFASST"},{"text":"public subroutine pf_mpi_wait(pf, level, ierror) Uses pf_mod_mpi Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf main pfasst structure integer, intent(in) :: level level on which to wait integer, intent(inout) :: ierror error flag Contents Source Code pf_mpi_wait Source Code subroutine pf_mpi_wait ( pf , level , ierror ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( in ) :: pf !!  main pfasst structure integer , intent ( in ) :: level !!  level on which to wait integer , intent ( inout ) :: ierror !!  error flag integer :: stat ( MPI_STATUS_SIZE ) call mpi_wait ( pf % comm % sendreq ( level ), stat , ierror ) end subroutine pf_mpi_wait","tags":"","loc":"proc/pf_mpi_wait.html","title":"pf_mpi_wait – LibPFASST"},{"text":"public subroutine pf_mpi_broadcast(pf, y, nvar, root, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure real(kind=pfdp), intent(in) :: y (nvar) data to broadcast integer, intent(in) :: nvar size of data to broadcast integer, intent(in) :: root rank of broadcaster integer, intent(inout) :: ierror error flag Contents Source Code pf_mpi_broadcast Source Code subroutine pf_mpi_broadcast ( pf , y , nvar , root , ierror ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: nvar !!  size of data to broadcast real ( pfdp ), intent ( in ) :: y ( nvar ) !!  data to broadcast integer , intent ( in ) :: root !!  rank of broadcaster integer , intent ( inout ) :: ierror !!  error flag call mpi_bcast ( y , nvar , myMPI_Datatype , root , pf % comm % comm , ierror ) end subroutine pf_mpi_broadcast","tags":"","loc":"proc/pf_mpi_broadcast.html","title":"pf_mpi_broadcast – LibPFASST"},{"text":"public subroutine imk_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks Perform nsweep  sweeps on level  and set qend appropriately. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Contents Source Code imk_sweep Source Code subroutine imk_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level this % t0 = t0 this % dt = dt if ( this % rk ) then call rk_step ( this , pf , t0 , dt ) else if ( this % mkrk ) then call mkrk_step ( this , pf , t0 , dt ) else call imk_actually_sweep ( this , pf , level_index , t0 , dt , nsweeps ) end if end subroutine imk_sweep","tags":"","loc":"proc/imk_sweep.html","title":"imk_sweep – LibPFASST"},{"text":"public subroutine rk_step(this, pf, t0, dt) Uses pf_mod_timer pf_mod_hooks Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size Contents Source Code rk_step Source Code subroutine rk_step ( this , pf , t0 , dt ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level integer :: level_index !!  Level to work on integer :: m !!  Loop variables real ( pfdp ) :: t !!  Time at nodes t = t0 + dt level_index = 1 lev => pf % levels ( level_index ) do m = 1 , 5 call lev % Q ( m )% setval ( 0.0_pfdp ) end do call call_hooks ( pf , 1 , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) ! commutator_p flags=1 hack copies Q(1)%y -> Q(1)%array ! all subsequent RK stages are done on Q(m)%array call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 1 ) call lev % Q ( 2 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) ! commutator_p flags=2 hack copies Q(m)%array -> Q(m)%y ! only the Q argument in this case matters ! in order to get solution back to qend call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 5 ), lev % Q ( 5 ), lev % F ( 1 , 1 ), flags = 2 ) call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) call call_hooks ( pf , 1 , PF_POST_SWEEP ) end subroutine rk_step","tags":"","loc":"proc/rk_step.html","title":"rk_step – LibPFASST"},{"text":"public subroutine mkrk_step(this, pf, t0, dt) Uses pf_mod_timer pf_mod_hooks Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size Contents Source Code mkrk_step Source Code subroutine mkrk_step ( this , pf , t0 , dt ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level integer :: level_index !!  Level we are working on integer :: m !!  Loop variables real ( pfdp ) :: t !!  Time at nodes level_index = 1 lev => pf % levels ( level_index ) t = t0 + dt do m = 1 , 5 call lev % Q ( m )% setval ( 0.0_pfdp ) end do call call_hooks ( pf , 1 , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) call this % dexpinv ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 2 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % dexpinv ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 3 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % dexpinv ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 4 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % dexpinv ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 5 )) call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) call call_hooks ( pf , 1 , PF_POST_SWEEP ) end subroutine mkrk_step","tags":"","loc":"proc/mkrk_step.html","title":"mkrk_step – LibPFASST"},{"text":"public subroutine imk_actually_sweep(this, pf, level_index, t0, dt, nsweeps) Uses pf_mod_timer pf_mod_hooks Loop over sweeps\n  Loop over substeps\n  Accumulate rhs\n  Add the tau term Compute explicit function on new value\n  End substep loop Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do Contents Source Code imk_actually_sweep Source Code subroutine imk_actually_sweep ( this , pf , level_index , t0 , dt , nsweeps ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do !>  Local variables type ( pf_level_t ), pointer :: lev !!  points to current level integer :: m , n , k !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( level_index ) !  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) end do if ( level_index < pf % nlevels ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% setval ( 0.0_pfdp ) ! likely an unnecessary setting of Omega=0 call this % evaluate ( pf , level_index , t0 , 1 ) end if t = t0 ! do the sub-stepping in sweep do m = 1 , lev % nnodes - 1 !!  Loop over substeps t = t + dt * this % dtsdc ( m ) !>  Accumulate rhs call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) do n = 1 , m call lev % Q ( m + 1 )% axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) end do !>  Add the tau term call lev % Q ( m + 1 )% axpy ( 1.0_pfdp , lev % I ( m )) !>  Compute explicit function on new value call this % evaluate ( pf , level_index , t , m + 1 ) end do !!  End substep loop call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imk_actually_sweep","tags":"","loc":"proc/imk_actually_sweep.html","title":"imk_actually_sweep – LibPFASST"},{"text":"public subroutine imk_initialize(this, pf, level_index) Assign explicit approximate quadrature rule\n  Make space for temporary variables Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize Contents Source Code imk_initialize Source Code subroutine imk_initialize ( this , pf , level_index ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize integer :: m , nnodes type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 1 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes ), this % QtilE ( nnodes - 1 , nnodes )) allocate ( this % dtsdc ( nnodes - 1 )) allocate ( this % tsdc ( nnodes )) this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) this % bernoullis = 0.0_pfdp this % bernoullis ( 1 ) = - 1.0_pfdp / 2.0_pfdp this % bernoullis ( 2 ) = 1.0_pfdp / 6.0_pfdp this % bernoullis ( 4 ) = - 1.0_pfdp / 3.0e1_pfdp this % bernoullis ( 6 ) = 1.0_pfdp / 4.2e1_pfdp this % bernoullis ( 8 ) = - 1.0_pfdp / 3.0e1_pfdp this % bernoullis ( 10 ) = 5.0_pfdp / 6.6e1_pfdp this % bernoullis ( 12 ) = - 69 1.0_pfdp / 2.73e3_pfdp this % bernoullis ( 14 ) = 7.0_pfdp / 6.0_pfdp this % bernoullis ( 16 ) = - 361 7.0_pfdp / 5.10e2_pfdp this % bernoullis ( 18 ) = 4386 7.0_pfdp / 7.98e2_pfdp this % bernoullis ( 20 ) = - 17461 1.0_pfdp / 33 0.0_pfdp !>  Assign explicit approximate quadrature rule this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE !>  Make space for temporary variables call lev % ulevel % factory % create_array ( this % A , nnodes , & lev % index , lev % shape ) do m = 1 , nnodes call this % A ( m )% setval ( 0.0_pfdp ) end do end subroutine imk_initialize","tags":"","loc":"proc/imk_initialize.html","title":"imk_initialize – LibPFASST"},{"text":"public subroutine imk_integrate(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code imk_integrate Source Code subroutine imk_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: j , m type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer do m = 1 , lev % nnodes - 1 call fintSDC ( m )% setval ( 0.0_pfdp ) do j = 1 , lev % nnodes call fintSDC ( m )% axpy ( dt * lev % sdcmats % qmat ( m , j ), fSDC ( j , 1 )) end do end do end subroutine imk_integrate","tags":"","loc":"proc/imk_integrate.html","title":"imk_integrate – LibPFASST"},{"text":"public subroutine imk_evaluate(this, pf, level_index, t, m, flags, step) Uses pf_mod_dtype Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imk_evaluate Source Code subroutine imk_evaluate ( this , pf , level_index , t , m , flags , step ) use pf_mod_dtype class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , optional , intent ( in ) :: flags , step integer :: i real ( pfdp ) :: dt type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer !  Propagate to get y=exp(Om) !prop needs e&#94;{Q (omega)} and apply to Y if ( this % debug ) & print * , 'level' , lev % index , 'in evaluate ' , m , '------------------' if ( this % rk ) then ! 't' in f_evals are meaningless since i have a time-independent matrix, A dt = this % dt do i = 1 , 5 call lev % Q ( i )% setval ( 0.0_pfdp ) end do call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) ! commutator_p flags=1 hack copies Q(1)%y -> Q(1)%array ! all subsequent RK stages are done on Q(m)%array call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 1 ) call lev % Q ( 2 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) ! commutator_p flags=2 hack copies Q(m)%array -> Q(m)%y ! only the Q argument in this case matters ! in order to get solution back to qend call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 5 ), lev % Q ( 5 ), lev % F ( 1 , 1 ), flags = 2 ) else if ( this % debug ) then endif if ( m > 1 ) then if ( this % debug ) print * , 'propagating' call this % propagate ( lev % q0 , lev % Q ( m )) else if ( this % debug ) print * , 'copying' call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) end if if ( this % debug ) print * , 'Q' if ( this % debug ) call lev % Q ( m )% eprint () !  Compute A(y,t) call this % f_eval ( lev % Q ( m ), t , lev % index , this % A ( m )) if ( this % debug ) print * , 'A' if ( this % debug ) call this % A ( m )% eprint () !  Compute the series expansion for dexpinv if ( m > 1 ) then call this % dexpinv ( this % A ( m ), lev % Q ( m ), lev % F ( m , 1 )) else call lev % F ( 1 , 1 )% copy ( this % A ( 1 )) endif if ( this % debug ) print * , 'depxinv' if ( this % debug ) call lev % F ( m , 1 )% eprint () endif if ( this % debug ) print * , 'end evaluate ------------' end subroutine imk_evaluate","tags":"","loc":"proc/imk_evaluate.html","title":"imk_evaluate – LibPFASST"},{"text":"public subroutine imk_evaluate_all(this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imk_evaluate_all Source Code subroutine imk_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step integer :: m type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer if ( this % rk ) then call lev % ulevel % sweeper % evaluate ( pf , level_index , t ( 1 ), 1 ) else do m = 1 , lev % nnodes call lev % ulevel % sweeper % evaluate ( pf , level_index , t ( m ), m ) end do end if end subroutine imk_evaluate_all","tags":"","loc":"proc/imk_evaluate_all.html","title":"imk_evaluate_all – LibPFASST"},{"text":"public subroutine imk_residual(this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code imk_residual Source Code subroutine imk_residual ( this , pf , level_index , dt , flags ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call lev % ulevel % sweeper % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I ) ! add tau (which is 'node to node') if ( level_index < pf % nlevels ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end do end if ! subtract out Q  (not initial condition is zero do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine imk_residual","tags":"","loc":"proc/imk_residual.html","title":"imk_residual – LibPFASST"},{"text":"public subroutine imk_spreadq0(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imk_spreadq0 Source Code subroutine imk_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer m , p type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) ! set initial omega to 0 call lev % Q ( 1 )% setval ( 0.0_pfdp ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , 1 ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), flags = 1 ) call lev % Q ( m )% copy ( lev % Q ( 1 )) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p )) end do end do end subroutine imk_spreadq0","tags":"","loc":"proc/imk_spreadq0.html","title":"imk_spreadq0 – LibPFASST"},{"text":"public subroutine imk_save(lev) Save function values so that difference can be computed Arguments Type Intent Optional Attributes Name type( pf_level_t ), intent(inout) :: lev Level to save on Contents Source Code imk_save Source Code subroutine imk_save ( lev ) type ( pf_level_t ), intent ( inout ) :: lev !!  Level to save on integer :: m do m = 1 , lev % nnodes call lev % pF ( m , 1 )% copy ( lev % F ( m , 1 )) end do end subroutine imk_save","tags":"","loc":"proc/imk_save.html","title":"imk_save – LibPFASST"},{"text":"public subroutine imk_destroy(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize Contents Source Code imk_destroy Source Code subroutine imk_destroy ( this , pf , level_index ) class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to initialize type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % QtilE , this % QdiffE ) deallocate ( this % dtsdc ) deallocate ( this % tsdc ) call lev % ulevel % factory % destroy_array ( this % A ) end subroutine imk_destroy","tags":"","loc":"proc/imk_destroy.html","title":"imk_destroy – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, f) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer(kind=c_int), intent(in) :: level class( pf_encap_t ), intent(inout) :: f Description Subroutine f_eval computes A(y,t)","tags":"","loc":"interface/pf_f_eval_p~7.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_dexpinv_p(this, a, omega, f) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: f The result Description Subroutine dexpinv computes Om'=F=dexpinv_Om(A)","tags":"","loc":"interface/pf_dexpinv_p.html","title":"pf_dexpinv_p – LibPFASST"},{"text":"interface public subroutine pf_propagate_p(this, q0, q) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: q0 class( pf_encap_t ), intent(inout) :: q Description Subroutine propagate   computes y_m=expm(Om_m)y_0(expm(Om_m))-1 or (expm(Om_m))y_0 or","tags":"","loc":"interface/pf_propagate_p.html","title":"pf_propagate_p – LibPFASST"},{"text":"interface public subroutine pf_commutator_p(this, a, b, out, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: b class( pf_encap_t ), intent(inout) :: out integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_commutator_p.html","title":"pf_commutator_p – LibPFASST"},{"text":"public function cast_as_zndarray(encap_polymorph) result(zndarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( zndarray ),\n  pointer Contents Source Code cast_as_zndarray Source Code function cast_as_zndarray ( encap_polymorph ) result ( zndarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( zndarray ), pointer :: zndarray_obj select type ( encap_polymorph ) type is ( zndarray ) zndarray_obj => encap_polymorph end select end function cast_as_zndarray","tags":"","loc":"proc/cast_as_zndarray.html","title":"cast_as_zndarray – LibPFASST"},{"text":"public function zndarray_norm(this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code zndarray_norm Source Code function zndarray_norm ( this , flags ) result ( norm ) class ( zndarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function zndarray_norm","tags":"","loc":"proc/zndarray_norm.html","title":"zndarray_norm – LibPFASST"},{"text":"public function get_array1d(x, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d Source Code function get_array1d ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:) select type ( x ) type is ( zndarray ) r => x % flatarray end select end function get_array1d","tags":"","loc":"proc/get_array1d.html","title":"get_array1d – LibPFASST"},{"text":"public function get_array2d(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d Source Code function get_array2d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( zndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % flatarray end select end function get_array2d","tags":"","loc":"proc/get_array2d.html","title":"get_array2d – LibPFASST"},{"text":"public function get_array3d(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d Source Code function get_array3d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( zndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % flatarray end select end function get_array3d","tags":"","loc":"proc/get_array3d.html","title":"get_array3d – LibPFASST"},{"text":"public subroutine zndarray_build(q, shape) Allocates complex ndarray Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) Contents Source Code zndarray_build Source Code subroutine zndarray_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) type ( zndarray ), pointer :: zndarray_obj select type ( q ) class is ( zndarray ) allocate ( q % shape ( size ( shape ))) allocate ( q % flatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape q % flatarray = cmplx ( 0.0 , 0.0 , pfdp ) end select nullify ( zndarray_obj ) end subroutine zndarray_build","tags":"","loc":"proc/zndarray_build.html","title":"zndarray_build – LibPFASST"},{"text":"public subroutine zndarray_destroy(encap) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Contents Source Code zndarray_destroy Source Code subroutine zndarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( zndarray ), pointer :: zndarray_obj zndarray_obj => cast_as_zndarray ( encap ) deallocate ( zndarray_obj % shape ) deallocate ( zndarray_obj % flatarray ) nullify ( zndarray_obj ) end subroutine zndarray_destroy","tags":"","loc":"proc/zndarray_destroy.html","title":"zndarray_destroy – LibPFASST"},{"text":"public subroutine zndarray_create_single(this, x, level, shape) Wrapper routine for allocation of a single zndarray type array Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndarray_create_single Source Code subroutine zndarray_create_single ( this , x , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( zndarray :: x ) call zndarray_build ( x , shape ) end subroutine zndarray_create_single","tags":"","loc":"proc/zndarray_create_single.html","title":"zndarray_create_single – LibPFASST"},{"text":"public subroutine zndarray_create_array(this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndarray_create_array Source Code subroutine zndarray_create_array ( this , x , n , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( zndarray :: x ( n )) do i = 1 , n call zndarray_build ( x ( i ), shape ) end do end subroutine zndarray_create_array","tags":"","loc":"proc/zndarray_create_array.html","title":"zndarray_create_array – LibPFASST"},{"text":"public subroutine zndarray_destroy_single(this, x) Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x Contents Source Code zndarray_destroy_single Source Code subroutine zndarray_destroy_single ( this , x ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( zndarray ) deallocate ( x % shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine zndarray_destroy_single","tags":"","loc":"proc/zndarray_destroy_single.html","title":"zndarray_destroy_single – LibPFASST"},{"text":"public subroutine zndarray_destroy_array(this, x) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Contents Source Code zndarray_destroy_array Source Code subroutine zndarray_destroy_array ( this , x ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( zndarray ) do i = 1 , size ( x ) deallocate ( x ( i )% shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine zndarray_destroy_array","tags":"","loc":"proc/zndarray_destroy_array.html","title":"zndarray_destroy_array – LibPFASST"},{"text":"public subroutine zndarray_setval(this, val, flags) Set solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code zndarray_setval Source Code subroutine zndarray_setval ( this , val , flags ) class ( zndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags complex ( pfdp ) :: zval zval = cmplx ( val , 0.0 , pfdp ) this % flatarray = zval end subroutine zndarray_setval","tags":"","loc":"proc/zndarray_setval.html","title":"zndarray_setval – LibPFASST"},{"text":"public subroutine zndarray_copy(this, src, flags) Copy solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Contents Source Code zndarray_copy Source Code subroutine zndarray_copy ( this , src , flags ) class ( zndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags class ( zndarray ), pointer :: zndarray_src zndarray_src => cast_as_zndarray ( src ) this % flatarray = zndarray_src % flatarray end subroutine zndarray_copy","tags":"","loc":"proc/zndarray_copy.html","title":"zndarray_copy – LibPFASST"},{"text":"public subroutine zndarray_pack(this, z, flags) Pack solution q into a flat array. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code zndarray_pack Source Code subroutine zndarray_pack ( this , z , flags ) class ( zndarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: i do i = 1 , product ( this % shape ) z ( 2 * i - 1 ) = real ( this % flatarray ( i )) z ( 2 * i ) = aimag ( this % flatarray ( i )) end do end subroutine zndarray_pack","tags":"","loc":"proc/zndarray_pack.html","title":"zndarray_pack – LibPFASST"},{"text":"public subroutine zndarray_unpack(this, z, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code zndarray_unpack Source Code subroutine zndarray_unpack ( this , z , flags ) class ( zndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: i do i = 1 , product ( this % shape ) this % flatarray ( i ) = cmplx ( z ( 2 * i - 1 ), z ( 2 * i ), pfdp ) enddo end subroutine zndarray_unpack","tags":"","loc":"proc/zndarray_unpack.html","title":"zndarray_unpack – LibPFASST"},{"text":"public subroutine zndarray_axpy(this, a, x, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Contents Source Code zndarray_axpy Source Code subroutine zndarray_axpy ( this , a , x , flags ) class ( zndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags class ( zndarray ), pointer :: zndarray_obj zndarray_obj => cast_as_zndarray ( x ) this % flatarray = a * zndarray_obj % flatarray + this % flatarray end subroutine zndarray_axpy","tags":"","loc":"proc/zndarray_axpy.html","title":"zndarray_axpy – LibPFASST"},{"text":"public subroutine zndarray_eprint(this, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code zndarray_eprint Source Code subroutine zndarray_eprint ( this , flags ) class ( zndarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags print * , this % flatarray ( 1 : 2 ) end subroutine zndarray_eprint","tags":"","loc":"proc/zndarray_eprint.html","title":"zndarray_eprint – LibPFASST"},{"text":"public subroutine write_to_disk(this, filename) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this character(len=*), intent(in) :: filename Contents Source Code write_to_disk Source Code subroutine write_to_disk ( this , filename ) class ( zndarray ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename complex ( pfdp ), pointer :: z_array (:,:) open ( unit = 1 , file = trim ( filename ), form = 'unformatted' ) write ( 1 ) this % flatarray !z_array=>get_array2d(this) !write(1) z_array close ( 1 ) end subroutine write_to_disk","tags":"","loc":"proc/write_to_disk.html","title":"write_to_disk – LibPFASST"},{"text":"interface Interfaces for subroutines public function pf_encap_norm_p(this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp)","tags":"","loc":"interface/pf_encap_norm_p.html","title":"pf_encap_norm_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_hook_p(pf, level_index) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index Description hooks subroutines","tags":"","loc":"interface/pf_hook_p.html","title":"pf_hook_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_sweep_p(this, pf, level_index, t0, dt, nsweeps, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags Description SDC sweeper subroutines","tags":"","loc":"interface/pf_sweep_p.html","title":"pf_sweep_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_evaluate_p(this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"interface/pf_evaluate_p.html","title":"pf_evaluate_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_evaluate_all_p(this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"interface/pf_evaluate_all_p.html","title":"pf_evaluate_all_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_initialize_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index","tags":"","loc":"interface/pf_initialize_p.html","title":"pf_initialize_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_destroy_sweeper_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index","tags":"","loc":"interface/pf_destroy_sweeper_p.html","title":"pf_destroy_sweeper_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_integrate_p(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt Time step size class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_integrate_p.html","title":"pf_integrate_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_residual_p(this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step size integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_residual_p.html","title":"pf_residual_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_spreadq0_p(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"interface/pf_spreadq0_p.html","title":"pf_spreadq0_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_destroy_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index","tags":"","loc":"interface/pf_destroy_p.html","title":"pf_destroy_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_do_n_steps_p(this, pf, level_index, t0, q0, qend, big_dt, nsteps_rk) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 class( pf_encap_t ), intent(in) :: q0 Starting value class( pf_encap_t ), intent(inout) :: qend Final value real(kind=pfdp), intent(in) :: big_dt Time step size integer, intent(in) :: nsteps_rk Description time stepper interfaces","tags":"","loc":"interface/pf_do_n_steps_p.html","title":"pf_do_n_steps_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_initialize_stepper_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index","tags":"","loc":"interface/pf_initialize_stepper_p.html","title":"pf_initialize_stepper_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_destroy_stepper_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index","tags":"","loc":"interface/pf_destroy_stepper_p.html","title":"pf_destroy_stepper_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_transfer_p(this, f_lev, c_lev, f_vec, c_vec, t, flags) Arguments Type Intent Optional Attributes Name class( pf_user_level_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: f_lev class( pf_level_t ), intent(inout) :: c_lev class( pf_encap_t ), intent(inout) :: f_vec class( pf_encap_t ), intent(inout) :: c_vec real(kind=pfdp), intent(in) :: t integer, intent(in), optional :: flags Description transfer interfaces used for restriction and interpolation","tags":"","loc":"interface/pf_transfer_p.html","title":"pf_transfer_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_create_single_p(this, x, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Description encapsulation interfaces","tags":"","loc":"interface/pf_encap_create_single_p.html","title":"pf_encap_create_single_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_create_array_p(this, x, n, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:)","tags":"","loc":"interface/pf_encap_create_array_p.html","title":"pf_encap_create_array_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_destroy_single_p(this, x) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x","tags":"","loc":"interface/pf_encap_destroy_single_p.html","title":"pf_encap_destroy_single_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_destroy_array_p(this, x) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:)","tags":"","loc":"interface/pf_encap_destroy_array_p.html","title":"pf_encap_destroy_array_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_setval_p(this, val, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_setval_p.html","title":"pf_encap_setval_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_copy_p(this, src, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_copy_p.html","title":"pf_encap_copy_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_pack_p(this, z, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_pack_p.html","title":"pf_encap_pack_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_unpack_p(this, z, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_unpack_p.html","title":"pf_encap_unpack_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_axpy_p(this, a, x, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_axpy_p.html","title":"pf_encap_axpy_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_eprint_p(this, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_eprint_p.html","title":"pf_encap_eprint_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_post_p(pf, level, tag, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag integer, intent(inout) :: ierror integer, intent(in) :: source Description communicator interfaces","tags":"","loc":"interface/pf_post_p.html","title":"pf_post_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_recv_p(pf, level, tag, blocking, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(inout) :: ierror integer, intent(in) :: source","tags":"","loc":"interface/pf_recv_p.html","title":"pf_recv_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_recv_status_p(pf, tag, istatus, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: tag integer, intent(inout) :: istatus integer, intent(inout) :: ierror integer, intent(in) :: source","tags":"","loc":"interface/pf_recv_status_p.html","title":"pf_recv_status_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_send_p(pf, level, tag, blocking, ierror, dest) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(inout) :: ierror integer, intent(in) :: dest","tags":"","loc":"interface/pf_send_p.html","title":"pf_send_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_send_status_p(pf, tag, istatus, ierror, dest) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in) :: istatus integer, intent(inout) :: ierror integer, intent(in) :: dest","tags":"","loc":"interface/pf_send_status_p.html","title":"pf_send_status_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_wait_p(pf, level, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf integer, intent(in) :: level integer, intent(inout) :: ierror","tags":"","loc":"interface/pf_wait_p.html","title":"pf_wait_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_broadcast_p(pf, y, nvar, root, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf real(kind=pfdp), intent(in) :: y (nvar) integer, intent(in) :: nvar integer, intent(in) :: root integer, intent(inout) :: ierror","tags":"","loc":"interface/pf_broadcast_p.html","title":"pf_broadcast_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_results_p(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this","tags":"","loc":"interface/pf_results_p.html","title":"pf_results_p – LibPFASST"},{"text":"public function zndsysarray_norm(this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code zndsysarray_norm Source Code function zndsysarray_norm ( this , flags ) result ( norm ) class ( zndsysarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function zndsysarray_norm","tags":"","loc":"proc/zndsysarray_norm.html","title":"zndsysarray_norm – LibPFASST"},{"text":"public function cast_as_zndsysarray(encap_polymorph) result(zndsysarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( zndsysarray ),\n  pointer Contents Source Code cast_as_zndsysarray Source Code function cast_as_zndsysarray ( encap_polymorph ) result ( zndsysarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( zndsysarray ), pointer :: zndsysarray_obj select type ( encap_polymorph ) type is ( zndsysarray ) zndsysarray_obj => encap_polymorph end select end function cast_as_zndsysarray","tags":"","loc":"proc/cast_as_zndsysarray.html","title":"cast_as_zndsysarray – LibPFASST"},{"text":"public function get_array1d(x, n, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d Source Code function get_array1d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:) select type ( x ) type is ( zndsysarray ) r => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array1d","tags":"","loc":"proc/get_array1d~2.html","title":"get_array1d – LibPFASST"},{"text":"public function get_array2d(x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d Source Code function get_array2d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( zndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array2d","tags":"","loc":"proc/get_array2d~2.html","title":"get_array2d – LibPFASST"},{"text":"public function get_array3d(x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d Source Code function get_array3d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( zndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 ), 1 : x % arr_shape ( 3 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array3d","tags":"","loc":"proc/get_array3d~2.html","title":"get_array3d – LibPFASST"},{"text":"public subroutine zndsysarray_build(q, arr_shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: arr_shape (:) Contents Source Code zndsysarray_build Source Code subroutine zndsysarray_build ( q , arr_shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: arr_shape (:) select type ( q ) class is ( zndsysarray ) allocate ( q % arr_shape ( size ( arr_shape ))) q % dim = size ( arr_shape ) - 1 q % ncomp = arr_shape ( q % dim + 1 ) q % ndof = product ( arr_shape ( 1 : q % dim )) q % arr_shape = arr_shape allocate ( q % flatarray ( product ( arr_shape ))) end select end subroutine zndsysarray_build","tags":"","loc":"proc/zndsysarray_build.html","title":"zndsysarray_build – LibPFASST"},{"text":"public subroutine zndsysarray_create_single(this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndsysarray_create_single Source Code subroutine zndsysarray_create_single ( this , x , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) integer :: i allocate ( zndsysarray :: x ) call zndsysarray_build ( x , shape ) end subroutine zndsysarray_create_single","tags":"","loc":"proc/zndsysarray_create_single.html","title":"zndsysarray_create_single – LibPFASST"},{"text":"public subroutine zndsysarray_create_array(this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndsysarray_create_array Source Code subroutine zndsysarray_create_array ( this , x , n , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( zndsysarray :: x ( n )) do i = 1 , n call zndsysarray_build ( x ( i ), shape ) end do end subroutine zndsysarray_create_array","tags":"","loc":"proc/zndsysarray_create_array.html","title":"zndsysarray_create_array – LibPFASST"},{"text":"public subroutine zndsysarray_destroy(encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Contents Source Code zndsysarray_destroy Source Code subroutine zndsysarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( zndsysarray ), pointer :: zndsysarray_obj zndsysarray_obj => cast_as_zndsysarray ( encap ) deallocate ( zndsysarray_obj % arr_shape ) deallocate ( zndsysarray_obj % flatarray ) nullify ( zndsysarray_obj ) end subroutine zndsysarray_destroy","tags":"","loc":"proc/zndsysarray_destroy.html","title":"zndsysarray_destroy – LibPFASST"},{"text":"public subroutine zndsysarray_destroy_single(this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x Contents Source Code zndsysarray_destroy_single Source Code subroutine zndsysarray_destroy_single ( this , x ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( zndsysarray ) deallocate ( x % arr_shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine zndsysarray_destroy_single","tags":"","loc":"proc/zndsysarray_destroy_single.html","title":"zndsysarray_destroy_single – LibPFASST"},{"text":"public subroutine zndsysarray_destroy_array(this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Contents Source Code zndsysarray_destroy_array Source Code subroutine zndsysarray_destroy_array ( this , x ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( zndsysarray ) do i = 1 , size ( x ) deallocate ( x ( i )% arr_shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine zndsysarray_destroy_array","tags":"","loc":"proc/zndsysarray_destroy_array.html","title":"zndsysarray_destroy_array – LibPFASST"},{"text":"public subroutine zndsysarray_setval(this, val, flags) The following are the base subroutines that all encapsulations must provide Subroutine to set array to a scalare  value. Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code zndsysarray_setval Source Code subroutine zndsysarray_setval ( this , val , flags ) class ( zndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine zndsysarray_setval","tags":"","loc":"proc/zndsysarray_setval.html","title":"zndsysarray_setval – LibPFASST"},{"text":"public subroutine zndsysarray_copy(this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Contents Source Code zndsysarray_copy Source Code subroutine zndsysarray_copy ( this , src , flags ) class ( zndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( zndsysarray ) this % flatarray = src % flatarray class default stop \"TYPE ERROR\" end select end subroutine zndsysarray_copy","tags":"","loc":"proc/zndsysarray_copy.html","title":"zndsysarray_copy – LibPFASST"},{"text":"public subroutine zndsysarray_pack(this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code zndsysarray_pack Source Code subroutine zndsysarray_pack ( this , z , flags ) class ( zndsysarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: ntot ntot = this % ndof * this % ncomp z ( 1 : ntot ) = real ( this % flatarray , pfdp ) z ( ntot + 1 : 2 * ntot ) = aimag ( this % flatarray ) end subroutine zndsysarray_pack","tags":"","loc":"proc/zndsysarray_pack.html","title":"zndsysarray_pack – LibPFASST"},{"text":"public subroutine zndsysarray_unpack(this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code zndsysarray_unpack Source Code subroutine zndsysarray_unpack ( this , z , flags ) class ( zndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: ntot ntot = this % ndof * this % ncomp this % flatarray = z ( 1 : ntot ) this % flatarray = this % flatarray + cmplx ( 0.0 , 1.0 , pfdp ) * z ( ntot + 1 : 2 * ntot ) this % flatarray = cmplx ( z ( 1 : ntot ), z ( ntot + 1 : 2 * ntot )) end subroutine zndsysarray_unpack","tags":"","loc":"proc/zndsysarray_unpack.html","title":"zndsysarray_unpack – LibPFASST"},{"text":"public subroutine zndsysarray_axpy(this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Contents Source Code zndsysarray_axpy Source Code subroutine zndsysarray_axpy ( this , a , x , flags ) class ( zndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( zndsysarray ) this % flatarray = a * x % flatarray + this % flatarray class default stop \"TYPE ERROR\" end select end subroutine zndsysarray_axpy","tags":"","loc":"proc/zndsysarray_axpy.html","title":"zndsysarray_axpy – LibPFASST"},{"text":"public subroutine zndsysarray_eprint(this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code zndsysarray_eprint Source Code subroutine zndsysarray_eprint ( this , flags ) class ( zndsysarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % flatarray ( 1 : 10 ) !print *, this%flatarray end subroutine zndsysarray_eprint","tags":"","loc":"proc/zndsysarray_eprint.html","title":"zndsysarray_eprint – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine zndsysarray_dump_numpy(dname, fname, endian, dim, mpibuflen, arr_shape, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: arr_shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Description Subroutine to write an the array to a file","tags":"","loc":"interface/zndsysarray_dump_numpy.html","title":"zndsysarray_dump_numpy – LibPFASST"},{"text":"public function ad_cos_ex(t, x, nu, v, kfreq, Lx) result(u) Routine to return the exact solution for advection diffusion\n Routine to return the exact solution for advection diffusion Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx Return Value real(kind=pfdp) Contents Source Code ad_cos_ex Source Code function ad_cos_ex ( t , x , nu , v , kfreq , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: v real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: kfreq real ( pfdp ), intent ( in ) :: Lx real ( pfdp ) :: u real ( pfdp ) :: omega omega = kfreq * two_pi / Lx u = cos ( omega * ( x - t * v )) * exp ( - omega * omega * nu * t ) end function ad_cos_ex","tags":"","loc":"proc/ad_cos_ex.html","title":"ad_cos_ex – LibPFASST"},{"text":"public function ad_exp_ex(t, x, nu, v, Lx) result(u) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx Return Value real(kind=pfdp) Contents Source Code ad_exp_ex Source Code function ad_exp_ex ( t , x , nu , v , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: v real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx real ( pfdp ) :: u integer :: nx , i , ii , k , nbox real ( pfdp ) :: xx , c , t0 u = 0.0_pfdp if ( nu . gt . 0.0 ) then t0 = 0.0025_pfdp / nu nbox = ceiling ( sqrt ( 4.0_pfdp * nu * ( t0 + t ) * 3 7.0_pfdp )) !  Decide how many periodic images do k = - nbox , nbox xx = x - 0.5_pfdp * Lx - t * v + real ( k , pfdp ) * Lx u = u + sqrt ( t0 ) / sqrt ( t0 + t ) * exp ( - xx * xx / ( 4.0_pfdp * nu * ( t0 + t ))) end do else nbox = ceiling ( sqrt ( 3 7.0d0 )) !  Decide how many periodic images do k = - nbox , nbox xx = x - 0.5_pfdp * Lx - t * v + real ( k , pfdp ) * Lx u = u + exp ( - xx * xx / ( 4.0_pfdp * 0.0025_pfdp )) end do end if end function ad_exp_ex","tags":"","loc":"proc/ad_exp_ex.html","title":"ad_exp_ex – LibPFASST"},{"text":"public function burg_sin_ex(t, x, nu, Lx) result(u) Routine to return the exact solution for inviscid Burgers based on Platzman\nSee \"A Simple Illustration of a Weak Spectral Cascade\", Muraki D,SIAM J Appl Math,2007 Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx Return Value real(kind=pfdp) Contents Source Code burg_sin_ex Source Code function burg_sin_ex ( t , x , nu , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx real ( pfdp ) :: u real ( pfdp ) :: rn , ts , xs , a , b , c , phi , dphi , o1 , o2 integer :: n , nterms nterms = 100 u = 0.0_pfdp xs = x * two_pi / Lx ts = t * two_pi / Lx if ( t . gt . 0.0_pfdp ) then do n = nterms , 1 , - 1 rn = real ( n , pfdp ) u = u - 2.0_pfdp * bessel_jn ( n , rn * ts ) / ( rn * ts ) * sin ( rn * xs ) end do else u =- sin ( xs ) end if end function burg_sin_ex","tags":"","loc":"proc/burg_sin_ex.html","title":"burg_sin_ex – LibPFASST"},{"text":"public function nls_ex(t, x, Lx) result(u) Routine to return the exact solution for the nonlinear Schoedinger Eq  u_t=i2}u|&#94;2u +i u_xx\nSee Tuncay Aktosun et al 2007 Inverse Problems 23 217\n  Note the domain size should be 2*pi Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: Lx Return Value complex(kind=pfdp) Contents Source Code nls_ex Source Code function nls_ex ( t , x , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: Lx complex ( pfdp ) :: u real ( pfdp ) :: a , b , taa , c complex ( pfdp ) :: ae , dn a = 1.0_pfdp / sqrt ( 2.0_pfdp ) b = 1.0_pfdp taa = 1.0_pfdp ae = a * exp ( zi * t ) dn = cosh ( t ) + zi * sinh ( t ) c = 4.0_pfdp u = exp ( zi * c * ( x - c * t )) * ae * ( dn / ( cosh ( t ) - sqrt ( 2.0_pfdp ) / 2.0_pfdp * cos ( x - 2.0_pfdp * c * t )) - 1.0_pfdp ) end function nls_ex","tags":"","loc":"proc/nls_ex.html","title":"nls_ex – LibPFASST"},{"text":"public function kdv_ex(t, x, beta, Lx) result(u) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx Return Value real(kind=pfdp) Contents Source Code kdv_ex Source Code function kdv_ex ( t , x , beta , Lx ) result ( u ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: beta real ( pfdp ), intent ( in ) :: Lx real ( pfdp ) :: u real ( pfdp ) :: a , s a = beta * ( x - 0.375_pfdp * Lx - t ) s = 2.0_pfdp / ( exp ( a ) + exp ( - a )) u = s * s end function kdv_ex","tags":"","loc":"proc/kdv_ex.html","title":"kdv_ex – LibPFASST"},{"text":"public subroutine exact_ad_cos_1d(t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_ad_cos_1d Source Code subroutine exact_ad_cos_1d ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu , v , kfreq , Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = ad_cos_ex ( t , x , nu , v , kfreq , Lx ) end do end subroutine exact_ad_cos_1d","tags":"","loc":"proc/exact_ad_cos_1d.html","title":"exact_ad_cos_1d – LibPFASST"},{"text":"public subroutine exact_ad_cos_1dz(t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_ad_cos_1dz Source Code subroutine exact_ad_cos_1dz ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu , v , kfreq , Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = ad_cos_ex ( t , x , nu , v , kfreq , Lx ) end do end subroutine exact_ad_cos_1dz","tags":"","loc":"proc/exact_ad_cos_1dz.html","title":"exact_ad_cos_1dz – LibPFASST"},{"text":"public subroutine exact_ad_cos_2d(t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: kfreq (2) real(kind=pfdp), intent(in) :: Lx (2) Contents Source Code exact_ad_cos_2d Source Code subroutine exact_ad_cos_2d ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy nx = size ( uex , 1 ) ny = size ( uex , 2 ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_cos_ex ( t , y , nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = ad_cos_ex ( t , x , nu , v ( 1 ), kfreq ( 1 ), Lx ( 1 )) * uy end do end do end subroutine exact_ad_cos_2d","tags":"","loc":"proc/exact_ad_cos_2d.html","title":"exact_ad_cos_2d – LibPFASST"},{"text":"public subroutine exact_ad_cos_2dz(t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: kfreq (2) real(kind=pfdp), intent(in) :: Lx (2) Contents Source Code exact_ad_cos_2dz Source Code subroutine exact_ad_cos_2dz ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy nx = size ( uex , 1 ) ny = size ( uex , 2 ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_cos_ex ( t , y , nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = ad_cos_ex ( t , x , nu , v ( 1 ), kfreq ( 1 ), Lx ( 1 )) * uy end do end do end subroutine exact_ad_cos_2dz","tags":"","loc":"proc/exact_ad_cos_2dz.html","title":"exact_ad_cos_2dz – LibPFASST"},{"text":"public subroutine exact_ad_cos_3d(t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: kfreq (3) real(kind=pfdp), intent(in) :: Lx (3) Contents Source Code exact_ad_cos_3d Source Code subroutine exact_ad_cos_3d ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu , v ( 3 ), kfreq ( 3 ), Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , uy , uz nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) uz = ad_cos_ex ( t , z , nu , v ( 3 ), kfreq ( 3 ), Lx ( 3 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_cos_ex ( t , y , nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = ad_cos_ex ( t , x , nu , v ( 1 ), kfreq ( 1 ), Lx ( 1 )) * uy * uz end do end do end do end subroutine exact_ad_cos_3d","tags":"","loc":"proc/exact_ad_cos_3d.html","title":"exact_ad_cos_3d – LibPFASST"},{"text":"public subroutine exact_ad_cos_3dz(t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: kfreq (3) real(kind=pfdp), intent(in) :: Lx (3) Contents Source Code exact_ad_cos_3dz Source Code subroutine exact_ad_cos_3dz ( t , uex , nu , v , kfreq , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu , v ( 3 ), kfreq ( 3 ), Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , uy , uz nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) uz = ad_cos_ex ( t , z , nu , v ( 3 ), kfreq ( 3 ), Lx ( 3 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_cos_ex ( t , y , nu , v ( 2 ), kfreq ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = ad_cos_ex ( t , x , nu , v ( 1 ), kfreq ( 1 ), Lx ( 1 )) * uy * uz end do end do end do end subroutine exact_ad_cos_3dz","tags":"","loc":"proc/exact_ad_cos_3dz.html","title":"exact_ad_cos_3dz – LibPFASST"},{"text":"public subroutine exact_ad_exp_1d(t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_ad_exp_1d Source Code subroutine exact_ad_exp_1d ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu , v , Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = ad_exp_ex ( t , x , nu , v , Lx ) end do end subroutine exact_ad_exp_1d","tags":"","loc":"proc/exact_ad_exp_1d.html","title":"exact_ad_exp_1d – LibPFASST"},{"text":"public subroutine exact_ad_exp_1dz(t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_ad_exp_1dz Source Code subroutine exact_ad_exp_1dz ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu , v , Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = ad_exp_ex ( t , x , nu , v , Lx ) end do end subroutine exact_ad_exp_1dz","tags":"","loc":"proc/exact_ad_exp_1dz.html","title":"exact_ad_exp_1dz – LibPFASST"},{"text":"public subroutine exact_ad_exp_2d(t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: Lx (2) Contents Source Code exact_ad_exp_2d Source Code subroutine exact_ad_exp_2d ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu , v ( 2 ), Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy nx = size ( uex , 1 ) ny = size ( uex , 2 ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_exp_ex ( t , y , nu , v ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = ad_exp_ex ( t , x , nu , v ( 1 ), Lx ( 1 )) * uy end do end do end subroutine exact_ad_exp_2d","tags":"","loc":"proc/exact_ad_exp_2d.html","title":"exact_ad_exp_2d – LibPFASST"},{"text":"public subroutine exact_ad_exp_2dz(t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: Lx (2) Contents Source Code exact_ad_exp_2dz Source Code subroutine exact_ad_exp_2dz ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu , v ( 2 ), Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy nx = size ( uex , 1 ) ny = size ( uex , 2 ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_exp_ex ( t , y , nu , v ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = ad_exp_ex ( t , x , nu , v ( 1 ), Lx ( 1 )) * uy end do end do end subroutine exact_ad_exp_2dz","tags":"","loc":"proc/exact_ad_exp_2dz.html","title":"exact_ad_exp_2dz – LibPFASST"},{"text":"public subroutine exact_ad_exp_3d(t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: Lx (3) Contents Source Code exact_ad_exp_3d Source Code subroutine exact_ad_exp_3d ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu , v ( 3 ), Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , uy , uz nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) uz = ad_exp_ex ( t , z , nu , v ( 3 ), Lx ( 3 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_exp_ex ( t , y , nu , v ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = ad_exp_ex ( t , x , nu , v ( 1 ), Lx ( 1 )) * uy * uz end do end do end do end subroutine exact_ad_exp_3d","tags":"","loc":"proc/exact_ad_exp_3d.html","title":"exact_ad_exp_3d – LibPFASST"},{"text":"public subroutine exact_ad_exp_3dz(t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: Lx (3) Contents Source Code exact_ad_exp_3dz Source Code subroutine exact_ad_exp_3dz ( t , uex , nu , v , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu , v ( 3 ), Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , uy , uz nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) uz = ad_exp_ex ( t , z , nu , v ( 3 ), Lx ( 3 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) uy = ad_exp_ex ( t , y , nu , v ( 2 ), Lx ( 2 )) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = ad_exp_ex ( t , x , nu , v ( 1 ), Lx ( 1 )) * uy * uz end do end do end do end subroutine exact_ad_exp_3dz","tags":"","loc":"proc/exact_ad_exp_3dz.html","title":"exact_ad_exp_3dz – LibPFASST"},{"text":"public subroutine exact_burg_sin_1d(t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_burg_sin_1d Source Code subroutine exact_burg_sin_1d ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = burg_sin_ex ( t , x , nu , Lx ) end do end subroutine exact_burg_sin_1d","tags":"","loc":"proc/exact_burg_sin_1d.html","title":"exact_burg_sin_1d – LibPFASST"},{"text":"public subroutine exact_burg_sin_1dz(t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_burg_sin_1dz Source Code subroutine exact_burg_sin_1dz ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = burg_sin_ex ( t , x , nu , Lx ) end do end subroutine exact_burg_sin_1dz","tags":"","loc":"proc/exact_burg_sin_1dz.html","title":"exact_burg_sin_1dz – LibPFASST"},{"text":"public subroutine exact_burg_sin_2d(t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (2) Contents Source Code exact_burg_sin_2d Source Code subroutine exact_burg_sin_2d ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , uy , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) L = 0.5_pfdp * ( Lx ( 1 ) + Lx ( 2 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = burg_sin_ex ( 2.0_pfdp * t , x + y , nu , L ) end do end do end subroutine exact_burg_sin_2d","tags":"","loc":"proc/exact_burg_sin_2d.html","title":"exact_burg_sin_2d – LibPFASST"},{"text":"public subroutine exact_burg_sin_2dz(t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (2) Contents Source Code exact_burg_sin_2dz Source Code subroutine exact_burg_sin_2dz ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) L = 0.5_pfdp * ( Lx ( 1 ) + Lx ( 2 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = burg_sin_ex ( 2.0_pfdp * t , x + y , nu , L ) end do end do end subroutine exact_burg_sin_2dz","tags":"","loc":"proc/exact_burg_sin_2dz.html","title":"exact_burg_sin_2dz – LibPFASST"},{"text":"public subroutine exact_burg_sin_3d(t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (3) Contents Source Code exact_burg_sin_3d Source Code subroutine exact_burg_sin_3d ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) L = ( Lx ( 1 ) + Lx ( 2 ) + Lx ( 3 )) / 3.0_pfdp do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = burg_sin_ex ( 3.0_pfdp * t , x + y + z , nu , L ) end do end do end do end subroutine exact_burg_sin_3d","tags":"","loc":"proc/exact_burg_sin_3d.html","title":"exact_burg_sin_3d – LibPFASST"},{"text":"public subroutine exact_burg_sin_3dz(t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (3) Contents Source Code exact_burg_sin_3dz Source Code subroutine exact_burg_sin_3dz ( t , uex , nu , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: nu real ( pfdp ), intent ( in ) :: Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) L = ( Lx ( 1 ) + Lx ( 2 ) + Lx ( 3 )) / 3.0_pfdp do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = burg_sin_ex ( 3.0_pfdp * t , x + y + z , nu , L ) end do end do end do end subroutine exact_burg_sin_3dz","tags":"","loc":"proc/exact_burg_sin_3dz.html","title":"exact_burg_sin_3dz – LibPFASST"},{"text":"public subroutine exact_nls_1dz(t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_nls_1dz Source Code subroutine exact_nls_1dz ( t , uex , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = nls_ex ( t , x , Lx ) end do end subroutine exact_nls_1dz","tags":"","loc":"proc/exact_nls_1dz.html","title":"exact_nls_1dz – LibPFASST"},{"text":"public subroutine exact_nls_2dz(t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: Lx (2) Contents Source Code exact_nls_2dz Source Code subroutine exact_nls_2dz ( t , uex , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:) real ( pfdp ), intent ( in ) :: Lx ( 2 ) integer :: nx , ny , i , j real ( pfdp ) :: x , y , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) L = 0.5_pfdp * ( Lx ( 1 ) + Lx ( 2 )) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j ) = nls_ex ( 2.0_pfdp * t , x + y , L ) end do end do end subroutine exact_nls_2dz","tags":"","loc":"proc/exact_nls_2dz.html","title":"exact_nls_2dz – LibPFASST"},{"text":"public subroutine exact_nls_3dz(t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: Lx (3) Contents Source Code exact_nls_3dz Source Code subroutine exact_nls_3dz ( t , uex , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:,:,:) real ( pfdp ), intent ( in ) :: Lx ( 3 ) integer :: nx , ny , nz , i , j , k real ( pfdp ) :: x , y , z , L nx = size ( uex , 1 ) ny = size ( uex , 2 ) nz = size ( uex , 3 ) L = ( Lx ( 1 ) + Lx ( 2 ) + Lx ( 3 )) / 3.0_pfdp do k = 1 , nz z = Lx ( 3 ) * real ( k - 1 , pfdp ) / real ( nz , pfdp ) do j = 1 , ny y = Lx ( 2 ) * real ( j - 1 , pfdp ) / real ( ny , pfdp ) do i = 1 , nx x = Lx ( 1 ) * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i , j , k ) = nls_ex ( 3.0_pfdp * t , x + y + z , L ) end do end do end do end subroutine exact_nls_3dz","tags":"","loc":"proc/exact_nls_3dz.html","title":"exact_nls_3dz – LibPFASST"},{"text":"public subroutine exact_kdv_1dz(t, uex, beta, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_kdv_1dz Source Code subroutine exact_kdv_1dz ( t , uex , beta , Lx ) real ( pfdp ), intent ( in ) :: t complex ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: beta real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = kdv_ex ( t , x , beta , Lx ) end do end subroutine exact_kdv_1dz","tags":"","loc":"proc/exact_kdv_1dz.html","title":"exact_kdv_1dz – LibPFASST"},{"text":"public subroutine exact_kdv_1d(t, uex, beta, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx Contents Source Code exact_kdv_1d Source Code subroutine exact_kdv_1d ( t , uex , beta , Lx ) real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( inout ) :: uex (:) real ( pfdp ), intent ( in ) :: beta real ( pfdp ), intent ( in ) :: Lx integer :: nx , i real ( pfdp ) :: x nx = size ( uex ) do i = 1 , nx x = Lx * real ( i - 1 , pfdp ) / real ( nx , pfdp ) uex ( i ) = kdv_ex ( t , x , beta , Lx ) end do end subroutine exact_kdv_1d","tags":"","loc":"proc/exact_kdv_1d.html","title":"exact_kdv_1d – LibPFASST"},{"text":"public interface exact_ad_cos Contents Module Procedures exact_ad_cos_1d exact_ad_cos_1dz exact_ad_cos_2d exact_ad_cos_2dz exact_ad_cos_3d exact_ad_cos_3dz Module Procedures public subroutine exact_ad_cos_1d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_cos_1dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_cos_2d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: kfreq (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_cos_2dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: kfreq (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_cos_3d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: kfreq (3) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_ad_cos_3dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: kfreq (3) real(kind=pfdp), intent(in) :: Lx (3)","tags":"","loc":"interface/exact_ad_cos.html","title":"exact_ad_cos – LibPFASST"},{"text":"public interface exact_ad_exp Contents Module Procedures exact_ad_exp_1d exact_ad_exp_1dz exact_ad_exp_2d exact_ad_exp_2dz exact_ad_exp_3d exact_ad_exp_3dz Module Procedures public subroutine exact_ad_exp_1d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_exp_1dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_exp_2d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_exp_2dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_exp_3d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_ad_exp_3dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: Lx (3)","tags":"","loc":"interface/exact_ad_exp.html","title":"exact_ad_exp – LibPFASST"},{"text":"public interface exact_burg_sin Contents Module Procedures exact_burg_sin_1d exact_burg_sin_1dz exact_burg_sin_2d exact_burg_sin_2dz exact_burg_sin_3d exact_burg_sin_3dz Module Procedures public subroutine exact_burg_sin_1d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx public subroutine exact_burg_sin_1dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx public subroutine exact_burg_sin_2d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_burg_sin_2dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_burg_sin_3d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_burg_sin_3dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (3)","tags":"","loc":"interface/exact_burg_sin.html","title":"exact_burg_sin – LibPFASST"},{"text":"public interface exact_nls Contents Module Procedures exact_nls_1dz exact_nls_2dz exact_nls_3dz Module Procedures public subroutine exact_nls_1dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: Lx public subroutine exact_nls_2dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_nls_3dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: Lx (3)","tags":"","loc":"interface/exact_nls.html","title":"exact_nls – LibPFASST"},{"text":"public interface exact_kdv Contents Module Procedures exact_kdv_1d exact_kdv_1dz Module Procedures public subroutine exact_kdv_1d (t, uex, beta, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx public subroutine exact_kdv_1dz (t, uex, beta, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx","tags":"","loc":"interface/exact_kdv.html","title":"exact_kdv – LibPFASST"},{"text":"public function ndsysarray_norm(this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code ndsysarray_norm Source Code function ndsysarray_norm ( this , flags ) result ( norm ) class ( ndsysarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function ndsysarray_norm","tags":"","loc":"proc/ndsysarray_norm.html","title":"ndsysarray_norm – LibPFASST"},{"text":"public function cast_as_ndsysarray(encap_polymorph) result(ndsysarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndsysarray ),\n  pointer Contents Source Code cast_as_ndsysarray Source Code function cast_as_ndsysarray ( encap_polymorph ) result ( ndsysarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndsysarray ), pointer :: ndsysarray_obj select type ( encap_polymorph ) type is ( ndsysarray ) ndsysarray_obj => encap_polymorph end select end function cast_as_ndsysarray","tags":"","loc":"proc/cast_as_ndsysarray.html","title":"cast_as_ndsysarray – LibPFASST"},{"text":"public function get_array1d(x, n, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d Source Code function get_array1d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) select type ( x ) type is ( ndsysarray ) r => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array1d","tags":"","loc":"proc/get_array1d~3.html","title":"get_array1d – LibPFASST"},{"text":"public function get_array2d(x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d Source Code function get_array2d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( ndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array2d","tags":"","loc":"proc/get_array2d~3.html","title":"get_array2d – LibPFASST"},{"text":"public function get_array3d(x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d Source Code function get_array3d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( ndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 ), 1 : x % arr_shape ( 3 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array3d","tags":"","loc":"proc/get_array3d~3.html","title":"get_array3d – LibPFASST"},{"text":"public subroutine ndsysarray_build(q, arr_shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: arr_shape (:) Contents Source Code ndsysarray_build Source Code subroutine ndsysarray_build ( q , arr_shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: arr_shape (:) select type ( q ) class is ( ndsysarray ) allocate ( q % arr_shape ( size ( arr_shape ))) q % dim = size ( arr_shape ) - 1 q % ncomp = arr_shape ( q % dim + 1 ) q % ndof = product ( arr_shape ( 1 : q % dim )) q % arr_shape = arr_shape allocate ( q % flatarray ( product ( arr_shape ))) end select end subroutine ndsysarray_build","tags":"","loc":"proc/ndsysarray_build.html","title":"ndsysarray_build – LibPFASST"},{"text":"public subroutine ndsysarray_create_single(this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndsysarray_create_single Source Code subroutine ndsysarray_create_single ( this , x , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( ndsysarray :: x ) call ndsysarray_build ( x , shape ) end subroutine ndsysarray_create_single","tags":"","loc":"proc/ndsysarray_create_single.html","title":"ndsysarray_create_single – LibPFASST"},{"text":"public subroutine ndsysarray_create_array(this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndsysarray_create_array Source Code subroutine ndsysarray_create_array ( this , x , n , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndsysarray :: x ( n )) do i = 1 , n call ndsysarray_build ( x ( i ), shape ) end do end subroutine ndsysarray_create_array","tags":"","loc":"proc/ndsysarray_create_array.html","title":"ndsysarray_create_array – LibPFASST"},{"text":"public subroutine ndsysarray_destroy(encap) Subroutine to destroy array (simple) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Contents Source Code ndsysarray_destroy Source Code subroutine ndsysarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndsysarray ), pointer :: ndsysarray_obj ndsysarray_obj => cast_as_ndsysarray ( encap ) deallocate ( ndsysarray_obj % arr_shape ) deallocate ( ndsysarray_obj % flatarray ) nullify ( ndsysarray_obj ) end subroutine ndsysarray_destroy","tags":"","loc":"proc/ndsysarray_destroy.html","title":"ndsysarray_destroy – LibPFASST"},{"text":"public subroutine ndsysarray_destroy_single(this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x Contents Source Code ndsysarray_destroy_single Source Code subroutine ndsysarray_destroy_single ( this , x ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( ndsysarray ) deallocate ( x % arr_shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine ndsysarray_destroy_single","tags":"","loc":"proc/ndsysarray_destroy_single.html","title":"ndsysarray_destroy_single – LibPFASST"},{"text":"public subroutine ndsysarray_destroy_array(this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Contents Source Code ndsysarray_destroy_array Source Code subroutine ndsysarray_destroy_array ( this , x ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( ndsysarray ) do i = 1 , size ( x ) deallocate ( x ( i )% arr_shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine ndsysarray_destroy_array","tags":"","loc":"proc/ndsysarray_destroy_array.html","title":"ndsysarray_destroy_array – LibPFASST"},{"text":"public subroutine ndsysarray_setval(this, val, flags) The following are the base subroutines that all encapsulations must provide Subroutine to set array to a scalare  value. Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code ndsysarray_setval Source Code subroutine ndsysarray_setval ( this , val , flags ) class ( ndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine ndsysarray_setval","tags":"","loc":"proc/ndsysarray_setval.html","title":"ndsysarray_setval – LibPFASST"},{"text":"public subroutine ndsysarray_copy(this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Contents Source Code ndsysarray_copy Source Code subroutine ndsysarray_copy ( this , src , flags ) class ( ndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( ndsysarray ) this % flatarray = src % flatarray class default stop \"TYPE ERROR\" end select end subroutine ndsysarray_copy","tags":"","loc":"proc/ndsysarray_copy.html","title":"ndsysarray_copy – LibPFASST"},{"text":"public subroutine ndsysarray_pack(this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndsysarray_pack Source Code subroutine ndsysarray_pack ( this , z , flags ) class ( ndsysarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags z = this % flatarray end subroutine ndsysarray_pack","tags":"","loc":"proc/ndsysarray_pack.html","title":"ndsysarray_pack – LibPFASST"},{"text":"public subroutine ndsysarray_unpack(this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndsysarray_unpack Source Code subroutine ndsysarray_unpack ( this , z , flags ) class ( ndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags this % flatarray = z end subroutine ndsysarray_unpack","tags":"","loc":"proc/ndsysarray_unpack.html","title":"ndsysarray_unpack – LibPFASST"},{"text":"public subroutine ndsysarray_axpy(this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Contents Source Code ndsysarray_axpy Source Code subroutine ndsysarray_axpy ( this , a , x , flags ) class ( ndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( ndsysarray ) this % flatarray = a * x % flatarray + this % flatarray class default stop \"TYPE ERROR\" end select end subroutine ndsysarray_axpy","tags":"","loc":"proc/ndsysarray_axpy.html","title":"ndsysarray_axpy – LibPFASST"},{"text":"public subroutine ndsysarray_eprint(this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code ndsysarray_eprint Source Code subroutine ndsysarray_eprint ( this , flags ) class ( ndsysarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % flatarray ( 1 : 10 ) !print *, this%flatarray end subroutine ndsysarray_eprint","tags":"","loc":"proc/ndsysarray_eprint.html","title":"ndsysarray_eprint – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine ndsysarray_dump_numpy(dname, fname, endian, dim, mpibuflen, arr_shape, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: arr_shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Description Subroutine to write an the array to a file","tags":"","loc":"interface/ndsysarray_dump_numpy.html","title":"ndsysarray_dump_numpy – LibPFASST"},{"text":"public subroutine imexQ_oc_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks Loop over sweeps Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level this is real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Contents Source Code imexQ_oc_sweep Source Code subroutine imexQ_oc_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: level_index !!  which level this is integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: lev !  points to current level ! indicate if sweep on both (0, default; might skip y or p if tolerance satisfied), just y (1), just p (2) integer :: k , m , n , Nnodes , which real ( pfdp ) :: t , tend logical :: sweep_y , sweep_p real ( pfdp ), allocatable :: norms_y (:) !, norms_p(Lev%nnodes-1) integer :: step lev => pf % levels ( level_index ) !  Assign level pointer step = pf % state % step + 1 !     print *, 'sweep on step', step which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SWEEPER WITHOUT FLAGS\" !     print *, \"IMEXQ_OC SWEEP\", which Nnodes = lev % nnodes tend = t0 + dt call start_timer ( pf , TLEVEL + lev % index - 1 ) if ( which . eq . 1 ) then sweep_y = . true . sweep_p = . false . else if ( which . eq . 2 ) then sweep_y = . false . sweep_p = . true . else sweep_y = . true . sweep_p = . true . allocate ( norms_y ( lev % nnodes - 1 )) do m = 1 , Nnodes - 1 norms_y ( m ) = lev % R ( m )% norm ( 1 ) end do if ( maxval ( abs ( norms_y )) < pf % abs_res_tol ) then sweep_y = . false . if ( level_index == pf % state % finest_level ) pf % state % skippedy = pf % state % skippedy + 1 end if deallocate ( norms_y ) !if ( maxval(abs(norms_p)) < pf%abs_res_tol ) sweep_p = .false. end if !     if( sweep_p .and. pf%rank == 0)  print *, \"sweep on p with which = \", which do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals from previous iteration and add fas correction !     do m = 1, Nnodes-1 !        call Lev%encap%setval(Lev%S(m), 0.0_pfdp, 1) !        call Lev%encap%setval(Lev%S(m), 0.0_pfdp, 2) if ( sweep_y ) then do m = 1 , Nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp , 1 ) !  Forward in y if ( this % explicit ) then do n = 1 , Nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 ), 1 ) !                 call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(m,n), Lev%F(n,1),1) end do end if if ( this % implicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 ), 1 ) !                 call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(m,n), Lev%F(n,2),1) end do end if if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 1 ) !              call Lev%encap%axpy(Lev%S(m), 1.0_pfdp, Lev%tauQ(m),1) end if end do end if if ( sweep_p ) then do m = Nnodes - 1 , 1 , - 1 call lev % I ( m )% setval ( 0.0_pfdp , 2 ) !  Backward in p, note S(m) goes backward now !2          do n =  1,Nnodes !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffE(m,n), Lev%F(Nnodes+1-n,1),2) !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffI(m,n), Lev%F(Nnodes+1-n,2),2) !2          end do if ( this % explicit ) then do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffE ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 1 ), 2 ) !call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(Nnodes-m,Nnodes+1-n), Lev%F(n,1),2) end do end if if ( this % implicit ) then do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 2 ), 2 ) !               call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(Nnodes-m,Nnodes+1-n), Lev%F(n,2),2) end do end if if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 2 ) end if end do end if ! Reload the newest initial values ! Recompute first function values if ( sweep_y ) then if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 , 1 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 , 1 , 1 , step ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 , 1 , 1 , step ) end if !        call Lev%encap%copy(Lev%Q(1), Lev%q0, 1) !        call imexQ_oc%f1eval(Lev%Q(1), t0, Lev%level, Lev%ctx, Lev%F(1,1), 1, 1, step) !        call imexQ_oc%f2eval(Lev%Q(1), t0, Lev%level, Lev%ctx, Lev%F(1,2), 1) end if !else !     if( sweep_p ) then !       if (k .eq. 1) then !         call lev%Q(Nnodes)%copy(lev%qend, 2) !         if (this%explicit) & !           call this%f_eval(lev%Q(Nnodes), tend, lev%index, lev%F(Nnodes,1), 1, 2, Nnodes, step) !         if (this%implicit) & !           call this%f_eval(lev%Q(Nnodes), tend, lev%index, lev%F(Nnodes,2), 2, 2, Nnodes, step) !       end if ! !        call Lev%encap%copy(Lev%Q(Nnodes), Lev%qend, 2) ! !        call imexQ_oc%f1eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,1), 2, Nnodes, step) ! !        call imexQ_oc%f2eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,2), 2) !     end if !     if (sweep_p) then !    !  Backward  sweep on p !       t = tend !       do m =  Nnodes-1,1,-1 !          t = t - dt*this%dtsdc(m) ! !          ! Do the dirk parts !          call this%rhs%setval(0.0_pfdp, 2) !          do n = Nnodes, m+1,-1 !             if (this%explicit) & !               call this%rhs%axpy(dt*this%QtilE(Nnodes-m,Nnodes-n+1), lev%F(n,1), 2) !             if (this%implicit) & !               call this%rhs%axpy(dt*this%QtilI(Nnodes-m,Nnodes-n+1), lev%F(n,2), 2) !          end do ! !          call this%rhs%axpy(1.0_pfdp, lev%I(m), 2) !          call this%rhs%axpy(1.0_pfdp, lev%Q(Nnodes), 2) ! !          !  Do implicit solve !          if (this%implicit) then !            call this%f_comp(lev%Q(m), t, dt*this%QtilI(Nnodes-m,Nnodes-m+1), this%rhs, lev%index, lev%F(m,2), 2, 2) !          else !             call lev%Q(m)%copy(this%rhs,2) !          end if !          if (this%explicit) & !            call this%f_eval(lev%Q(m), t, lev%index, lev%F(m,1), 1, 2, m, step) !       end do !       ! reset first value !       call lev%q0%copy(lev%Q(1), 2) !       call pf_residual(pf, lev, dt, 2) ! !       call pf_residual(pf, lev, dt, which) !     end if !  Make some space !     call Lev%encap%create(rhs, Lev%level, SDC_KIND_SOL_FEVAL, Lev%nvars, Lev%shape, Lev%ctx) if ( sweep_y ) then !  Forward sweep on y t = t0 do m = 1 , Nnodes - 1 t = t + dt * this % dtsdc ( m ) !  forward running time !  Form rhs with all explicit terms call this % rhs % setval ( 0.0_pfdp , 1 ) do n = 1 , m if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 ), 1 ) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 ), 1 ) end do call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 1 ) call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) ! Do implicit solve if ( this % implicit ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 ) else call lev % Q ( m + 1 )% copy ( this % rhs , 1 ) end if !  Compute explicit piece on new value if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 , 1 , m + 1 , step ) end do !  Reset last values call lev % qend % copy ( lev % Q ( Nnodes ), 1 ) !       call pf_residual(pf, lev, dt, 1) !       call pf_residual(pf, lev, dt, which) end if if ( sweep_p ) then !        do m=1, Nnodes-1 !           call lev%I(m)%setval(0.0_pfdp, 2) ! !           !  Backward in p, note S(m) goes backward now ! !2          do n =  1,Nnodes ! !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffE(m,n), Lev%F(Nnodes+1-n,1),2) ! !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffI(m,n), Lev%F(Nnodes+1-n,2),2) ! !2          end do !           if (this%explicit) then !             do n =  Nnodes,1,-1 !               call lev%I(m)%axpy(dt*this%QdiffE(Nnodes-m,Nnodes+1-n), lev%F(n,1), 2) !               !call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(Nnodes-m,Nnodes+1-n), Lev%F(n,1),2) !             end do !           end if !           if (this%implicit) then !             do n =  Nnodes,1,-1 !               call lev%I(m)%axpy(dt*this%QdiffI(Nnodes-m,Nnodes+1-n), lev%F(n,2), 2) ! !               call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(Nnodes-m,Nnodes+1-n), Lev%F(n,2),2) !             end do !           end if !           if (allocated(lev%tauQ)) then !              call lev%I(m)%axpy(1.0_pfdp, lev%tauQ(m), 2) !           end if !       end do if ( k . eq . 1 ) then call lev % Q ( Nnodes )% copy ( lev % qend , 2 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 1 ), 1 , 2 , Nnodes , step ) if ( this % implicit ) & call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 2 ), 2 , 2 , Nnodes , step ) end if !        call Lev%encap%copy(Lev%Q(Nnodes), Lev%qend, 2) !        call imexQ_oc%f1eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,1), 2, Nnodes, step) !        call imexQ_oc%f2eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,2), 2) end if if ( sweep_p ) then !  Backward  sweep on p t = tend do m = Nnodes - 1 , 1 , - 1 t = t - dt * this % dtsdc ( m ) ! Do the dirk parts call this % rhs % setval ( 0.0_pfdp , 2 ) do n = Nnodes , m + 1 , - 1 if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 1 ), 2 ) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 2 ), 2 ) end do call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) call this % rhs % axpy ( 1.0_pfdp , lev % Q ( Nnodes ), 2 ) !  Do implicit solve if ( this % implicit ) then call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 2 ), 2 , 2 ) else call lev % Q ( m )% copy ( this % rhs , 2 ) end if if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , 2 , m , step ) end do ! reset first value call lev % q0 % copy ( lev % Q ( 1 ), 2 ) !       call pf_residual(pf, lev, dt, 2) end if !     if(sweep_p) & !       call this%evaluate_all(lev, t0 + dt*lev%nodes, 2, step) !     if( sweep_p .and. sweep_y ) then !       call pf_residual(pf, lev, dt, 0) !     else if( sweep_y ) then !       call pf_residual(pf, lev, dt, 1) !     else if (sweep_p ) then !       call pf_residual(pf, lev, dt, 2) !     else !       stop \"neither sweep on p nor on y : that should not happen\" !     end if call pf_residual ( pf , lev % index , dt , which ) ! done call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !nsweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imexQ_oc_sweep","tags":"","loc":"proc/imexq_oc_sweep.html","title":"imexQ_oc_sweep – LibPFASST"},{"text":"public subroutine imexQ_oc_evaluate(this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imexQ_oc_evaluate Source Code subroutine imexQ_oc_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , intent ( in ), optional :: flags , step integer :: which , mystep type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC EVAL WITHOUT FLAGS\" mystep = 1 if ( present ( step )) then mystep = step else print * , \"step not present in evaluate\" , which stop end if !     print *, \"IMEXQ_OC EVAL \", which if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , which , m , mystep ) if ( this % implicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , which , m , mystep ) end subroutine imexQ_oc_evaluate","tags":"","loc":"proc/imexq_oc_evaluate.html","title":"imexQ_oc_evaluate – LibPFASST"},{"text":"public subroutine imexQ_oc_evaluate_all(this, pf, level_index, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imexQ_oc_evaluate_all Source Code subroutine imexQ_oc_evaluate_all ( this , pf , level_index , t , flags , step ) !! Evaluate all function values class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) integer , intent ( in ), optional :: flags , step !     call pf_generic_evaluate_all(this, lev, t, flags, step) integer :: m type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer if (. not . present ( flags )) stop \"IMEXQ_OC EVAL_ALL WITHOUT FLAGS\" if (. not . present ( step )) stop \"IMEXQ_OC EVAL_ALL WITHOUT step\" do m = 1 , lev % nnodes call this % evaluate ( pf , level_index , t ( m ), m , flags , step ) end do end subroutine imexQ_oc_evaluate_all","tags":"","loc":"proc/imexq_oc_evaluate_all.html","title":"imexQ_oc_evaluate_all – LibPFASST"},{"text":"public subroutine imexQ_oc_initialize(this, pf, level_index) Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code imexQ_oc_initialize Source Code subroutine imexQ_oc_initialize ( this , pf , level_index ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index integer :: Nnodes type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 2 Nnodes = lev % nnodes allocate ( this % QdiffE ( Nnodes - 1 , Nnodes )) !  S-FE allocate ( this % QdiffI ( Nnodes - 1 , Nnodes )) !  S-BE allocate ( this % QtilE ( Nnodes - 1 , Nnodes )) !  S-FE allocate ( this % QtilI ( Nnodes - 1 , Nnodes )) !  S-BE this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp this % dtsdc = lev % nodes ( 2 : Nnodes ) - lev % nodes ( 1 : Nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !!  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_oc_initialize","tags":"","loc":"proc/imexq_oc_initialize.html","title":"imexQ_oc_initialize – LibPFASST"},{"text":"public subroutine imexQ_oc_integrate(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code imexQ_oc_integrate Source Code subroutine imexQ_oc_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) !qSDC unused? real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , intent ( in ), optional :: flags integer :: n , m , Nnodes , which type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer Nnodes = lev % nnodes which = 0 if ( present ( flags )) then which = flags else print * , \"flags not present in integrate\" , which stop end if !     print *, \"IMEXQ_OC INTEGRATE \", which do n = 1 , Nnodes - 1 !  Forward in y if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call fintSDC ( n )% setval ( 0.0_pfdp , 1 ) do m = 1 , Nnodes !               do p = 1, npieces !                 call Lev%encap%axpy(fintSDC(n), dt*Lev%sdcmats%qmat(n,m), fSDC(m,p),1) !               end do if ( this % explicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 1 ), 1 ) if ( this % implicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 2 ), 1 ) end do end if !  Backward in p if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call fintSDC ( Nnodes - n )% setval ( 0.0_pfdp , 2 ) do m = 1 , Nnodes !               do p = 1, npieces !                 call Lev%encap%axpy(fintSDC(Nnodes-n), dt*Lev%sdcmats%qmat(n,m), fSDC(Nnodes+1-m,p),2) !               end do if ( this % explicit ) & call fintSDC ( Nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( Nnodes + 1 - m , 1 ), 2 ) if ( this % implicit ) & call fintSDC ( Nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( Nnodes + 1 - m , 2 ), 2 ) end do end if end do end subroutine imexQ_oc_integrate","tags":"","loc":"proc/imexq_oc_integrate.html","title":"imexQ_oc_integrate – LibPFASST"},{"text":"public subroutine imexQ_oc_residual(this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code imexQ_oc_residual Source Code subroutine imexQ_oc_residual ( this , pf , level_index , dt , flags ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m , which type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) which = 0 if ( present ( flags )) then which = flags else print * , \"flags not present in residual\" , which stop end if !     print *, \"IMEXQ_OC RESIDUAL \", which call this % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I , which ) ! add tau (which is 'node to node') if ( level_index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), which ) end do end if ! subtract out Q do m = 1 , pf % levels ( level_index )% nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do end subroutine imexQ_oc_residual","tags":"","loc":"proc/imexq_oc_residual.html","title":"imexQ_oc_residual – LibPFASST"},{"text":"public subroutine imexQ_oc_spreadq0(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imexQ_oc_spreadq0 Source Code subroutine imexQ_oc_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer :: m , p , which , mystep type ( pf_level_t ), pointer :: lev !  Current level lev => pf % levels ( level_index ) !  Assign level pointer which = 3 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SPREADQ0 WITHOUT FLAGS\" !     print *, \"IMEXQ_OC SPREADQ0\", which mystep = 1 if ( present ( step )) then mystep = step !needed for sequential version else print * , \"step not present in spreadq0\" , which stop end if select case ( which ) case ( 1 ) !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , 1 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , 1 , 1 , mystep ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), 1 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p ), 1 ) end do end do case ( 2 ) !  Stick terminal condition into last node slot call lev % Q ( lev % nnodes )% copy ( lev % qend , 2 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , lev % nnodes , 2 , mystep ) ! Spread F and solution to all nodes do m = lev % nnodes - 1 , 1 , - 1 call lev % Q ( m )% copy ( lev % Q ( lev % nnodes ), 2 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( lev % nnodes , p ), 2 ) end do end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine imexQ_oc_spreadq0","tags":"","loc":"proc/imexq_oc_spreadq0.html","title":"imexQ_oc_spreadq0 – LibPFASST"},{"text":"public subroutine imexQ_oc_destroy(this, pf, level_index) Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code imexQ_oc_destroy Source Code subroutine imexQ_oc_destroy ( this , pf , level_index ) !  deallocate class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev !!  Current level lev => pf % levels ( level_index ) !!  Assign level pointer deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine imexQ_oc_destroy","tags":"","loc":"proc/imexq_oc_destroy.html","title":"imexQ_oc_destroy – LibPFASST"},{"text":"interface This is the interface for the routine to compute the RHS function values public subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags integer, intent(in), optional :: idx integer, intent(in), optional :: step Description Evaluae f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~8.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface This is the interface for the routine to compute the RHS function values public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags Description Solve the equation y - dtq*f_2(y) =rhs","tags":"","loc":"interface/pf_f_comp_p~6.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine fft_setup(this, grid_shape, dim, grid_size) Allocate and initialize FFT structure Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) Contents Source Code fft_setup Source Code subroutine fft_setup ( this , grid_shape , dim , grid_size ) class ( pf_fft_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) integer :: nx , ny , nz this % dim = dim !  FFT Storage parameters nx = grid_shape ( 1 ) this % nx = nx this % lensavx = 4 * nx + 15 this % normfact = real ( nx , pfdp ) allocate ( this % workhatx ( nx )) !  complex transform allocate ( this % wsavex ( this % lensavx )) this % Lx = 1.0_pfdp if ( present ( grid_size )) this % Lx = grid_size ( 1 ) !  Initialize FFT call ZFFTI ( nx , this % wsavex ) if ( dim > 1 ) then !  FFT Storage ny = grid_shape ( 2 ) this % ny = ny this % lensavy = 4 * ny + 15 this % normfact = real ( nx * ny , pfdp ) allocate ( this % workhaty ( ny )) !  complex transform allocate ( this % wsavey ( this % lensavy )) this % Ly = 1.0_pfdp if ( present ( grid_size )) this % Ly = grid_size ( 2 ) !  Initialize FFT call ZFFTI ( ny , this % wsavey ) if ( dim > 2 ) then !  FFT Storage nz = grid_shape ( 3 ) this % nz = nz this % lensavz = 4 * nz + 15 this % normfact = real ( nx * ny * nz , pfdp ) allocate ( this % workhatz ( nz )) !  complex transform allocate ( this % wsavez ( this % lensavz )) this % Lz = 1.0_pfdp if ( present ( grid_size )) this % Lz = grid_size ( 3 ) !  Initialize FFT call ZFFTI ( nz , this % wsavez ) endif endif select case ( this % dim ) case ( 1 ) allocate ( this % wk_1d ( nx )) case ( 2 ) allocate ( this % wk_2d ( nx , ny )) case ( 3 ) allocate ( this % wk_3d ( nx , ny , nz )) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_setup","tags":"","loc":"proc/fft_setup~2.html","title":"fft_setup – LibPFASST"},{"text":"public subroutine fft_destroy(this) Deallocate and destroy fft structures Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Contents Source Code fft_destroy Source Code subroutine fft_destroy ( this ) class ( pf_fft_t ), intent ( inout ) :: this deallocate ( this % workhatx ) deallocate ( this % wsavex ) if ( this % dim > 1 ) then deallocate ( this % workhaty ) deallocate ( this % wsavey ) if ( this % dim > 2 ) then deallocate ( this % workhatz ) deallocate ( this % wsavez ) end if end if select case ( this % dim ) case ( 1 ) deallocate ( this % wk_1d ) case ( 2 ) deallocate ( this % wk_2d ) case ( 3 ) deallocate ( this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_destroy","tags":"","loc":"proc/fft_destroy~2.html","title":"fft_destroy – LibPFASST"},{"text":"public subroutine fftf(this) Forward fft call Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Contents Source Code fftf Source Code subroutine fftf ( this ) class ( pf_fft_t ), intent ( inout ) :: this integer i , j , k select case ( this % dim ) case ( 1 ) call zfftf ( this % nx , this % wk_1d , this % wsavex ) this % wk_1d = this % wk_1d / this % normfact case ( 2 ) do j = 1 , this % ny this % workhatx = this % wk_2d (:, j ) call zfftf ( this % nx , this % workhatx , this % wsavex ) this % wk_2d (:, j ) = this % workhatx end do do i = 1 , this % nx this % workhaty = this % wk_2d ( i ,:) call zfftf ( this % ny , this % workhaty , this % wsavey ) this % wk_2d ( i ,:) = this % workhaty end do this % wk_2d = this % wk_2d / this % normfact case ( 3 ) do k = 1 , this % nz do j = 1 , this % ny this % workhatx = this % wk_3d (:, j , k ) call zfftf ( this % nx , this % workhatx , this % wsavex ) this % wk_3d (:, j , k ) = this % workhatx end do end do do k = 1 , this % nz do i = 1 , this % nx this % workhaty = this % wk_3d ( i ,:, k ) call zfftf ( this % ny , this % workhaty , this % wsavey ) this % wk_3d ( i ,:, k ) = this % workhaty end do end do do j = 1 , this % ny do i = 1 , this % nx this % workhatz = this % wk_3d ( i , j ,:) call zfftf ( this % nz , this % workhatz , this % wsavez ) this % wk_3d ( i , j ,:) = this % workhatz end do end do this % wk_3d = this % wk_3d / this % normfact case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftf","tags":"","loc":"proc/fftf~2.html","title":"fftf – LibPFASST"},{"text":"public subroutine fftb(this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Contents Source Code fftb Source Code subroutine fftb ( this ) class ( pf_fft_t ), intent ( inout ) :: this integer i , j , k select case ( this % dim ) case ( 1 ) this % wk_1d = this % wk_1d call zfftb ( this % nx , this % wk_1d , this % wsavex ) case ( 2 ) this % wk_2d = this % wk_2d do j = 1 , this % ny this % workhatx = this % wk_2d (:, j ) call zfftb ( this % nx , this % workhatx , this % wsavex ) this % wk_2d (:, j ) = this % workhatx end do do i = 1 , this % nx this % workhaty = this % wk_2d ( i ,:) call zfftb ( this % ny , this % workhaty , this % wsavey ) this % wk_2d ( i ,:) = this % workhaty end do case ( 3 ) this % wk_3d = this % wk_3d do k = 1 , this % nz do j = 1 , this % ny this % workhatx = this % wk_3d (:, j , k ) call zfftb ( this % nx , this % workhatx , this % wsavex ) this % wk_3d (:, j , k ) = this % workhatx end do end do do k = 1 , this % nz do i = 1 , this % nx this % workhaty = this % wk_3d ( i ,:, k ) call zfftb ( this % ny , this % workhaty , this % wsavey ) this % wk_3d ( i ,:, k ) = this % workhaty end do end do do j = 1 , this % ny do i = 1 , this % nx this % workhatz = this % wk_3d ( i , j ,:) call zfftb ( this % nz , this % workhatz , this % wsavez ) this % wk_3d ( i , j ,:) = this % workhatz end do end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftb","tags":"","loc":"proc/fftb~2.html","title":"fftb – LibPFASST"},{"text":"public subroutine interp_1d(this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:) Contents Source Code interp_1d Source Code subroutine interp_1d ( this , yvec_c , fft_f , yvec_f ) !      use pf_mod_fftpackage, only: pf_fft_t !        class(pf_fft_abs_t), intent(inout) :: this class ( pf_fft_t ), intent ( inout ) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f integer :: nx_f , nx_c complex ( pfdp ), pointer :: wk_f (:), wk_c (:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_1d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f , pfdp ) end subroutine interp_1d","tags":"","loc":"proc/interp_1d~2.html","title":"interp_1d – LibPFASST"},{"text":"public subroutine interp_2d(this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:) Contents Source Code interp_2d Source Code subroutine interp_2d ( this , yvec_c , fft_f , yvec_f ) class ( pf_fft_t ), intent ( inout ) :: this !    class(pf_fft_abs_t), intent(inout) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:,:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:,:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f complex ( pfdp ), pointer :: wk_f (:,:), wk_c (:,:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_2d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f , pfdp ) end subroutine interp_2d","tags":"","loc":"proc/interp_2d~2.html","title":"interp_2d – LibPFASST"},{"text":"public subroutine interp_3d(this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:,:) Contents Source Code interp_3d Source Code subroutine interp_3d ( this , yvec_c , fft_f , yvec_f ) class ( pf_fft_t ), intent ( inout ) :: this !   class(pf_fft_abs_t), intent(inout) :: this real ( pfdp ), intent ( inout ), pointer :: yvec_f (:,:,:) real ( pfdp ), intent ( inout ), pointer :: yvec_c (:,:,:) type ( pf_fft_t ), pointer , intent ( in ) :: fft_f complex ( pfdp ), pointer :: wk_f (:,:,:), wk_c (:,:,:) call this % get_wk_ptr ( wk_c ) call fft_f % get_wk_ptr ( wk_f ) wk_c = yvec_c !  internal forward fft call call this % fftf () call this % zinterp_3d ( wk_c , wk_f ) wk_f = wk_f !  internal inverse fft call call fft_f % fftb () yvec_f = real ( wk_f , pfdp ) end subroutine interp_3d","tags":"","loc":"proc/interp_3d~2.html","title":"interp_3d – LibPFASST"},{"text":"public subroutine zinterp_1d(this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:) complex(kind=pfdp), pointer :: yhat_f (:) Contents Source Code zinterp_1d Source Code subroutine zinterp_1d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:), yhat_c (:) integer :: nx_f , nx_c real ( pfdp ) :: fct nx_f = size ( yhat_f ) nx_c = size ( yhat_c ) fct = real ( nx_f , pfdp ) / real ( nx_c , pfdp ) yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c / 2 ) = yhat_c ( 1 : nx_c / 2 ) yhat_f ( nx_f - nx_c / 2 + 2 : nx_f ) = yhat_c ( nx_c / 2 + 2 : nx_c ) end subroutine zinterp_1d","tags":"","loc":"proc/zinterp_1d~2.html","title":"zinterp_1d – LibPFASST"},{"text":"public subroutine zinterp_2d(this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:) complex(kind=pfdp), pointer :: yhat_f (:,:) Contents Source Code zinterp_2d Source Code subroutine zinterp_2d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:), yhat_c (:,:) integer :: nx_f ( 2 ), nx_c ( 2 ), nf1 , nf2 , nc1 , nc2 nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 )) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 )) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 )) end subroutine zinterp_2d","tags":"","loc":"proc/zinterp_2d~2.html","title":"zinterp_2d – LibPFASST"},{"text":"public subroutine zinterp_3d(this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:,:) complex(kind=pfdp), pointer :: yhat_f (:,:,:) Contents Source Code zinterp_3d Source Code subroutine zinterp_3d ( this , yhat_c , yhat_f ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: yhat_f (:,:,:), yhat_c (:,:,:) integer :: nx_f ( 3 ), nx_c ( 3 ), nf1 , nf2 , nf3 , nc1 , nc2 , nc3 nx_f = shape ( yhat_f ) nx_c = shape ( yhat_c ) nf1 = nx_f ( 1 ) - nx_c ( 1 ) / 2 + 2 nf2 = nx_f ( 2 ) - nx_c ( 2 ) / 2 + 2 nf3 = nx_f ( 3 ) - nx_c ( 3 ) / 2 + 2 nc1 = nx_c ( 1 ) / 2 + 2 nc2 = nx_c ( 2 ) / 2 + 2 nc3 = nx_c ( 3 ) / 2 + 2 yhat_f = 0.0_pfdp yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , 1 : nx_c ( 3 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), 1 : nx_c ( 3 ) / 2 ) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), 1 : nx_c ( 3 ) / 2 ) yhat_f ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) yhat_f ( nf1 : nx_f ( 1 ), 1 : nx_c ( 2 ) / 2 , nf3 : nx_f ( 3 )) = yhat_c ( nc1 : nx_c ( 1 ), 1 : nx_c ( 2 ) / 2 , nc3 : nx_c ( 3 )) yhat_f ( 1 : nx_c ( 1 ) / 2 , nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) = yhat_c ( 1 : nx_c ( 1 ) / 2 , nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) yhat_f ( nf1 : nx_f ( 1 ), nf2 : nx_f ( 2 ), nf3 : nx_f ( 3 )) = yhat_c ( nc1 : nx_c ( 1 ), nc2 : nx_c ( 2 ), nc3 : nx_c ( 3 )) end subroutine zinterp_3d","tags":"","loc":"proc/zinterp_3d~2.html","title":"zinterp_3d – LibPFASST"},{"text":"public subroutine pf_residual(pf, level_index, dt, flag) Compute full residual at each node and measure its size Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flag Contents Source Code pf_residual Source Code subroutine pf_residual ( pf , level_index , dt , flag ) type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flag real ( pfdp ) :: res_norms ( pf % levels ( level_index )% nnodes - 1 ) !!  Holds norms of residual real ( pfdp ) :: sol_norms ( pf % levels ( level_index )% nnodes ) !!  Holds norms of solution ! for adjoint: need sol at t0 as well, not only t0+dt integer :: m type ( pf_level_t ), pointer :: lev call start_timer ( pf , TRESIDUAL ) lev => pf % levels ( level_index ) call lev % ulevel % sweeper % residual ( pf , level_index , dt , flag ) ! compute max residual norm sol_norms ( 1 ) = lev % Q ( 1 )% norm ( flag ) ! for adjoint do m = 1 , lev % nnodes - 1 res_norms ( m ) = lev % R ( m )% norm ( flag ) sol_norms ( m + 1 ) = lev % Q ( m + 1 )% norm ( flag ) ! only the value at lev%nnodes is needed for forward integration, right? end do !    lev%residual = res_norms(lev%nnodes-1) m = lev % nnodes ! for usual forward integration if ( present ( flag )) then if ( flag == 2 ) m = 1 end if lev % residual = maxval ( res_norms ) if ( sol_norms ( m ) > 0.0d0 ) then lev % residual_rel = lev % residual / sol_norms ( m ) else lev % residual_rel = 0.0d0 end if call pf_set_resid ( pf , lev % index , lev % residual ) !    if (pf%save_residuals .and. pf%state%iter>0)  then !       pf%results(lev%index)%residuals(pf%state%iter, pf%state%pfblock, pf%state%sweep) = lev%residual !    end if call end_timer ( pf , TRESIDUAL ) end subroutine pf_residual","tags":"","loc":"proc/pf_residual.html","title":"pf_residual – LibPFASST"},{"text":"public subroutine pf_generic_residual(this, pf, level_index, dt, flags) Generic residual\n Each sweeper can define its own residual, or use this generic one\n This routine is in the \"Q\" form, so the residual approximates\n R(m)=y(t_n) + \\int_{t_n}&#94;t_m f(y,s) ds - y(t_m)\n  Compute the integral of F from t_n to t_m at each node add tau if it exists\n subtract out the solution value Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code pf_generic_residual Source Code subroutine pf_generic_residual ( this , pf , level_index , dt , flags ) class ( pf_sweeper_t ), intent ( in ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , intent ( in ), optional :: flags integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( lev % index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if !> subtract out the solution value if ( present ( flags )) then do m = 1 , lev % nnodes - 1 if ( ( flags . eq . 0 ) . or . ( flags . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( flags . eq . 0 ) . or . ( flags . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do else do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end if end subroutine pf_generic_residual","tags":"","loc":"proc/pf_generic_residual.html","title":"pf_generic_residual – LibPFASST"},{"text":"public subroutine pf_echo_residual(pf, level_index) Output the current residual in the solution Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index Contents Source Code pf_echo_residual Source Code subroutine pf_echo_residual ( pf , level_index ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index print '(\"resid: time: \", f8.4,\" step: \",i3.3,\" rank: \",i3.3,\" iter: \",i4.3,\" level: \",i2.2,\" resid: \",es14.7)' , & pf % state % t0 + pf % state % dt , pf % state % step + 1 , pf % rank , pf % state % iter , level_index , pf % levels ( level_index )% residual call flush ( 6 ) end subroutine pf_echo_residual","tags":"","loc":"proc/pf_echo_residual.html","title":"pf_echo_residual – LibPFASST"},{"text":"public subroutine pf_set_resid(pf, level_index, resid) Subroutine to store a residual value Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: resid Contents Source Code pf_set_resid Source Code subroutine pf_set_resid ( pf , level_index , resid ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: resid if ( pf % save_residuals . and . pf % state % iter > 0 ) then pf % results ( level_index )% residuals ( pf % state % iter , pf % state % pfblock , pf % state % sweep ) = resid end if end subroutine pf_set_resid","tags":"","loc":"proc/pf_set_resid.html","title":"pf_set_resid – LibPFASST"},{"text":"public subroutine pf_set_error(pf, level_index, error) Subroutine to store a residual value Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: error Contents Source Code pf_set_error Source Code subroutine pf_set_error ( pf , level_index , error ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: error if ( pf % save_residuals . and . pf % state % iter > 0 ) then pf % results ( level_index )% errors ( pf % state % iter , pf % state % pfblock , pf % state % sweep ) = error end if end subroutine pf_set_error","tags":"","loc":"proc/pf_set_error.html","title":"pf_set_error – LibPFASST"},{"text":"public subroutine pf_generic_evaluate_all(this, pf, level_index, t, flags, step) Generic evaluate all\n Each sweeper can define its own evaluate_all or use this generic one\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code pf_generic_evaluate_all Source Code subroutine pf_generic_evaluate_all ( this , pf , level_index , t , flags , step ) class ( pf_sweeper_t ), intent ( in ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step integer :: m class ( pf_level_t ), pointer :: lev !!  points to current level lev => pf % levels ( level_index ) !!  Assign level pointer !     which = 1 !     if(present(flags)) which = flags !     mystep = 1 !     if(present(step)) mystep = step do m = 1 , lev % nnodes call lev % ulevel % sweeper % evaluate ( pf , level_index , t ( m ), m , flags = flags , step = step ) end do end subroutine pf_generic_evaluate_all","tags":"","loc":"proc/pf_generic_evaluate_all.html","title":"pf_generic_evaluate_all – LibPFASST"},{"text":"public subroutine pf_generic_spreadq0(this, pf, level_index, t0) Generic routine to spread initial conditions\n Each sweeper can define its own spreadq0 or use this generic one\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to sweep real(kind=pfdp), intent(in) :: t0 time at beginning of interval Contents Source Code pf_generic_spreadq0 Source Code subroutine pf_generic_spreadq0 ( this , pf , level_index , t0 ) class ( pf_sweeper_t ), intent ( in ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  level on which to sweep real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of interval integer :: m , p class ( pf_level_t ), pointer :: lev !!  Level on which to spread lev => pf % levels ( level_index ) !!  Assign level pointer !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , 1 ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 )) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p )) end do end do end subroutine pf_generic_spreadq0","tags":"","loc":"proc/pf_generic_spreadq0.html","title":"pf_generic_spreadq0 – LibPFASST"},{"text":"public subroutine pf_stop(pf_file, Nline, msg, N) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: pf_file integer, intent(in) :: Nline character(len=*), intent(in) :: msg integer, intent(in), optional :: N Contents Source Code pf_stop Source Code subroutine pf_stop ( pf_file , Nline , msg , N ) character ( len =* ), intent ( in ) :: pf_file integer , intent ( in ) :: Nline character ( len =* ), intent ( in ) :: msg integer , intent ( in ), optional :: N print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * , 'Stopping in File: ' , pf_file print * , 'Line number: ' , Nline print * , msg if ( present ( N )) print * , 'value=' , N print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' stop end subroutine pf_stop","tags":"","loc":"proc/pf_stop.html","title":"pf_stop – LibPFASST"},{"text":"public subroutine pf_apply_mat(dst, a, mat, src, zero_first, flags) Apply a matrix (tmat or rmat) to src and add to dst.\n Mathematically this is \n     dst= dst + a mat src\n  Where dst and src are vectors, mat is a matrix, and a is a scalar\n  If the optional variable \"zero\" is provided and is true, then we compute\n     dst=  a mat src Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: dst (:) destination vector real(kind=pfdp), intent(in) :: a scalar real(kind=pfdp), intent(in) :: mat (:,:) matrix class( pf_encap_t ), intent(in) :: src (:) src vector logical, intent(in), optional :: zero_first If true, zero out the the dst variable before computing integer, intent(in), optional :: flags Used for choosing which variable to operate on Local variables Contents Source Code pf_apply_mat Source Code subroutine pf_apply_mat ( dst , a , mat , src , zero_first , flags ) !! Apply a matrix (tmat or rmat) to src and add to dst. !! Mathematically this is !!     dst= dst + a*mat*src !!  Where dst and src are vectors, mat is a matrix, and a is a scalar !!  If the optional variable \"zero\" is provided and is true, then we compute !!     dst=  a*mat*src class ( pf_encap_t ), intent ( inout ) :: dst (:) !!  destination vector real ( pfdp ), intent ( in ) :: a !!  scalar real ( pfdp ), intent ( in ) :: mat (:, :) !!  matrix class ( pf_encap_t ), intent ( in ) :: src (:) !!  src vector logical , intent ( in ), optional :: zero_first !! If true, zero out the the dst variable before computing integer , intent ( in ), optional :: flags !! Used for choosing which variable to operate on !!  Local variables logical :: lzero !!  local version of input parameter zero integer :: which !!  local version of flags integer :: n , m !!  size of mat integer :: i , j !!  loop variables lzero = . true .; if ( present ( zero_first )) lzero = zero_first which = 1 ; if ( present ( flags )) which = flags n = size ( mat , dim = 1 ) m = size ( mat , dim = 2 ) do i = 1 , n if ( lzero ) call dst ( i )% setval ( 0.0_pfdp , flags ) do j = 1 , m if ( abs ( a * mat ( i , j )) /= 0.0_pfdp ) call dst ( i )% axpy ( a * mat ( i , j ), src ( j ), flags ) end do end do end subroutine pf_apply_mat","tags":"","loc":"proc/pf_apply_mat.html","title":"pf_apply_mat – LibPFASST"},{"text":"public subroutine pf_apply_mat_backward(dst, a, mat, src, zero_first, flags) Apply a matrix (tmat or rmat) to src and add to dst. Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: dst (:) destination vector real(kind=pfdp), intent(in) :: a scalar real(kind=pfdp), intent(in) :: mat (:,:) matrix class( pf_encap_t ), intent(in) :: src (:) src vector logical, intent(in), optional :: zero_first If true, zero out the the dst variable before computing integer, intent(in), optional :: flags Used for choosing which variable to operate on Local variables Contents Source Code pf_apply_mat_backward Source Code subroutine pf_apply_mat_backward ( dst , a , mat , src , zero_first , flags ) !! Apply a matrix (tmat or rmat) to src and add to dst. class ( pf_encap_t ), intent ( inout ) :: dst (:) !!  destination vector real ( pfdp ), intent ( in ) :: a !!  scalar real ( pfdp ), intent ( in ) :: mat (:, :) !!  matrix class ( pf_encap_t ), intent ( in ) :: src (:) !!  src vector logical , intent ( in ), optional :: zero_first !! If true, zero out the the dst variable before computing integer , intent ( in ), optional :: flags !! Used for choosing which variable to operate on !!  Local variables logical :: lzero !!  local version of input parameter zero integer :: which !!  local version of flags integer :: n , m !!  size of mat integer :: i , j !!  loop variables lzero = . true .; if ( present ( zero_first )) lzero = zero_first which = 2 ; if ( present ( flags )) which = flags if ( which /= 2 ) & stop \"pf_apply_mat_backward can only be used for restricting the backward integrals with which==2\" n = size ( mat , dim = 1 ) m = size ( mat , dim = 2 ) do i = 1 , n if ( lzero ) call dst ( n + 1 - i )% setval ( 0.0_pfdp , 2 ) do j = 1 , m if ( abs ( a * mat ( i , j )) /= 0.0_pfdp ) call dst ( n + 1 - i )% axpy ( a * mat ( i , j ), src ( m + 1 - j ), 2 ) end do end do end subroutine pf_apply_mat_backward","tags":"","loc":"proc/pf_apply_mat_backward.html","title":"pf_apply_mat_backward – LibPFASST"},{"text":"public subroutine restrict_time_space_fas(pf, t0, dt, level_index, flags, mystep) Restrict (in time and space) fine level to coarse and set coarse level FAS correction. The coarse function values are re-evaluated after restriction.\n Note that even if the number of variables and nodes is the same,\n we should still compute the FAS correction since the function\n evaluations may be different.\n restrict q's and recompute f's\n  Recompute the functions Compute  FAS correction\n$       if (pf%use_Sform) then\n$          do m = c_lev_p%nnodes-1,2,-1\n$!             call c_lev_p%tauQ(m)%axpy(-1.0_pfdp, c_lev_p%tauQ(m-1), flags)\n$          end do\n$       end if Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf real(kind=pfdp), intent(in) :: t0 time at beginning of step real(kind=pfdp), intent(in) :: dt time step integer, intent(in) :: level_index defines which level to restrict integer, intent(in), optional :: flags integer, intent(in), optional :: mystep Contents Source Code restrict_time_space_fas Source Code subroutine restrict_time_space_fas ( pf , t0 , dt , level_index , flags , mystep ) !! Restrict (in time and space) fine level to coarse and set coarse level FAS correction. !! !! The coarse function values are re-evaluated after restriction. !! Note that even if the number of variables and nodes is the same, !! we should still compute the FAS correction since the function !! evaluations may be different. type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of step real ( pfdp ), intent ( in ) :: dt !!  time step integer , intent ( in ) :: level_index !! defines which level to restrict integer , optional , intent ( in ) :: flags , mystep !>  Local variables class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p integer :: m , step real ( pfdp ), allocatable :: c_times (:) !!  Simulation time at coarse nodes real ( pfdp ), allocatable :: f_times (:) !!  Simulation time at fine nodes f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) step = pf % state % step + 1 if ( present ( mystep )) step = mystep call call_hooks ( pf , level_index , PF_PRE_RESTRICT_ALL ) call start_timer ( pf , TRESTRICT + level_index - 1 ) allocate ( c_times ( c_lev_p % nnodes )) allocate ( f_times ( f_lev_p % nnodes )) !> restrict q's and recompute f's c_times = t0 + dt * c_lev_p % nodes f_times = t0 + dt * f_lev_p % nodes call restrict_ts ( f_lev_p , c_lev_p , f_lev_p % Q , c_lev_p % Q , f_times , flags ) !>  Recompute the functions call c_lev_p % ulevel % sweeper % evaluate_all ( pf , level_index - 1 , c_times , flags = flags , step = step ) !>  Compute  FAS correction do m = 1 , c_lev_p % nnodes - 1 call c_lev_p % tauQ ( m )% setval ( 0.0_pfdp , flags ) end do if ( pf % state % iter >= pf % taui0 ) then ! compute '0 to node' integral on the coarse level call c_lev_p % ulevel % sweeper % integrate ( pf , level_index - 1 , c_lev_p % Q , & c_lev_p % F , dt , c_lev_p % I , flags ) ! compute '0 to node' integral on the fine level call f_lev_p % ulevel % sweeper % integrate ( pf , level_index , f_lev_p % Q , & f_lev_p % F , dt , f_lev_p % I , flags ) !  put tau in on fine level if ( level_index < pf % state % finest_level ) then do m = 1 , f_lev_p % nnodes - 1 call f_lev_p % I ( m )% axpy ( 1.0_pfdp , f_lev_p % tauQ ( m ), flags ) end do end if !  Subtract coarse integral do m = 1 , c_lev_p % nnodes - 1 call c_lev_p % tauQ ( m )% axpy ( - 1.0_pfdp , c_lev_p % I ( m ), flags ) end do ! restrict '0 to node' integral on the fine level  in time and space call restrict_ts_integral ( f_lev_p , c_lev_p , f_lev_p % I , c_lev_p % I , f_times , flags ) ! Add fine restriction of fine integral (stored on coarse) do m = 1 , c_lev_p % nnodes - 1 call c_lev_p % tauQ ( m )% axpy ( 1.0_pfdp , c_lev_p % I ( m ), flags ) end do !!$       if (pf%use_Sform) then !!$          do m = c_lev_p%nnodes-1,2,-1 !!$!             call c_lev_p%tauQ(m)%axpy(-1.0_pfdp, c_lev_p%tauQ(m-1), flags) !!$          end do !!$       end if end if call end_timer ( pf , TRESTRICT + level_index - 1 ) call call_hooks ( pf , level_index , PF_POST_RESTRICT_ALL ) deallocate ( c_times ) deallocate ( f_times ) end subroutine restrict_time_space_fas","tags":"","loc":"proc/restrict_time_space_fas.html","title":"restrict_time_space_fas – LibPFASST"},{"text":"public subroutine restrict_ts(f_lev_p, c_lev_p, f_encap_array, c_encap_array, f_time, flags) Restrict (in time and space) f_sol_array  to c_sol_array\n This version is for point values (either functions or solutions) Create a temp array for the spatial restriction Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: f_lev_p pointer to fine level class( pf_level_t ), intent(inout) :: c_lev_p pointer to coarse level class( pf_encap_t ), intent(inout) :: f_encap_array (:) array of fine level data to be restricted class( pf_encap_t ), intent(inout) :: c_encap_array (:) array of coarse level data to be computed real(kind=pfdp), intent(in) :: f_time (:) time at the fine nodes integer, intent(in), optional :: flags Contents Source Code restrict_ts Source Code subroutine restrict_ts ( f_lev_p , c_lev_p , f_encap_array , c_encap_array , f_time , flags ) !! Restrict (in time and space) f_sol_array  to c_sol_array !! This version is for point values (either functions or solutions) class ( pf_level_t ), intent ( inout ) :: f_lev_p !!   pointer to fine level class ( pf_level_t ), intent ( inout ) :: c_lev_p !!   pointer to coarse level class ( pf_encap_t ), intent ( inout ) :: f_encap_array (:) !! array of fine level data to be restricted class ( pf_encap_t ), intent ( inout ) :: c_encap_array (:) !! array of coarse level data to be computed real ( pfdp ), intent ( in ) :: f_time (:) !! time at the fine nodes integer , optional , intent ( in ) :: flags class ( pf_encap_t ), allocatable :: f_encap_array_c (:) !!  fine solution restricted in space only integer :: m , j integer :: f_nnodes , c_nnodes f_nnodes = f_lev_p % nnodes c_nnodes = c_lev_p % nnodes !!  Create a temp array for the spatial restriction call c_lev_p % ulevel % factory % create_array ( f_encap_array_c , f_nnodes , c_lev_p % index , c_lev_p % shape ) !  spatial restriction do m = 1 , f_nnodes call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_encap_array ( m ), f_encap_array_c ( m ), f_time ( m ), flags ) end do ! temporal restriction if ( present ( flags )) then if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) & call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_p % rmat , f_encap_array_c , . true ., flags ) if (( flags . eq . 0 ) . or . ( flags . eq . 2 )) & call pf_apply_mat_backward ( c_encap_array , 1.0_pfdp , f_lev_p % rmat , f_encap_array_c , . true ., flags = 2 ) else call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_p % rmat , f_encap_array_c , . true .) end if call c_lev_p % ulevel % factory % destroy_array ( f_encap_array_c ) end subroutine restrict_ts","tags":"","loc":"proc/restrict_ts.html","title":"restrict_ts – LibPFASST"},{"text":"public subroutine restrict_ts_integral(f_lev_p, c_lev_p, f_encap_array, c_encap_array, f_time, flags) Restrict (in time and space) f_sol_array  to c_sol_array\n This version is for integrals Create a temp array for the spatial restriction Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: f_lev_p pointer to fine level class( pf_level_t ), intent(inout) :: c_lev_p pointer to coarse level class( pf_encap_t ), intent(inout) :: f_encap_array (:) array of fine level data to be restricted class( pf_encap_t ), intent(inout) :: c_encap_array (:) array of coarse level data to be computed real(kind=pfdp), intent(in) :: f_time (:) time at the fine nodes integer, intent(in), optional :: flags Contents Source Code restrict_ts_integral Source Code subroutine restrict_ts_integral ( f_lev_p , c_lev_p , f_encap_array , c_encap_array , f_time , flags ) !! Restrict (in time and space) f_sol_array  to c_sol_array !! This version is for integrals class ( pf_level_t ), intent ( inout ) :: f_lev_p !!   pointer to fine level class ( pf_level_t ), intent ( inout ) :: c_lev_p !!   pointer to coarse level class ( pf_encap_t ), intent ( inout ) :: f_encap_array (:) !! array of fine level data to be restricted class ( pf_encap_t ), intent ( inout ) :: c_encap_array (:) !! array of coarse level data to be computed real ( pfdp ), intent ( in ) :: f_time (:) !! time at the fine nodes integer , optional , intent ( in ) :: flags class ( pf_encap_t ), allocatable :: f_encap_array_c (:) !!  fine solution restricted in space only integer :: m , j integer :: f_nnodes , c_nnodes f_nnodes = f_lev_p % nnodes c_nnodes = c_lev_p % nnodes !!  Create a temp array for the spatial restriction call c_lev_p % ulevel % factory % create_array ( f_encap_array_c , f_nnodes - 1 , c_lev_p % index , c_lev_p % shape ) !  spatial restriction do m = 1 , f_nnodes - 1 call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_encap_array ( m ), f_encap_array_c ( m ), f_time ( m ), flags ) end do ! temporal restriction ! when restricting '0 to node' integral terms, skip the first entry since it is zero if ( present ( flags )) then if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) & call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_p % rmat ( 2 :, 2 :), f_encap_array_c , . true ., flags = 1 ) if (( flags . eq . 0 ) . or . ( flags . eq . 2 )) & call pf_apply_mat_backward ( c_encap_array , 1.0_pfdp , f_lev_p % rmat ( 2 :, 2 :), f_encap_array_c , . true ., flags = 2 ) else call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_p % rmat ( 2 :, 2 :), f_encap_array_c , . true .) end if call c_lev_p % ulevel % factory % destroy_array ( f_encap_array_c ) end subroutine restrict_ts_integral","tags":"","loc":"proc/restrict_ts_integral.html","title":"restrict_ts_integral – LibPFASST"},{"text":"public subroutine pf_predictor_oc(pf, t0, dt, flags) Step 1. Getting the  initial condition on the finest level at each processor\n         If we are doing multiple levels, then we need to coarsen to fine level\n  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction\n If RK_pred is true, just do some RK_steps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags Contents Source Code pf_predictor_oc Source Code subroutine pf_predictor_oc ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p integer :: k !!  Loop indices integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k integer :: which , dir , send_tag , burnin_sweeps , my_coarse_sweeps which = 1 ! standard: predict and sweep forward-in-time dir = 1 ! for MPI communication, standard is forward-in-time if ( present ( flags )) then if ( flags ( 1 ) == 2 ) then which = 2 ! if we are computing an adjoint, predict and sweep backward-in-time dir = 2 ! communication has to be backwards as well end if if ( flags ( 1 ) == 0 ) which = 0 ! sweep forward and backward simultaneously on two components, communication only forwards end if call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning predictor' !! Step 1. Getting the  initial condition on the finest level at each processor !!         If we are doing multiple levels, then we need to coarsen to fine level f_lev_p => pf % levels ( pf % state % finest_level ) if ( pf % q0_style < 2 ) then !  Spread q0 to all the nodes if ( ( which == 0 ) . or . ( which == 1 )) call f_lev_p % ulevel % sweeper % spreadq0 ( pf , pf % state % finest_level , t0 , 1 , pf % state % step + 1 ) if ( ( which == 0 ) . or . ( which == 2 )) call f_lev_p % ulevel % sweeper % spreadq0 ( pf , pf % state % finest_level , t0 + dt , 2 , pf % state % step + 1 ) endif !!  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do coarsen  in predictor' if ( pf % state % finest_level > 1 ) then do level_index = pf % state % finest_level , 2 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call pf_residual ( pf , f_lev_p % index , dt , which ) if ( ( which == 0 ) . or . ( which == 1 )) & call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0 , t0 , flags = 1 ) if ( ( which == 0 ) . or . ( which == 2 )) & call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % qend , c_lev_p % qend , t0 + dt , flags = 2 ) call restrict_time_space_fas ( pf , t0 , dt , level_index , flags = which ) !  Restrict call save ( pf , c_lev_p , which ) end do !  level_index = pf%state%finest_level, 2, -1 end if level_index = 1 c_lev_p => pf % levels ( 1 ) if ( pf % q0_style < 3 ) then ! Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !         (this is skipped if the fine initial conditions are already consistent) ! The first processor does nothing, the second does one set of sweeps, the 2nd two, etc ! Hence, this is skipped completely if nprocs=1 if ( pf % q0_style . eq . 0 ) then !  The coarse level needs burn in if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do burnin in pred' , ' RK_pred' , pf % RK_pred , ' PFASST_pred' , pf % PFASST_pred !! If RK_pred is true, just do some RK_steps if ( pf % RK_pred . or . which == 2 ) then !  Use Runge-Kutta to get the coarse initial data !  Get new initial conditions call pf_recv ( pf , c_lev_p , 100000 + pf % rank , . true ., dir ) !  Do a RK_step call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 , which ) !  Send forward/backward if ( dir == 1 ) send_tag = 100000 + pf % rank + 1 if ( dir == 2 ) send_tag = 100000 + pf % rank - 1 call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) else !  Normal PFASST burn in burnin_sweeps = pf % rank + 1 if ( which == 2 ) then if ( pf % rank == 0 ) & print * , 'WARNING --- normal PFASST burn in is not suitable for adjoint as rhs cannot be evaluated for [t0k, t0k+dt]' burnin_sweeps = pf % comm % nproc - pf % rank end if if ( pf % debug ) print * , 'DEBUG ---' , pf % rank , 'which = ' , which , 'burnin_sweeps = ' , burnin_sweeps do k = 1 , burnin_sweeps !pf%rank + 1 pf % state % iter = - k t0k = t0 - ( pf % rank ) * dt + ( k - 1 ) * dt ! Remember t0=pf%rank*dt is the beginning of this time slice so t0-(pf%rank)*dt is 0 ! and we iterate up to the correct time step. ! for optimal control problem t, t0k has no influence on f_eval, so there this does something else if ( which == 2 ) t0k = t0 + ( burnin_sweeps - 1 ) * dt - ( k - 1 ) * dt if ( pf % debug ) print * , 'DEBUG ----' , pf % rank , 't0k = ' , t0k ! Get new initial value (skip on first iteration) if ( k > 1 ) then if (( which == 0 ) . or . ( which == 1 )) call c_lev_p % q0 % copy ( c_lev_p % qend , 1 ) !                 if ((which == 0) .or. (which == 2)) call c_lev_p%qend%copy(c_lev_p%q0, 2) ! for which==0, we solve with zero terminal conditions, ! but q0,2 is not zero (source term due to state sweeps) if ( which == 2 ) call c_lev_p % qend % copy ( c_lev_p % q0 , 2 ) ! If we are doing PFASST_pred, we use the old values at nodes, otherwise spread q0 if (. not . pf % PFASST_pred ) then if ( ( which == 0 ) . or . ( which == 1 )) call c_lev_p % ulevel % sweeper % spreadq0 ( pf , level_index , t0k , 1 , pf % state % step + 1 ) !                    if( (which == 0) .or. (which == 2)) call c_lev_p%ulevel%sweeper%spreadq0(pf,level_index, t0k+dt, 2, pf%state%step+1) if ( which == 2 ) call c_lev_p % ulevel % sweeper % spreadq0 ( pf , level_index , t0k + dt , 2 , pf % state % step + 1 ) end if end if !  Do some sweeps if ( which == 0 . or . which == 1 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn , 1 ) ! was: 1 not which if ( which == 2 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn , 2 ) end do endif !  RK_pred end if ! (q0_style .eq. 0) if ( pf % q0_style > 0 ) then my_coarse_sweeps = pf % rank + 1 ! for warm start do pipelining if ( which == 2 ) my_coarse_sweeps = pf % comm % nproc - pf % rank else my_coarse_sweeps = c_lev_p % nsweeps_pred end if ! Step 4: Now we have everyone burned in, so do some coarse sweeps ! Modification: each processor does sweeps according to its rank if ( pf % state % finest_level > 1 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do sweeps  in predictor' , ' Pipeline_pred' , pf % Pipeline_pred level_index = 1 c_lev_p => pf % levels ( level_index ) if ( pf % Pipeline_pred ) then do k = 1 , my_coarse_sweeps !c_lev_p%nsweeps_pred pf % state % iter =- ( pf % rank + 1 ) - k !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + k , . true ., dir ) !  Do a sweep call c_lev_p % ulevel % sweeper % sweep ( pf , c_lev_p % index , t0 , dt , 1 , which ) !  Send forward/backward if ( dir == 1 ) send_tag = c_lev_p % index * 1110000 + pf % rank + 1 + k if ( dir == 2 ) send_tag = c_lev_p % index * 1110000 + pf % rank - 1 + k call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) end do ! k = 1, c_lev_p%nsweeps_pred-1 else !  Don't pipeline !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 100000 + pf % rank , . true ., dir ) !  Do sweeps !         if(which == 0 .or. which == 1) call c_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, c_lev_p%nsweeps_pred, 1) !1 ! why only state? if ( which == 0 . or . which == 1 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , my_coarse_sweeps , which ) !1 ! why only state? !         if(which == 2)                 call c_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, c_lev_p%nsweeps_pred, 2) !which if ( which == 2 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , my_coarse_sweeps , 2 ) !which !  Send forward/backward if ( dir == 1 ) send_tag = c_lev_p % index * 100000 + pf % rank + 1 if ( dir == 2 ) send_tag = c_lev_p % index * 100000 + pf % rank - 1 call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) endif ! (Pipeline_pred .eq. .true) then end if ! pf%state%finest_level > 1 !  Step 5:  Return to fine level sweeping on any level in between coarsest and finest if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'returning to fine level in predictor' do level_index = 2 , pf % state % finest_level !  Will do nothing with one level f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp , flags = which ) if (( which == 0 ) . or . ( which == 1 )) then call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 1 ) if ( pf % rank /= 0 ) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 1 ) end if if ( which == 2 ) then ! for which==0, qend never changes, so don't need to interpolate call f_lev_p % q0 % copy ( f_lev_p % Q ( 1 ), flags = 2 ) if ( pf % rank /= pf % comm % nproc - 1 ) call interpolate_qend ( pf , f_lev_p , c_lev_p ) end if !  Do sweeps on level unless we are at the finest level if ( level_index < pf % state % finest_level ) then if (( which == 0 ) . or . ( which == 1 )) & call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred , which ) !which was 1 if ( which == 2 ) & call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred , 2 ) end if end do end if call end_timer ( pf , TPREDICTOR ) call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' end subroutine pf_predictor_oc","tags":"","loc":"proc/pf_predictor_oc.html","title":"pf_predictor_oc – LibPFASST"},{"text":"public subroutine pf_check_residual_oc(pf, level_index, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index logical, intent(out) :: residual_converged Return true if residual is below tolerances Contents Source Code pf_check_residual_oc Source Code subroutine pf_check_residual_oc ( pf , level_index , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if relative tolerance is met if ( pf % levels ( level_index )% residual_rel < pf % rel_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , ' residual relative tol met' , pf % levels ( level_index )% residual_rel residual_converged = . true . end if ! Check to see if relative tolerance is met if ( pf % levels ( level_index )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( level_index )% residual residual_converged = . true . end if end subroutine pf_check_residual_oc","tags":"","loc":"proc/pf_check_residual_oc.html","title":"pf_check_residual_oc – LibPFASST"},{"text":"public subroutine pf_check_convergence_oc(pf, level_index, send_tag, flags) Test residuals to determine if the current processor has converged,\n adapted to optimal control. Can probably be removed, when pf_pfasst_block_oc\n is changed to use pf_check_convergence of pf_check_convergence_old. Note that if the previous processor hasn't converged yet\n (pstatus), the current processor hasn't converged yet either,\n regardless of the residual. Check to see if tolerances are met Until I hear the previous processor is done, recieve it's status Check to see if I am converged\n Assign status and send it forward Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index integer, intent(in) :: send_tag integer, intent(in), optional :: flags Contents Source Code pf_check_convergence_oc Source Code subroutine pf_check_convergence_oc ( pf , level_index , send_tag , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index integer , intent ( in ) :: send_tag !     real(pfdp),        intent(inout) :: residual !     integer,           intent(in)    :: k !     logical,           intent(out)   :: converged   !!  True if this processor is done integer , optional , intent ( in ) :: flags !     real(pfdp)     :: residual1 integer :: dir , which logical :: residual_converged , converged converged = . false . ! shortcut for fixed block mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if ! in first sweep: always continue if ( pf % state % iter == 1 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual_oc ( pf , level_index , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag , dir ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 . and . dir == 1 ) then converged = . true . elseif ( pf % rank == pf % comm % nproc - 1 . and . dir == 2 ) then converged = . true . else !  I am not the first/last processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag , dir ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag , dir ) end if call call_hooks ( pf , 1 , PF_POST_CONVERGENCE ) end subroutine pf_check_convergence_oc","tags":"","loc":"proc/pf_check_convergence_oc.html","title":"pf_check_convergence_oc – LibPFASST"},{"text":"public subroutine pf_pfasst_block_oc(pf, dt, nsteps, predict, flags, step) Routine to do the pfasst iterations for optimal control problems on one block of processors until completion.\n  Each processor will do either a fixed number of iterations, or iterate until a tolerance is met\n  On calling, it is assumed that the levels are already loaded with the initial guesses Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps logical, intent(in) :: predict integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code pf_pfasst_block_oc Source Code subroutine pf_pfasst_block_oc ( pf , dt , nsteps , predict , flags , step ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps logical , intent ( in ) :: predict integer , optional , intent ( in ) :: flags !0 (default): sweep on y and p, 1: just y, 2: just p integer , optional , intent ( in ) :: step ! not yet clear how to handle send and receive for forward and backward combined type ( pf_level_t ), pointer :: fine_lev_p , coarse_lev_p integer :: k , j , l , which , pred_flags ( 1 ), dir , ierror !dir to choose forward or backward send real ( pfdp ) :: residual logical :: converged , qbroadcast logical :: did_post_step_hook call start_timer ( pf , TTOTAL ) which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 pred_flags ( 1 ) = which if ( present ( step ) ) then pf % state % step = step else pf % state % step = pf % rank end if !     print *, pf%state%step pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % t0 = pf % state % step * dt pf % state % iter = - 1 !     pf%state%itcnt   = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % nsteps = nsteps !     pf%state%component = which residual = - 1 did_post_step_hook = . false . !       if (pf%state%status == PF_STATUS_PREDICTOR) then !         !print *, 'pf%state%status == PF_STATUS_PREDICTOR', pf%state%t0, dt, which if ( predict ) then !print *, 'calling predictor' call pf_predictor_oc ( pf , pf % state % t0 , dt , pred_flags ) end if !       end if call call_hooks ( pf , - 1 , PF_POST_ITERATION ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING k = pf % state % pfblock ! !pf%state%pfblock = k ! has to be set in pf_optimization_flex to current step ! this is relevant for save_residuals do j = 1 , pf % niters call start_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle !       call pf_v_cycle(pf, k, pf%state%t0, dt, 1 ,pf%nlevels) call pf_v_cycle_oc ( pf , j , pf % state % t0 , dt , 1 , pf % state % finest_level , which ) !  Check for convergence call pf_check_convergence_oc ( pf , pf % state % finest_level , send_tag = 1111 * k + j , flags = dir ) call call_hooks ( pf , - 1 , PF_POST_ITERATION ) call end_timer ( pf , TITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) exit end do !  Loop over the iteration in this block call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) pf % state % itcnt = pf % state % itcnt + pf % state % iter call call_hooks ( pf , - 1 , PF_POST_STEP ) !    call pf_dump_results(pf) call end_timer ( pf , TTOTAL ) end subroutine pf_pfasst_block_oc","tags":"","loc":"proc/pf_pfasst_block_oc.html","title":"pf_pfasst_block_oc – LibPFASST"},{"text":"public subroutine pf_v_cycle_oc(pf, iteration, t0, dt, level_index_c, level_index_f, flags) Post the nonblocking receives on the all the levels that will be recieving later\n    (for single level this will be skipped)\n move from fine to coarse doing sweeps\n Do the coarsest level\n Now move coarse to fine interpolating and sweeping Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags Contents Source Code pf_v_cycle_oc Source Code subroutine pf_v_cycle_oc ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) ! Execute a V-cycle between levels nfine and ncoarse type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j , which , dir which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 ! !>  Post the nonblocking receives on the all the levels that will be recieving later !>    (for single level this will be skipped) do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ) call pf_post ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , dir ) end do !> move from fine to coarse doing sweeps do level_index = level_index_f , level_index_c + 1 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) call restrict_time_space_fas ( pf , t0 , dt , level_index , flags = which ) call save ( pf , c_lev_p , which ) end do !> Do the coarsest level level_index = level_index_c f_lev_p => pf % levels ( level_index ) if ( pf % pipeline_pred ) then do j = 1 , f_lev_p % nsweeps call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . true ., dir ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 , which ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . false ., dir ) end do else call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . true ., dir ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . false ., dir ) endif !> Now move coarse to fine interpolating and sweeping do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp , flags = which ) if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 1 ) if ( flags . eq . 2 ) call f_lev_p % q0 % copy ( f_lev_p % Q ( 1 ), flags = 2 ) call pf_recv ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) if ( pf % rank /= 0 ) then ! interpolate increment to q0 -- the fine initial condition ! needs the same increment that Q(1) got, but applied to the ! new fine initial condition if (( which . eq . 0 ) . or . ( which . eq . 1 )) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 1 ) end if if ( pf % rank /= pf % comm % nproc - 1 ) then if ( which . eq . 2 ) call interpolate_qend ( pf , f_lev_p , c_lev_p ) end if ! don't sweep on the finest level since that is only done at beginning if ( level_index < level_index_f ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) else !  compute residual for diagnostics since we didn't sweep call pf_residual ( pf , f_lev_p % index , dt , which ) end if end do end subroutine pf_v_cycle_oc","tags":"","loc":"proc/pf_v_cycle_oc.html","title":"pf_v_cycle_oc – LibPFASST"},{"text":"public subroutine amisdc_sweep(this, pf, lev, t0, dt) Uses pf_mod_timer Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Contents Source Code amisdc_sweep Source Code subroutine amisdc_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhsA , rhsB , QA , QB call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f1eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) call this % f2eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 )) call this % f3eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 )) call lev % ulevel % factory % create_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QB , lev % index , lev % shape ) call QA % setval ( 0.0_pfdp ) call QB % setval ( 0.0_pfdp ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) ! First compute the explicit part of the right-hand side call rhsA % copy ( lev % Q ( m )) call rhsA % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhsA % axpy ( 1.0_pfdp , lev % S ( m )) ! Save the right-hand side with only the explicit contribution call rhsB % copy ( rhsA ) ! Add the first implicit part to the right-hand side and solve for the first asynchronous update call rhsA % axpy ( - 2.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 2 )) call this % f2comp ( QA , t , 2.0_pfdp * dtsdc ( m ), rhsA , lev % index , lev % F ( m + 1 , 2 )) ! Add the second implicit part to the right-hand side and solve for the second asynchronous update call rhsB % axpy ( - 2.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 3 )) call this % f3comp ( QB , t , 2.0_pfdp * dtsdc ( m ), rhsB , lev % index , lev % F ( m + 1 , 3 )) ! Now we average the two asynchronous updates call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QA ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QB ) ! Evaluate the three right-hand sides with the updated variables call this % f1eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 )) call this % f2eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 )) call this % f3eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 3 )) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! Destroy the temporary variables call lev % ulevel % factory % destroy_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QB , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine amisdc_sweep","tags":"","loc":"proc/amisdc_sweep.html","title":"amisdc_sweep – LibPFASST"},{"text":"public subroutine amisdc_evaluate(this, lev, t, m) Uses pf_mod_dtype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m Contents Source Code amisdc_evaluate Source Code subroutine amisdc_evaluate ( this , lev , t , m ) use pf_mod_dtype class ( pf_amisdc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f1eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) call this % f2eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 )) call this % f3eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 )) end subroutine amisdc_evaluate","tags":"","loc":"proc/amisdc_evaluate.html","title":"amisdc_evaluate – LibPFASST"},{"text":"public subroutine amisdc_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code amisdc_initialize Source Code subroutine amisdc_initialize ( this , lev ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine amisdc_initialize","tags":"","loc":"proc/amisdc_initialize.html","title":"amisdc_initialize – LibPFASST"},{"text":"public subroutine amisdc_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code amisdc_destroy Source Code subroutine amisdc_destroy ( this , lev ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine amisdc_destroy","tags":"","loc":"proc/amisdc_destroy.html","title":"amisdc_destroy – LibPFASST"},{"text":"public subroutine amisdc_integrate(this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) Contents Source Code amisdc_integrate Source Code subroutine amisdc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine amisdc_integrate","tags":"","loc":"proc/amisdc_integrate.html","title":"amisdc_integrate – LibPFASST"},{"text":"public subroutine amisdc_residual(this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt Contents Source Code amisdc_residual Source Code subroutine amisdc_residual ( this , lev , dt ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine amisdc_residual","tags":"","loc":"proc/amisdc_residual.html","title":"amisdc_residual – LibPFASST"},{"text":"public subroutine amisdc_evaluate_all(this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) Contents Source Code amisdc_evaluate_all Source Code subroutine amisdc_evaluate_all ( this , lev , t ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine amisdc_evaluate_all","tags":"","loc":"proc/amisdc_evaluate_all.html","title":"amisdc_evaluate_all – LibPFASST"},{"text":"interface public subroutine pf_f1eval_p(this, y, t, level, f1) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f1","tags":"","loc":"interface/pf_f1eval_p.html","title":"pf_f1eval_p – LibPFASST"},{"text":"interface public subroutine pf_f2eval_p(this, y, t, level, f2) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2","tags":"","loc":"interface/pf_f2eval_p.html","title":"pf_f2eval_p – LibPFASST"},{"text":"interface public subroutine pf_f2comp_p(this, y, t, dt, rhs, level, f2) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2","tags":"","loc":"interface/pf_f2comp_p.html","title":"pf_f2comp_p – LibPFASST"},{"text":"interface public subroutine pf_f3eval_p(this, y, t, level, f3) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3","tags":"","loc":"interface/pf_f3eval_p.html","title":"pf_f3eval_p – LibPFASST"},{"text":"interface public subroutine pf_f3comp_p(this, y, t, dt, rhs, level, f3) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3","tags":"","loc":"interface/pf_f3comp_p.html","title":"pf_f3comp_p – LibPFASST"},{"text":"public subroutine start_timer(pf, timer) Subroutine to start a timer Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: timer Contents Source Code start_timer Source Code subroutine start_timer ( pf , timer ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: timer pf % timers ( timer ) = MPI_Wtime () end subroutine start_timer","tags":"","loc":"proc/start_timer.html","title":"start_timer – LibPFASST"},{"text":"public subroutine end_timer(pf, timer) Subroutine to stop a timer Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: timer Contents Source Code end_timer Source Code subroutine end_timer ( pf , timer ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: timer double precision :: t t = MPI_Wtime () pf % runtimes ( timer ) = pf % runtimes ( timer ) + t - pf % timers ( timer ) if ( pf % echo_timings ) then write ( * , '(\"timer:\",a16,\", rank: \",i3,\", step: \",i4, \", level: \", i3,' & // '\", iter: \",i3, f23.8,f23.8,f23.8)' ) & timer_names ( timer ), pf % rank , & pf % state % step , pf % state % level , pf % state % iter , & t - pf % timers ( timer ), pf % runtimes ( timer ), t - pf % timers ( TTOTAL ) end if end subroutine end_timer","tags":"","loc":"proc/end_timer.html","title":"end_timer – LibPFASST"},{"text":"public subroutine initialize_results(this, nsteps_in, niters_in, nprocs_in, nsweeps_in, rank_in, level_index, datpath, save_residuals) Arguments Type Intent Optional Attributes Name class( pf_results_t ), intent(inout) :: this integer, intent(in) :: nsteps_in integer, intent(in) :: niters_in integer, intent(in) :: nprocs_in integer, intent(in) :: nsweeps_in integer, intent(in) :: rank_in integer, intent(in) :: level_index character(len=*), intent(in) :: datpath logical, intent(in) :: save_residuals Contents Source Code initialize_results Source Code subroutine initialize_results ( this , nsteps_in , niters_in , nprocs_in , nsweeps_in , rank_in , level_index , datpath , save_residuals ) class ( pf_results_t ), intent ( inout ) :: this integer , intent ( in ) :: nsteps_in , niters_in , nprocs_in , nsweeps_in , rank_in , level_index character ( len =* ), intent ( in ) :: datpath logical , intent ( in ) :: save_residuals character ( len = 128 ) :: fname !!  output file name for residuals character ( len = 256 ) :: fullname !!  output file name for residuals integer :: istat , system !  Set up the directory to dump results if ( save_residuals ) then istat = system ( 'mkdir -p ' // trim ( datpath )) this % datpath = trim ( datpath ) // '/' if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in initialize_results\" ) write ( fname , \"(A16,I0.1,A4)\" ) 'residuals_size_L' , level_index , '.dat' fullname = trim ( this % datpath ) // trim ( fname ) if ( rank_in == 0 ) then open ( unit = 123 , file = trim ( fullname ), form = 'formatted' ) write ( 123 , '(I5, I5, I5, I5)' ) nsteps_in , niters_in , nprocs_in , nsweeps_in close ( unit = 123 ) end if end if !    this%dump => dump_results this % destroy => destroy_results this % nsteps = nsteps_in this % nblocks = nsteps_in / nprocs_in this % niters = niters_in this % nprocs = nprocs_in this % nsweeps = nsweeps_in this % rank = rank_in this % level = level_index if (. not . allocated ( this % errors )) allocate ( this % errors ( niters_in , this % nblocks , nsweeps_in )) if (. not . allocated ( this % residuals )) allocate ( this % residuals ( niters_in , this % nblocks , nsweeps_in )) this % errors = - 1.0_pfdp this % residuals = - 1.0_pfdp end subroutine initialize_results","tags":"","loc":"proc/initialize_results.html","title":"initialize_results – LibPFASST"},{"text":"public subroutine dump_resids(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this Contents Source Code dump_resids Source Code subroutine dump_resids ( this ) type ( pf_results_t ), intent ( inout ) :: this integer :: i , j , k , istat , system character ( len = 128 ) :: fname !!  output file name for residuals character ( len = 256 ) :: fullname !!  output file name for residuals character ( len = 128 ) :: datpath !!  directory path datpath = trim ( this % datpath ) // 'residuals' istat = system ( 'mkdir -p ' // trim ( datpath )) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in dump_resids\" ) write ( fname , \"(A6,I0.3,A5,I0.1,A4)\" ) '/Proc_' , this % rank , '_Lev_' , this % level , '.dat' fullname = trim ( datpath ) // trim ( fname ) !  output residuals open ( 100 + this % rank , file = trim ( fullname ), form = 'formatted' ) do j = 1 , this % nblocks do i = 1 , this % niters do k = 1 , this % nsweeps write ( 100 + this % rank , '(I4, I4, I4, e22.14)' ) j , i , k , this % residuals ( i , j , k ) end do end do enddo close ( 100 + this % rank ) end subroutine dump_resids","tags":"","loc":"proc/dump_resids.html","title":"dump_resids – LibPFASST"},{"text":"public subroutine dump_errors(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this Contents Source Code dump_errors Source Code subroutine dump_errors ( this ) type ( pf_results_t ), intent ( inout ) :: this integer :: i , j , k , istat , system character ( len = 128 ) :: fname !!  output file name for residuals character ( len = 256 ) :: fullname !!  output file name for residuals character ( len = 128 ) :: datpath !!  directory path datpath = trim ( this % datpath ) // 'errors' istat = system ( 'mkdir -p ' // trim ( datpath )) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in dump_errors\" ) write ( fname , \"(A6,I0.3,A5,I0.1,A4)\" ) '/Proc_' , this % rank , '_Lev_' , this % level , '.dat' fullname = trim ( datpath ) // trim ( fname ) !  output errors open ( 100 + this % rank , file = trim ( fullname ), form = 'formatted' ) do j = 1 , this % nblocks do i = 1 , this % niters do k = 1 , this % nsweeps write ( 100 + this % rank , '(I4, I4, I4, e22.14)' ) j , i , k , this % errors ( i , j , k ) end do end do enddo close ( 100 + this % rank ) end subroutine dump_errors","tags":"","loc":"proc/dump_errors.html","title":"dump_errors – LibPFASST"},{"text":"public subroutine dump_timings(pf) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Contents Source Code dump_timings Source Code subroutine dump_timings ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf character ( len = 128 ) :: fname !!  output file name for runtimes character ( len = 256 ) :: fullname !!  output file name for runtimes character ( len = 128 ) :: datpath !!  directory path integer :: istat , j , istream , system datpath = trim ( pf % outdir ) // '/runtimes' istat = system ( 'mkdir -p ' // trim ( datpath )) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in dump_timings\" ) write ( fname , \"(A6,I0.3,A4)\" ) '/Proc_' , pf % rank , '.dat' fullname = trim ( datpath ) // trim ( fname ) istream = 200 + pf % rank !  Use processor dependent file number !  output timings open ( istream , file = trim ( fullname ), form = 'formatted' ) do j = 1 , 100 if ( pf % runtimes ( j ) > 0.0d0 ) then write ( istream , '(a16,  f23.8)' ) timer_names ( j ), pf % runtimes ( j ) end if end do close ( istream ) end subroutine dump_timings","tags":"","loc":"proc/dump_timings.html","title":"dump_timings – LibPFASST"},{"text":"public subroutine destroy_results(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this Contents Source Code destroy_results Source Code subroutine destroy_results ( this ) type ( pf_results_t ), intent ( inout ) :: this if ( allocated ( this % errors )) deallocate ( this % errors ) if ( allocated ( this % residuals )) deallocate ( this % residuals ) end subroutine destroy_results","tags":"","loc":"proc/destroy_results.html","title":"destroy_results – LibPFASST"},{"text":"public function cast_as_ndarray(encap_polymorph) result(ndarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndarray ),\n  pointer Contents Source Code cast_as_ndarray Source Code function cast_as_ndarray ( encap_polymorph ) result ( ndarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndarray ), pointer :: ndarray_obj select type ( encap_polymorph ) type is ( ndarray ) ndarray_obj => encap_polymorph end select end function cast_as_ndarray","tags":"","loc":"proc/cast_as_ndarray.html","title":"cast_as_ndarray – LibPFASST"},{"text":"public function ndarray_norm(this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code ndarray_norm Source Code function ndarray_norm ( this , flags ) result ( norm ) class ( ndarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function ndarray_norm","tags":"","loc":"proc/ndarray_norm.html","title":"ndarray_norm – LibPFASST"},{"text":"public function get_array1d(x, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d Source Code function get_array1d ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) select type ( x ) type is ( ndarray ) r => x % flatarray end select end function get_array1d","tags":"","loc":"proc/get_array1d~4.html","title":"get_array1d – LibPFASST"},{"text":"public function get_array2d(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d Source Code function get_array2d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( ndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % flatarray end select end function get_array2d","tags":"","loc":"proc/get_array2d~4.html","title":"get_array2d – LibPFASST"},{"text":"public function get_array3d(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d Source Code function get_array3d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( ndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % flatarray end select end function get_array3d","tags":"","loc":"proc/get_array3d~4.html","title":"get_array3d – LibPFASST"},{"text":"public subroutine ndarray_build(q, shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) Contents Source Code ndarray_build Source Code subroutine ndarray_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) select type ( q ) class is ( ndarray ) allocate ( q % shape ( size ( shape ))) allocate ( q % flatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape end select end subroutine ndarray_build","tags":"","loc":"proc/ndarray_build.html","title":"ndarray_build – LibPFASST"},{"text":"public subroutine ndarray_create_single(this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndarray_create_single Source Code subroutine ndarray_create_single ( this , x , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) integer :: i allocate ( ndarray :: x ) call ndarray_build ( x , shape ) end subroutine ndarray_create_single","tags":"","loc":"proc/ndarray_create_single.html","title":"ndarray_create_single – LibPFASST"},{"text":"public subroutine ndarray_create_array(this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndarray_create_array Source Code subroutine ndarray_create_array ( this , x , n , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndarray :: x ( n )) do i = 1 , n call ndarray_build ( x ( i ), shape ) end do end subroutine ndarray_create_array","tags":"","loc":"proc/ndarray_create_array.html","title":"ndarray_create_array – LibPFASST"},{"text":"public subroutine ndarray_destroy(encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Contents Source Code ndarray_destroy Source Code subroutine ndarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndarray ), pointer :: ndarray_obj ndarray_obj => cast_as_ndarray ( encap ) deallocate ( ndarray_obj % shape ) deallocate ( ndarray_obj % flatarray ) nullify ( ndarray_obj ) end subroutine ndarray_destroy","tags":"","loc":"proc/ndarray_destroy.html","title":"ndarray_destroy – LibPFASST"},{"text":"public subroutine ndarray_destroy_single(this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x Contents Source Code ndarray_destroy_single Source Code subroutine ndarray_destroy_single ( this , x ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( ndarray ) deallocate ( x % shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine ndarray_destroy_single","tags":"","loc":"proc/ndarray_destroy_single.html","title":"ndarray_destroy_single – LibPFASST"},{"text":"public subroutine ndarray_destroy_array(this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Contents Source Code ndarray_destroy_array Source Code subroutine ndarray_destroy_array ( this , x ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( ndarray ) do i = 1 , size ( x ) deallocate ( x ( i )% shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine ndarray_destroy_array","tags":"","loc":"proc/ndarray_destroy_array.html","title":"ndarray_destroy_array – LibPFASST"},{"text":"public subroutine ndarray_setval(this, val, flags) The following are the base subroutines that all encapsulations must provide Subroutine to set array to a scalare  value. Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code ndarray_setval Source Code subroutine ndarray_setval ( this , val , flags ) class ( ndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine ndarray_setval","tags":"","loc":"proc/ndarray_setval.html","title":"ndarray_setval – LibPFASST"},{"text":"public subroutine ndarray_copy(this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Contents Source Code ndarray_copy Source Code subroutine ndarray_copy ( this , src , flags ) class ( ndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( ndarray ) this % flatarray = src % flatarray class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_copy","tags":"","loc":"proc/ndarray_copy.html","title":"ndarray_copy – LibPFASST"},{"text":"public subroutine ndarray_pack(this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndarray_pack Source Code subroutine ndarray_pack ( this , z , flags ) class ( ndarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags z = this % flatarray end subroutine ndarray_pack","tags":"","loc":"proc/ndarray_pack.html","title":"ndarray_pack – LibPFASST"},{"text":"public subroutine ndarray_unpack(this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndarray_unpack Source Code subroutine ndarray_unpack ( this , z , flags ) class ( ndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags this % flatarray = z end subroutine ndarray_unpack","tags":"","loc":"proc/ndarray_unpack.html","title":"ndarray_unpack – LibPFASST"},{"text":"public subroutine ndarray_axpy(this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Contents Source Code ndarray_axpy Source Code subroutine ndarray_axpy ( this , a , x , flags ) class ( ndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( ndarray ) this % flatarray = a * x % flatarray + this % flatarray class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_axpy","tags":"","loc":"proc/ndarray_axpy.html","title":"ndarray_axpy – LibPFASST"},{"text":"public subroutine ndarray_eprint(this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code ndarray_eprint Source Code subroutine ndarray_eprint ( this , flags ) class ( ndarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values if ( product ( this % shape ) < 10 ) then print * , this % flatarray else print * , this % flatarray ( 1 : 10 ) endif end subroutine ndarray_eprint","tags":"","loc":"proc/ndarray_eprint.html","title":"ndarray_eprint – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine ndarray_dump_numpy(dname, fname, endian, dim, mpibuflen, shape, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Description Subroutine to write an the array to a file","tags":"","loc":"interface/ndarray_dump_numpy.html","title":"ndarray_dump_numpy – LibPFASST"},{"text":"public subroutine misdcQ_oc_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags Contents Source Code misdcQ_oc_sweep Source Code subroutine misdcQ_oc_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index , nsweeps real ( pfdp ), intent ( in ) :: dt , t0 integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev integer :: k , m , n , which , Nnodes real ( pfdp ) :: t , tend logical :: sweep_y , sweep_p integer :: step lev => pf % levels ( level_index ) !  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) step = pf % state % step + 1 which = 0 if ( present ( flags )) which = flags if ( which . eq . 1 ) then sweep_y = . true . sweep_p = . false . else if ( which . eq . 2 ) then sweep_y = . false . sweep_p = . true . else sweep_y = . true . sweep_p = . true . end if Nnodes = lev % nnodes tend = t0 + dt do k = 1 , nsweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction if ( sweep_y ) then !  Forward in y do m = 1 , Nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp , 1 ) call this % I3 ( m )% setval ( 0.0_pfdp , 1 ) do n = 1 , Nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 ), 1 ) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( m , n ), lev % F ( n , 3 ), 1 ) call this % I3 ( m )% axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 ), 1 ) end do if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 1 ) end if end do end if if ( sweep_p ) then !  Backward in p do m = Nnodes - 1 , 1 , - 1 call lev % I ( m )% setval ( 0.0_pfdp , 2 ) call this % I3 ( m )% setval ( 0.0_pfdp , 2 ) do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffE ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 1 ), 2 ) call lev % I ( m )% axpy ( dt * this % QdiffI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 2 ), 2 ) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 3 ), 2 ) call this % I3 ( m )% axpy ( dt * this % QtilI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 3 ), 2 ) end do if ( level_index < pf % state % finest_level ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 2 ) end if end do end if ! do the time-stepping if ( k . eq . 1 ) then if ( sweep_y ) then call lev % Q ( 1 )% copy ( lev % q0 , 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 , 1 , 1 , step ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 , 1 , 1 , step ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 , 1 , 1 , step ) end if if ( sweep_p ) then call lev % Q ( Nnodes )% copy ( lev % qend , 2 ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 1 ), 1 , 2 , Nnodes , step ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 2 ), 2 , 2 , Nnodes , step ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 3 ), 3 , 2 , Nnodes , step ) end if end if ! k .eq. 1 if ( sweep_y ) then t = t0 do m = 1 , lev % nnodes - 1 t = t + dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp , 1 ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 ), 1 ) call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 ), 1 ) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 1 ) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( lev % Q ( m + 1 ), 1 ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 ), 1 ) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m ), 1 ) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 3 ), 3 , 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 , 1 , m + 1 , step ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 , m + 1 , step ) end do !call pf_residual(pf, level_index, dt, 1) call lev % qend % copy ( lev % Q ( lev % nnodes ), 1 ) end if ! sweep_y if ( sweep_p ) then t = tend do m = Nnodes - 1 , 1 , - 1 t = t - dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp , 2 ) do n = Nnodes , m + 1 , - 1 call this % rhs % axpy ( dt * this % QtilE ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 1 ), 2 ) call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 2 ), 2 ) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( Nnodes ), 2 ) call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 2 ), 2 , 2 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( lev % Q ( m ), 2 ) do n = Nnodes , m + 1 , - 1 call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 3 ), 2 ) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m ), 2 ) call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 3 ), 3 , 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , 2 , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , 2 , m , step ) end do !call pf_residual(pf, level_index, dt, 2) call lev % q0 % copy ( lev % Q ( 1 ), 2 ) end if ! sweep_p if ( sweep_p . and . sweep_y ) then call pf_residual ( pf , level_index , dt , 0 ) else if ( sweep_y ) then call pf_residual ( pf , level_index , dt , 1 ) else if ( sweep_p ) then call pf_residual ( pf , level_index , dt , 2 ) else stop \"neither sweep on p nor on y : that should not happen\" end if ! done call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! k=1,nsweeps end subroutine misdcQ_oc_sweep","tags":"","loc":"proc/misdcq_oc_sweep.html","title":"misdcQ_oc_sweep – LibPFASST"},{"text":"public subroutine misdcQ_oc_initialize(this, pf, level_index) Make space for rhs Make space for extra integration piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code misdcQ_oc_initialize Source Code subroutine misdcQ_oc_initialize ( this , pf , level_index ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index integer :: m , n , nnodes type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % dtsdc ( nnodes - 1 )) this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) !>  Make space for extra integration piece call lev % ulevel % factory % create_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) end subroutine misdcQ_oc_initialize","tags":"","loc":"proc/misdcq_oc_initialize.html","title":"misdcQ_oc_initialize – LibPFASST"},{"text":"public subroutine misdcQ_oc_destroy(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code misdcQ_oc_destroy Source Code subroutine misdcQ_oc_destroy ( this , pf , level_index ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % I3 ) call lev % ulevel % factory % destroy_single ( this % rhs ) end subroutine misdcQ_oc_destroy","tags":"","loc":"proc/misdcq_oc_destroy.html","title":"misdcQ_oc_destroy – LibPFASST"},{"text":"public subroutine misdcQ_oc_integrate(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code misdcQ_oc_integrate Source Code subroutine misdcQ_oc_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: n , m , p , which type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer which = 0 if ( present ( flags )) which = flags do n = 1 , lev % nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call fintSDC ( n )% setval ( 0.0_pfdp , 1 ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , p ), 1 ) end do end do end if !  Backward in p if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call fintSDC ( lev % nnodes - n )% setval ( 0.0_pfdp , 2 ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( lev % nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( lev % nnodes + 1 - m , p ), 2 ) end do end do end if end do end subroutine misdcQ_oc_integrate","tags":"","loc":"proc/misdcq_oc_integrate.html","title":"misdcQ_oc_integrate – LibPFASST"},{"text":"public subroutine misdcQ_oc_evaluate(this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_oc_evaluate Source Code subroutine misdcQ_oc_evaluate ( this , pf , level_index , t , m , flags , step ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , optional , intent ( in ) :: flags , step integer :: which , mystep type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer which = 0 if ( present ( flags )) which = flags mystep = 1 if ( present ( step )) mystep = step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , which , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , which , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 , which , m , step ) end subroutine misdcQ_oc_evaluate","tags":"","loc":"proc/misdcq_oc_evaluate.html","title":"misdcQ_oc_evaluate – LibPFASST"},{"text":"public subroutine misdcQ_oc_evaluate_all(this, pf, level_index, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_oc_evaluate_all Source Code subroutine misdcQ_oc_evaluate_all ( this , pf , level_index , t , flags , step ) !! Evaluate all function values class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) integer , intent ( in ), optional :: flags , step integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer if (. not . present ( flags )) stop \"MISDCQ_OC EVAL_ALL WITHOUT FLAGS\" if (. not . present ( step )) stop \"MISDCQ_OC EVAL_ALL WITHOUT step\" do m = 1 , lev % nnodes call this % evaluate ( pf , level_index , t ( m ), m , flags , step ) end do end subroutine misdcQ_oc_evaluate_all","tags":"","loc":"proc/misdcq_oc_evaluate_all.html","title":"misdcQ_oc_evaluate_all – LibPFASST"},{"text":"public subroutine misdcQ_oc_residual(this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code misdcQ_oc_residual Source Code subroutine misdcQ_oc_residual ( this , pf , level_index , dt , flags ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m , n , which type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer which = 0 if ( present ( flags )) which = flags call this % integrate ( pf , level_index , pf % levels ( level_index )% Q , pf % levels ( level_index )% F , dt , & pf % levels ( level_index )% I , which ) ! add tau (which is 'node to node') if ( level_index < pf % state % finest_level ) then do m = 1 , pf % levels ( level_index )% nnodes - 1 call pf % levels ( level_index )% I ( m )% axpy ( 1.0_pfdp , pf % levels ( level_index )% tauQ ( m ), which ) end do end if ! subtract out Q do m = 1 , pf % levels ( level_index )% nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call pf % levels ( level_index )% R ( m )% copy ( pf % levels ( level_index )% I ( m ), 1 ) call pf % levels ( level_index )% R ( m )% axpy ( 1.0_pfdp , pf % levels ( level_index )% Q ( 1 ), 1 ) call pf % levels ( level_index )% R ( m )% axpy ( - 1.0_pfdp , pf % levels ( level_index )% Q ( m + 1 ), 1 ) end if if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call pf % levels ( level_index )% R ( m )% copy ( pf % levels ( level_index )% I ( m ), 2 ) call pf % levels ( level_index )% R ( m )% axpy ( 1.0_pfdp , pf % levels ( level_index )% Q ( pf % levels ( level_index )% nnodes ), 2 ) call pf % levels ( level_index )% R ( m )% axpy ( - 1.0_pfdp , pf % levels ( level_index )% Q ( m ), 2 ) end if end do end subroutine misdcQ_oc_residual","tags":"","loc":"proc/misdcq_oc_residual.html","title":"misdcQ_oc_residual – LibPFASST"},{"text":"public subroutine misdcQ_oc_spreadq0(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_oc_spreadq0 Source Code subroutine misdcQ_oc_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer :: m , p , which , mystep type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer which = 3 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SPREADQ0 WITHOUT FLAGS\" mystep = 1 if ( present ( step )) then mystep = step !needed for sequential version else print * , \"step not present in spreadq0\" , which stop end if select case ( which ) case ( 1 ) !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , 1 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , 1 , 1 , mystep ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), 1 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p ), 1 ) end do end do case ( 2 ) !  Stick terminal condition into last node slot call lev % Q ( lev % nnodes )% copy ( lev % qend , 2 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( pf , level_index , t0 , lev % nnodes , 2 , mystep ) ! Spread F and solution to all nodes do m = lev % nnodes - 1 , 1 , - 1 call lev % Q ( m )% copy ( lev % Q ( lev % nnodes ), 2 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( lev % nnodes , p ), 2 ) end do end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) stop end select end subroutine misdcQ_oc_spreadq0","tags":"","loc":"proc/misdcq_oc_spreadq0.html","title":"misdcQ_oc_spreadq0 – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward integer, intent(in), optional :: idx index of quadrature node integer, intent(in), optional :: step time step for sequential version Description This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two\n  Evaluate f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~9.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward Description Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece","tags":"","loc":"interface/pf_f_comp_p~7.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine pf_pfasst_run(pf, q0, dt, tend, nsteps, qend, flags) This is the main interface to pfasst.\n  It examines the parameters and decides which subroutine to call\n  to execute the code correctly\n  Set the number of time steps to do\n  The user can either pass in the number of time steps or\n  pass in the time step size and length of run\n  Allocate stuff for holding results deallocate results data Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf The complete PFASST structure class( pf_encap_t ), intent(inout) :: q0 The initial condition real(kind=pfdp), intent(in) :: dt The time step for each processor real(kind=pfdp), intent(in) :: tend The final time of run integer, intent(in), optional :: nsteps The number of time steps class( pf_encap_t ), intent(inout), optional :: qend The computed solution at tend integer, intent(in), optional :: flags (:) User defnined flags Contents Source Code pf_pfasst_run Source Code subroutine pf_pfasst_run ( pf , q0 , dt , tend , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  The complete PFASST structure class ( pf_encap_t ), intent ( inout ) :: q0 !!  The initial condition real ( pfdp ), intent ( in ) :: dt !!  The time step for each processor real ( pfdp ), intent ( in ) :: tend !!  The final time of run integer , intent ( in ), optional :: nsteps !!  The number of time steps class ( pf_encap_t ), intent ( inout ), optional :: qend !!  The computed solution at tend integer , intent ( in ), optional :: flags (:) !!  User defnined flags !  Local variables integer :: nproc !!  Total number of processors integer :: nsteps_loc !!  local number of time steps real ( pfdp ) :: tend_loc !!  The final time of run ! make a local copy of nproc nproc = pf % comm % nproc !>  Set the number of time steps to do !!  The user can either pass in the number of time steps or !!  pass in the time step size and length of run if ( present ( nsteps )) then nsteps_loc = nsteps tend_loc = dble ( nsteps_loc * dt ) else nsteps_loc = ceiling ( tend / dt ) !  Do  sanity check on steps if ( abs ( real ( nsteps_loc , pfdp ) - tend / dt ) > dt / 10 0.0 ) then print * , 'dt=' , dt print * , 'nsteps=' , nsteps_loc print * , 'tend=' , tend stop \"Invalid nsteps\" end if end if pf % state % nsteps = nsteps_loc !>  Allocate stuff for holding results call pf_initialize_results ( pf ) !  do sanity checks on Nproc if ( mod ( nsteps , nproc ) > 0 ) stop \"ERROR: nsteps must be multiple of nproc (pf_parallel.f90).\" if ( present ( qend )) then call pf_block_run ( pf , q0 , dt , nsteps_loc , qend = qend , flags = flags ) else call pf_block_run ( pf , q0 , dt , nsteps_loc , flags = flags ) end if call pf_dump_results ( pf ) !>   deallocate results data call pf_destroy_results ( pf ) !  What we would like to do is check for !  1.  nlevels==1  and nprocs ==1 -> Serial SDC !      Predictor is either spreadQ or nothing !      Then we just call a loop on sweeps !      Communication is copy !  2.  nlevels > 1  and nprocs ==1 -> Serial MLSDC !      Predictor is needed to populate levels (or nothing) !      Then we just call a loop on MLSDC sweeps !      Communication is copy !  3.  nlevels == 1  and nprocs > 1 -> Pipelined SDC !      Predictor is just like PFASST, but on finest (only) level (or nothing) !  4.  nlevels > 1  and nprocs > 1 -> PFASST end subroutine pf_pfasst_run","tags":"","loc":"proc/pf_pfasst_run.html","title":"pf_pfasst_run – LibPFASST"},{"text":"public subroutine pf_predictor(pf, t0, dt, flags) PFASST Predictor.\n  Subroutine  to initialize the solution on each processor\n  The goal is to have a solution at each level and each node set to a consistent value\n  When this is called, the value of q0 at the fine level on each processor has been set somehow (see q0_style below) This can be broken down into four substeps\n 1. Get the  initial condition on the finest level at each node\n 2. Coarsen the initial condition to each coarser level with tau corrections\n 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent\n    (this is skipped if the fine initial conditions are already consistent)\n 4. Do some coarse grid sweeps to improve initial solutions on coarsest nodes\n 5. Interpolating coarse correction back to finer levels sweeping along the way. There are several parameters or flags that determine how things are done:\n  integer  q0_style:    can take 3 values\n           0:  Only the q0 at t=0 is valid  (default)\n           1:  The q0 at each processor is valid\n           2:  q0 and all nodes at each processor is valid\n logical  PFASST_pred:  If true, the burn-in step uses the \"PFASST predictor\" trick\n integer  nsweeps_burn: Determines how many sweeps are done on the coarse level during burn in\n integer  nsweeps_pred: Determines how many sweeps are done at the coarse level after burn in\n logical Pipeline_burn: True if coarse sweeps during burn in are pipelined  (meaningless if nsweeps_burn>1 on coarse level)\n logical Pipeline_pred: True if coarse sweeps after burn in are pipelined  (meaningless if nsweeps_pred>1 on coarse level)\n    Pipeline variables do nothing if there is only one processor\n logical  RK_pred:      If true, the coarse level is initialized with Runge-Kutta instead of the  PFASST burn in.\n                        We  will still do coarse sweeps after and correct finer levels The user defined flags(:) parameter is used to determine whether we are in a (standard) forward-in-time run (flags(1) == 1)\n or backward-in-time (for the adjoint) with a given terminal condition qend instead of initial condition q0  (flags(1) == 2).\n In the latter case, e.g., sweeper%spreadq0 has to do the correct thing (i.e., spread qend instead of q0). No time communication is performed during the predictor since all\n procesors can do the work themselves The iteration count is reset to 0, and the status is reset to\n  ITERATING. Step 1. Getting the  initial condition on the finest level at each processor\n         If we are doing multiple levels, then we need to coarsen to fine level Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent\n         (this is skipped if the fine initial conditions are already consistent)\n The first processor does nothing, the second does one set of sweeps, the third two, etc\n Hence, this is skipped completely if nprocs=1\n If RK_pred is true, just do some RK_steps Step 4: Now we have everyone burned in, so do some coarse sweeps Step 5:  Return to fine level sweeping on any level in between coarsest and finest Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags Contents Source Code pf_predictor Source Code subroutine pf_predictor ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p !! integer :: k !!  Loop indices integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k pf % state % iter = - 1 call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning predictor' !! !! Step 1. Getting the  initial condition on the finest level at each processor !!         If we are doing multiple levels, then we need to coarsen to fine level f_lev_p => pf % levels ( pf % state % finest_level ) if ( pf % q0_style < 2 ) then !  Spread q0 to all the nodes call f_lev_p % ulevel % sweeper % spreadq0 ( pf , pf % state % finest_level , t0 ) endif !! !!  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do coarsen  in predictor' if ( pf % state % finest_level > 1 ) then do level_index = pf % state % finest_level , 2 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call pf_residual ( pf , f_lev_p % index , dt ) call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0 , t0 ) call restrict_time_space_fas ( pf , t0 , dt , level_index ) !  Restrict call save ( pf , c_lev_p ) end do !  level_index = pf%state%finest_level, 2, -1 else level_index = 1 c_lev_p => pf % levels ( 1 ) end if !! !! Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !!         (this is skipped if the fine initial conditions are already consistent) !! The first processor does nothing, the second does one set of sweeps, the third two, etc !! Hence, this is skipped completely if nprocs=1 if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do burnin  in predictor' if ( pf % q0_style . eq . 0 ) then !  The coarse level needs burn in !! If RK_pred is true, just do some RK_steps if ( pf % RK_pred ) then !  Use Runge-Kutta to get the coarse initial data !  Get new initial conditions call pf_recv ( pf , c_lev_p , 100000 + pf % rank , . true .) !  Do a RK_step call c_lev_p % ulevel % stepper % do_n_steps ( pf , level_index , t0 , c_lev_p % q0 , c_lev_p % qend , dt , 1 ) !  Send forward call pf_send ( pf , c_lev_p , 100000 + pf % rank + 1 , . false .) print * , 'woo hoo' else !  Normal PFASST burn in level_index = 1 c_lev_p => pf % levels ( level_index ) do k = 1 , pf % rank + 1 pf % state % iter = - k t0k = t0 - ( pf % rank ) * dt + ( k - 1 ) * dt ! Remember t0=pf%rank*dt is the beginning of this time slice so t0-(pf%rank)*dt is 0 ! and we iterate up to the correct time step. ! for optimal control problem t, t0k has no influence on f_eval, so there this does something else ! Get new initial value (skip on first iteration) if ( k > 1 ) then call c_lev_p % q0 % copy ( c_lev_p % qend , flags = 0 ) ! If we are doing PFASST_pred, we use the old values at nodes, otherwise spread q0 if (. not . pf % PFASST_pred ) then call c_lev_p % ulevel % sweeper % spreadq0 ( pf , level_index , t0k ) end if end if !  Do some sweeps call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn ) end do endif !  RK_pred end if ! (q0_style .eq. 0) !! !! Step 4: Now we have everyone burned in, so do some coarse sweeps if ( pf % state % finest_level > 1 ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do sweeps  in predictor' , 'Pipeline_pred' , pf % Pipeline_pred pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING if ( pf % Pipeline_pred ) then do k = 1 , c_lev_p % nsweeps_pred pf % state % iter =- ( pf % rank + 1 ) - k !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + k , . true .) !  Do a sweep call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) !  Send forward call pf_send ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + 1 + k , . false .) end do ! k = 1, c_lev_p%nsweeps_pred-1 else !  Don't pipeline !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank , . true .) !  Do a sweeps call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , c_lev_p % nsweeps_pred ) !  Send forward call pf_send ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + 1 , . false .) endif ! (Pipeline_pred .eq. .true) then end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'returning to fine level in predictor' !! !!  Step 5:  Return to fine level sweeping on any level in between coarsest and finest do level_index = 2 , pf % state % finest_level !  Will do nothing with one level f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp ) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 0 ) if ( pf % rank /= 0 ) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 0 ) !  Do a sweep on level unless we are at the finest level if ( level_index < pf % state % finest_level ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred ) end if end do call end_timer ( pf , TPREDICTOR ) call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' end subroutine pf_predictor","tags":"","loc":"proc/pf_predictor.html","title":"pf_predictor – LibPFASST"},{"text":"public subroutine pf_check_residual(pf, level_index, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index logical, intent(out) :: residual_converged Return true if residual is below tolerances Contents Source Code pf_check_residual Source Code subroutine pf_check_residual ( pf , level_index , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if relative tolerance is met if ( pf % levels ( level_index )% residual_rel < pf % rel_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , ' residual relative tol met' , pf % levels ( level_index )% residual_rel residual_converged = . true . print * , 'DEBUG --' , pf % rank , 'residual_rel tol met' , pf % levels ( level_index )% residual_rel end if ! Check to see if absolute tolerance is met if ( pf % levels ( level_index )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( level_index )% residual residual_converged = . true . print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( level_index )% residual end if end subroutine pf_check_residual","tags":"","loc":"proc/pf_check_residual.html","title":"pf_check_residual – LibPFASST"},{"text":"public subroutine pf_check_convergence_block(pf, level_index, send_tag) Subroutine to check if the current processor has converged and\n to update the next processor on the status\n Note that if the previous processor hasn't converged yet\n (pstatus), the current processor can't be converged yet either\n Check to see if tolerances are met Until I hear the previous processor is done, recieve it's status Check to see if I am converged\n Assign status and send it forward Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index integer, intent(in) :: send_tag identifier for status send and receive Contents Source Code pf_check_convergence_block Source Code subroutine pf_check_convergence_block ( pf , level_index , send_tag ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index integer , intent ( in ) :: send_tag !! identifier for status send and receive logical :: residual_converged , converged ! Shortcut for fixed iteration mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual ( pf , level_index , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 ) then converged = . true . else !  I am not the first processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag ) end if end subroutine pf_check_convergence_block","tags":"","loc":"proc/pf_check_convergence_block.html","title":"pf_check_convergence_block – LibPFASST"},{"text":"public subroutine pf_block_run(pf, q0, dt, nsteps, qend, flags) PFASST controller for block mode\n  When starting a new block, broadcast new initial conditions to all procs\n  For initial block, this is done when initial conditions are set\n Reset some flags\n  Pack away your last solution\n  Everyone resets their q0\n  Just stick qend in q0\n  Update the step and t0 variables for new block\n Call the predictor to get an initial guess on all levels and all processors Start the loops over SDC sweeps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf class( pf_encap_t ), intent(in) :: q0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps class( pf_encap_t ), intent(inout), optional :: qend integer, intent(in), optional :: flags (:) Contents Source Code pf_block_run Source Code subroutine pf_block_run ( pf , q0 , dt , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf class ( pf_encap_t ), intent ( in ) :: q0 real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps class ( pf_encap_t ), intent ( inout ), optional :: qend integer , intent ( in ), optional :: flags (:) class ( pf_level_t ), pointer :: lev_p !!  pointer to the one level we are operating on integer :: j , k integer :: nblocks !!  The number of blocks of steps to do integer :: nproc !!  The number of processors being used integer :: level_index_c !!  Coarsest level in V (Lambda)-cycle integer :: level_max_depth !!  Finest level in V-cycle call start_timer ( pf , TTOTAL ) pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % step = pf % rank pf % state % t0 = pf % state % step * dt ! set finest level to visit in the following run pf % state % finest_level = pf % nlevels !  pointer to finest  level to start lev_p => pf % levels ( pf % state % finest_level ) !  Stick the initial condition into q0 (will happen on all processors) call lev_p % q0 % copy ( q0 , flags = 0 ) nproc = pf % comm % nproc nblocks = nsteps / nproc !  Decide what the coarsest level in the V-cycle is level_index_c = 1 if (. not . pf % Vcycle ) level_index_c = pf % state % finest_level do k = 1 , nblocks !  Loop over blocks of time steps ! print *,'Starting  step=',pf%state%step,'  block k=',k ! Each block will consist of !  1.  predictor !  2.  Vcycle until max iterations, or tolerances met !  3.  Move solution to next block !  Reset some flags !>  When starting a new block, broadcast new initial conditions to all procs !>  For initial block, this is done when initial conditions are set !> Reset some flags pf % state % iter = - 1 pf % state % itcnt = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % pfblock = k if ( k > 1 ) then if ( nproc > 1 ) then call lev_p % qend % pack ( lev_p % send ) !!  Pack away your last solution call pf_broadcast ( pf , lev_p % send , lev_p % mpibuflen , pf % comm % nproc - 1 ) call lev_p % q0 % unpack ( lev_p % send ) !!  Everyone resets their q0 else call lev_p % q0 % copy ( lev_p % qend , flags = 0 ) !!  Just stick qend in q0 end if !>  Update the step and t0 variables for new block pf % state % step = pf % state % step + pf % comm % nproc pf % state % t0 = pf % state % step * dt end if !> Call the predictor to get an initial guess on all levels and all processors call pf_predictor ( pf , pf % state % t0 , dt , flags ) !>  Start the loops over SDC sweeps pf % state % iter = 0 call call_hooks ( pf , - 1 , PF_POST_ITERATION ) call start_timer ( pf , TITERATION ) do j = 1 , pf % niters call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle call pf_v_cycle ( pf , k , pf % state % t0 , dt , level_index_c , pf % state % finest_level ) !  Check for convergence call pf_check_convergence_block ( pf , pf % state % finest_level , send_tag = 1111 * k + j ) !          print *,pf%rank, ' post res' call call_hooks ( pf , - 1 , PF_POST_ITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) then call pf % levels ( pf % nlevels )% ulevel % sweeper % sweep ( pf , pf % nlevels , pf % state % t0 , dt , 1 ) exit end if end do !  Loop over the iteration in this bloc call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) call end_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_POST_STEP ) end do !  Loop over the blocks call end_timer ( pf , TTOTAL ) !  Grab the last solution for return (if wanted) if ( present ( qend )) then call qend % copy ( lev_p % qend , flags = 0 ) end if end subroutine pf_block_run","tags":"","loc":"proc/pf_block_run.html","title":"pf_block_run – LibPFASST"},{"text":"public subroutine pf_v_cycle(pf, iteration, t0, dt, level_index_c, level_index_f, flags) Execute a V-cycle between levels nfine and ncoarse Post the nonblocking receives on the all the levels that will be recieving later\n    (for single level this will be skipped)\n move from fine to coarse doing sweeps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags Contents Source Code pf_v_cycle Source Code subroutine pf_v_cycle ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j !>  Post the nonblocking receives on the all the levels that will be recieving later !>    (for single level this will be skipped) do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ) call pf_post ( pf , f_lev_p , f_lev_p % index * 10000 + iteration ) end do !> move from fine to coarse doing sweeps do level_index = level_index_f , level_index_c + 1 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false .) call restrict_time_space_fas ( pf , t0 , dt , level_index ) call save ( pf , c_lev_p ) end do ! Do the coarsest level level_index = level_index_c f_lev_p => pf % levels ( level_index ) if ( pf % pipeline_pred ) then do j = 1 , f_lev_p % nsweeps call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . true .) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . false .) end do else call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . true .) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . false .) endif ! Now move coarse to fine interpolating and sweeping do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp ) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 0 ) call pf_recv ( pf , f_lev_p , level_index * 10000 + iteration , . false .) if ( pf % rank /= 0 ) then ! interpolate increment to q0 -- the fine initial condition ! needs the same increment that Q(1) got, but applied to the ! new fine initial condition call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 0 ) end if ! don't sweep on the finest level since that is only done at beginning if ( level_index <= level_index_f ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) else !  compute residual for diagnostics since we didn't sweep pf % state % sweep = 1 call pf_residual ( pf , f_lev_p % index , dt ) end if end do end subroutine pf_v_cycle","tags":"","loc":"proc/pf_v_cycle.html","title":"pf_v_cycle – LibPFASST"},{"text":"public subroutine pf_post(pf, level, tag, direction) Subroutine to post a receive request for a new initial condition to be received after doing some work Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(in) :: pf class(pf_level_t), intent(inout) :: level integer, intent(in) :: tag integer, intent(in), optional :: direction Contents Source Code pf_post Source Code subroutine pf_post ( pf , level , tag , direction ) type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: ierror , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'is beginning pf_post, state%pstatus=' , pf % state % pstatus , 'with tag =' , tag ierror = 0 if ( pf % rank /= 0 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 1 ) then source = pf % rank - 1 call pf % comm % post ( pf , level , tag , ierror , source ) elseif ( pf % rank /= pf % comm % nproc - 1 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 2 ) then source = pf % rank + 1 call pf % comm % post ( pf , level , tag , ierror , source ) end if if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during post' , ierror stop \"pf_parallel:pf_post\" endif if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'is leaving pf_post, state%pstatus=' , pf % state % pstatus , 'with tag =' , tag end subroutine pf_post","tags":"","loc":"proc/pf_post.html","title":"pf_post – LibPFASST"},{"text":"public subroutine pf_send_status(pf, tag, direction) Subroutine to send this processor's convergence status to the next processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in), optional :: direction Contents Source Code pf_send_status Source Code subroutine pf_send_status ( pf , tag , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: istatus integer :: ierror , dest if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction if ( pf % rank == 0 . and . dir == 2 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 1 ) return ierror = 0 istatus = pf % state % status if ( dir == 1 ) then dest = pf % rank + 1 elseif ( dir == 2 ) then dest = pf % rank - 1 else print * , pf % rank , 'warning: bad dir during send_status' , dir stop \"pf_parallel:pf_send_status\" end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begins send_status with status' , istatus , 'with tag =' , tag call pf % comm % send_status ( pf , tag , istatus , ierror , dest ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ends send_status' if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send_status' , ierror stop \"pf_parallel:pf_send_status\" endif end subroutine pf_send_status","tags":"","loc":"proc/pf_send_status.html","title":"pf_send_status – LibPFASST"},{"text":"public subroutine pf_recv_status(pf, tag, direction) Subroutine to receive the convergence status from the previous processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in), optional :: direction Contents Source Code pf_recv_status Source Code subroutine pf_recv_status ( pf , tag , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: ierror , istatus , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction !  Return if this is the first processor if ( pf % rank == 0 . and . dir == 1 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 2 ) return if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin recv_status with pstatus=' , pf % state % pstatus , ' tag=' , tag ierror = 0 if ( dir == 1 ) then source = pf % rank - 1 elseif ( dir == 2 ) then source = pf % rank + 1 else print * , pf % rank , 'warning: bad dir in recv_status' , dir stop \"pf_parallel_oc:pf_recv_status\" end if if ( pf % debug ) print * , pf % rank , 'is receiving status with tag ' , tag call pf % comm % recv_status ( pf , tag , istatus , ierror , source ) if ( ierror . eq . 0 ) then pf % state % pstatus = istatus else print * , pf % rank , 'warning: error during recv_status' , ierror stop \"pf_parallel_oc:pf_recv_status\" endif if ( pf % debug ) print * , pf % rank , 'status recvd = ' , istatus if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end recv_statuswith pstatus=' , pf % state % pstatus , 'tag=' , tag end subroutine pf_recv_status","tags":"","loc":"proc/pf_recv_status.html","title":"pf_recv_status – LibPFASST"},{"text":"public subroutine pf_send(pf, level, tag, blocking, direction) Subroutine to send the solution to the next processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(in), optional :: direction Contents Source Code pf_send Source Code subroutine pf_send ( pf , level , tag , blocking , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , optional , intent ( in ) :: direction integer :: dir , ierror , dest if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default: send forward if ( present ( direction )) dir = direction if ( pf % rank == 0 . and . dir == 2 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 1 ) return ierror = 0 ! need to wait here if ( blocking . eqv . . false .) & call pf_mpi_wait ( pf , level % index , ierror ) if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send (wait)' , ierror stop \"pf_parallel:pf_send\" end if if ( dir == 2 ) then call level % q0 % pack ( level % send , 2 ) dest = pf % rank - 1 else dest = pf % rank + 1 if ( present ( direction )) then !  This is for the imk sweeper where the presence of a flag matters call level % qend % pack ( level % send , 1 ) else call level % qend % pack ( level % send ) end if end if !     ierror = 0 call start_timer ( pf , TSEND + level % index - 1 ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin send, tag=' , tag , blocking , ' pf%state%status =' , pf % state % status !     if (pf%debug) print*,  'DEBUG --',pf%rank, size(level%send), 'send buffer=',level%send call pf % comm % send ( pf , level , tag , blocking , ierror , dest ) if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send' , ierror stop \"pf_parallel:pf_send\" endif if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end send, tag=' , tag , blocking call end_timer ( pf , TSEND + level % index - 1 ) end subroutine pf_send","tags":"","loc":"proc/pf_send.html","title":"pf_send – LibPFASST"},{"text":"public subroutine pf_recv(pf, level, tag, blocking, direction) Subroutine to recieve the solution from the previous processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf type(pf_level_t), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(in), optional :: direction Contents Source Code pf_recv Source Code subroutine pf_recv ( pf , level , tag , blocking , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf type ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , optional , intent ( in ) :: direction integer :: dir , ierror , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default: send forward if ( present ( direction )) dir = direction ierror = 0 call start_timer ( pf , TRECEIVE + level % index - 1 ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin recv, tag=' , tag , blocking , \"pf%state%pstatus=\" , pf % state % pstatus if ( pf % rank /= 0 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 1 ) then source = pf % rank - 1 call pf % comm % recv ( pf , level , tag , blocking , ierror , source ) !        if (pf%debug) print*,  'DEBUG --',pf%rank, size(level%recv), 'recv buffer=',level%recv if ( ierror . eq . 0 ) then if ( present ( direction )) then call level % q0 % unpack ( level % recv , 1 ) else call level % q0 % unpack ( level % recv ) end if end if elseif ( pf % rank /= pf % comm % nproc - 1 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 2 ) then source = pf % rank + 1 call pf % comm % recv ( pf , level , tag , blocking , ierror , source ) !        if (pf%debug) print*,  'DEBUG --',pf%rank, size(level%recv), 'recv buffer=',level%recv if ( ierror . eq . 0 ) then if ( present ( direction )) then call level % qend % unpack ( level % recv , 2 ) else call level % qend % unpack ( level % recv ) end if end if end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end recv, tag=' , tag , blocking if ( ierror . ne . 0 ) then print * , pf % rank , 'warning: mpi error during receive' , ierror stop \"pf_parallel:pf_recv\" end if call end_timer ( pf , TRECEIVE + level % index - 1 ) end subroutine pf_recv","tags":"","loc":"proc/pf_recv.html","title":"pf_recv – LibPFASST"},{"text":"public subroutine pf_broadcast(pf, y, nvar, root) Subroutine to broadcast the initial condition to all processors Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf real(kind=pfdp), intent(in) :: y (nvar) integer, intent(in) :: nvar integer, intent(in) :: root Contents Source Code pf_broadcast Source Code subroutine pf_broadcast ( pf , y , nvar , root ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: nvar , root real ( pfdp ) , intent ( in ) :: y ( nvar ) integer :: ierror if ( pf % comm % nproc . eq . 1 ) return call start_timer ( pf , TBROADCAST ) if ( pf % debug ) print * , 'beginning broadcast' call pf % comm % broadcast ( pf , y , nvar , root , ierror ) if ( ierror /= 0 ) then print * , pf % rank , 'warning:  error during broadcast' , ierror stop \"pf_parallel:pf_broadcast\" endif call end_timer ( pf , TBROADCAST ) if ( pf % debug ) print * , 'ending broadcast' end subroutine pf_broadcast","tags":"","loc":"proc/pf_broadcast.html","title":"pf_broadcast – LibPFASST"},{"text":"public subroutine save(pf, lev, flags) Save current solution and function value so that future corrections can be computed Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev Level to save on integer, intent(in), optional :: flags which component to save (state/adjoint) Contents Source Code save Source Code subroutine save ( pf , lev , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: lev !!  Level to save on integer , optional , intent ( in ) :: flags !!  which component to save (state/adjoint) integer :: m , p !  Save the data so we can interpolate correction later if ( lev % index < pf % state % finest_level ) then do m = 1 , lev % nnodes call lev % pQ ( m )% copy ( lev % Q ( m ), flags ) if ( lev % Finterp ) then do p = 1 , size ( lev % F ( 1 ,:)) call lev % pF ( m , p )% copy ( lev % F ( m , p ), flags ) end do end if end do end if end subroutine save","tags":"","loc":"proc/save.html","title":"save – LibPFASST"},{"text":"public subroutine interpolate_time_space(pf, t0, dt, level_index, F_INTERP, flags) Subroutine to interpolate (in time and space) level_index-1 to level_index\n Interpolation is done by interpolating increments. The fine function values are re-evaluated after interpolation.\n create workspaces\n set time at coarse and fine nodes\n  interpolate coarse level correction in space only\n interpolate corrections in time either interpolate function values or recompute them\n destroy local data structures Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf main pfasst structure real(kind=pfdp), intent(in) :: t0 time at beginning of time interval real(kind=pfdp), intent(in) :: dt time step integer, intent(in) :: level_index defines which level to interpolate to logical, intent(in) :: F_INTERP Flag, if true, then do interp on f not sol integer, intent(in), optional :: flags Contents Source Code interpolate_time_space Source Code subroutine interpolate_time_space ( pf , t0 , dt , level_index , F_INTERP , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! main pfasst structure real ( pfdp ), intent ( in ) :: t0 !! time at beginning of time interval real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ) :: level_index !! defines which level to interpolate to logical , intent ( in ) :: F_INTERP !!  Flag, if true, then do interp on f not sol integer , optional , intent ( in ) :: flags !  Local variables class ( pf_level_t ), pointer :: c_lev_p !  Pointer to coarse level class ( pf_level_t ), pointer :: f_lev_p !  Pointer to fine level integer :: m , p , step real ( pfdp ), allocatable :: c_times (:) ! coarse level node times real ( pfdp ), allocatable :: f_times (:) ! fine level node times f_lev_p => pf % levels ( level_index ) ! fine level c_lev_p => pf % levels ( level_index - 1 ) ! coarse level call call_hooks ( pf , level_index , PF_PRE_INTERP_ALL ) call start_timer ( pf , TINTERPOLATE + level_index - 1 ) step = pf % state % step + 1 !> create workspaces if ( f_lev_p % interp_workspace_allocated . eqv . . false .) then call c_lev_p % ulevel % factory % create_array ( f_lev_p % c_delta , c_lev_p % nnodes , c_lev_p % index , c_lev_p % shape ) call f_lev_p % ulevel % factory % create_array ( f_lev_p % cf_delta , c_lev_p % nnodes , f_lev_p % index , f_lev_p % shape ) f_lev_p % interp_workspace_allocated = . true . end if !> set time at coarse and fine nodes allocate ( c_times ( c_lev_p % nnodes )) allocate ( f_times ( f_lev_p % nnodes )) c_times = t0 + dt * c_lev_p % nodes f_times = t0 + dt * f_lev_p % nodes do m = 1 , c_lev_p % nnodes call f_lev_p % c_delta ( m )% setval ( 0.0_pfdp , flags ) call f_lev_p % cf_delta ( m )% setval ( 0.0_pfdp , flags ) end do !>  interpolate coarse level correction in space only do m = 1 , c_lev_p % nnodes call f_lev_p % c_delta ( m )% copy ( c_lev_p % Q ( m ), flags ) call f_lev_p % c_delta ( m )% axpy ( - 1.0_pfdp , c_lev_p % pQ ( m ), flags ) call f_lev_p % ulevel % interpolate ( f_lev_p , c_lev_p , f_lev_p % cf_delta ( m ), f_lev_p % c_delta ( m ), c_times ( m ), flags ) end do !> interpolate corrections in time call pf_apply_mat ( f_lev_p % Q , 1.0_pfdp , f_lev_p % tmat , f_lev_p % cf_delta , . false ., flags ) !> either interpolate function values or recompute them if ( F_INTERP ) then !  Interpolating F do p = 1 , size ( c_lev_p % F ( 1 ,:)) do m = 1 , c_lev_p % nnodes call f_lev_p % c_delta ( m )% setval ( 0.0_pfdp , flags ) call f_lev_p % cf_delta ( m )% setval ( 0.0_pfdp , flags ) end do ! interpolate coarse corrections  in space do m = 1 , c_lev_p % nnodes call f_lev_p % c_delta ( m )% copy ( c_lev_p % F ( m , p ), flags ) call f_lev_p % c_delta ( m )% axpy ( - 1.0_pfdp , c_lev_p % pF ( m , p ), flags ) call f_lev_p % ulevel % interpolate ( f_lev_p , c_lev_p , f_lev_p % cf_delta ( m ), f_lev_p % c_delta ( m ), c_times ( m ), flags ) end do ! interpolate corrections  in time call pf_apply_mat ( f_lev_p % F (:, p ), 1.0_pfdp , f_lev_p % tmat , f_lev_p % cf_delta , . false ., flags ) end do !  Loop on npieces else ! recompute function values call f_lev_p % ulevel % sweeper % evaluate_all ( pf , level_index , f_times , flags = flags , step = step ) end if !  Feval !> destroy local data structures deallocate ( c_times , f_times ) call end_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call call_hooks ( pf , f_lev_p % index , PF_POST_INTERP_ALL ) end subroutine interpolate_time_space","tags":"","loc":"proc/interpolate_time_space.html","title":"interpolate_time_space – LibPFASST"},{"text":"public subroutine interpolate_q0(pf, f_lev_p, c_lev_p, flags) Subroutine to update the fine initial condition from coarse increment by spatial interpolation restrict fine initial data to coarse\n  get coarse level correction\n  interpolate correction in space\n update fine inital condition Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: f_lev_p fine level class( pf_level_t ), intent(inout) :: c_lev_p coarse level integer, intent(in), optional :: flags Contents Source Code interpolate_q0 Source Code subroutine interpolate_q0 ( pf , f_lev_p , c_lev_p , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: f_lev_p !!  fine level class ( pf_level_t ), intent ( inout ) :: c_lev_p !!  coarse level integer , optional , intent ( in ) :: flags !!  optional: specify component on which to operate !   here flags more or less is logical, if it is present we operate on component 1 !   of the ndarray-type call call_hooks ( pf , f_lev_p % index , PF_PRE_INTERP_Q0 ) call start_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call c_lev_p % q0_delta % setval ( 0.0_pfdp , flags ) call f_lev_p % q0_delta % setval ( 0.0_pfdp , flags ) !>  restrict fine initial data to coarse call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0_delta , pf % state % t0 , flags ) !>  get coarse level correction call c_lev_p % q0_delta % axpy ( - 1.0_pfdp , c_lev_p % q0 , flags ) !>  interpolate correction in space call f_lev_p % ulevel % interpolate ( f_lev_p , c_lev_p , f_lev_p % q0_delta , c_lev_p % q0_delta , pf % state % t0 , flags ) !> update fine inital condition call f_lev_p % q0 % axpy ( - 1.0_pfdp , f_lev_p % q0_delta , flags ) call end_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call call_hooks ( pf , f_lev_p % index , PF_POST_INTERP_Q0 ) end subroutine interpolate_q0","tags":"","loc":"proc/interpolate_q0.html","title":"interpolate_q0 – LibPFASST"},{"text":"public subroutine interpolate_qend(pf, f_lev_p, c_lev_p) Subroutine to update the fine terminal condition from coarse increment by spatial interpolation\n  used for adjoint solver restrict fine initial data to coarse\n  get coarse level correction interpolate correction in space update fine inital condition Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: f_lev_p fine level class( pf_level_t ), intent(inout) :: c_lev_p coarse level Contents Source Code interpolate_qend Source Code subroutine interpolate_qend ( pf , f_lev_p , c_lev_p ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: f_lev_p !!  fine level class ( pf_level_t ), intent ( inout ) :: c_lev_p !!  coarse level call call_hooks ( pf , f_lev_p % index , PF_PRE_INTERP_Q0 ) call start_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call c_lev_p % q0_delta % setval ( 0.0_pfdp ) call f_lev_p % q0_delta % setval ( 0.0_pfdp ) !>  restrict fine initial data to coarse call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % qend , c_lev_p % q0_delta , pf % state % t0 , flags = 2 ) !>  get coarse level correction call c_lev_p % q0_delta % axpy ( - 1.0_pfdp , c_lev_p % qend , flags = 2 ) !>  interpolate correction in space call f_lev_p % ulevel % interpolate ( f_lev_p , c_lev_p , f_lev_p % q0_delta , c_lev_p % q0_delta , pf % state % t0 , flags = 2 ) !> update fine inital condition call f_lev_p % qend % axpy ( - 1.0_pfdp , f_lev_p % q0_delta , flags = 2 ) call end_timer ( pf , TINTERPOLATE + f_lev_p % index - 1 ) call call_hooks ( pf , f_lev_p % index , PF_POST_INTERP_Q0 ) end subroutine interpolate_qend","tags":"","loc":"proc/interpolate_qend.html","title":"interpolate_qend – LibPFASST"},{"text":"public subroutine exp_initialize(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code exp_initialize Source Code subroutine exp_initialize ( this , pf , level_index ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index ! local variables integer :: i , nnodes real ( pfdp ), allocatable :: q (:) type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) nnodes = lev % nnodes allocate ( this % eta ( nnodes - 1 )) allocate ( this % nodes ( nnodes )) allocate ( q ( nnodes )) ! set nodes and substeps this % nodes = lev % sdcmats % qnodes this % eta = this % nodes ( 2 : nnodes ) - this % nodes ( 1 : nnodes - 1 ) ! substeps ! compute weights allocate ( this % w ( nnodes - 1 , nnodes , nnodes )) do i = 1 , nnodes - 1 q = this % nodes - this % nodes ( i ); call weights ( this , real ( 0.0 , pfdp ), q , nnodes - 1 , this % W ( i ,:,:)) end do ! set number of rhs components this % npieces = 1 ! initialize temporary storage objects call lev % ulevel % factory % create_single ( this % newF , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % b , nnodes + 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % f_old , nnodes , lev % index , lev % shape ) end subroutine exp_initialize","tags":"","loc":"proc/exp_initialize.html","title":"exp_initialize – LibPFASST"},{"text":"public subroutine exp_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Contents Source Code exp_sweep Source Code subroutine exp_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags ! local variables type ( pf_level_t ), pointer :: lev integer :: m , nnodes , j , k real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call start_timer ( pf , TLEVEL + lev % index - 1 ) ! error sweeps do k = 1 , nsweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! NOTE: ensure that lev%F has been properly initialized here do j = 1 , nnodes call this % f_old ( j )% copy ( lev % F ( j , 1 )) ! Save old f end do if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) ! compute F_j&#94;{[k+1]} end if t = t0 do j = 1 , nnodes - 1 t = t0 + dt * this % eta ( j ) ! form b vectors call LocalDerivsAtNode ( this , j , nnodes , this % f_old , this % b ) ! phi expansion for exponential picard integral call this % b ( 1 )% copy ( lev % Q ( j )) ! add term \\phi_0(tL) y_n call this % b ( 2 )% axpy ( real ( - 1.0 , pfdp ), this % f_old ( j )) ! add -\\phi_1(tL) F_j&#94;{[k]} call this % f_eval ( lev % Q ( j ), t , lev % index , lev % F ( j , 1 )) ! compute F_j&#94;{[k+1]} call this % b ( 2 )% axpy ( real ( 1.0 , pfdp ), lev % F ( j , 1 )) ! add \\phi_1(tL) F_j&#94;{[k+1]} ! compute phi products if ( this % use_phib ) then call this % phib ( this % eta ( j ), dt , this % b , lev % Q ( j + 1 )) else call this % swpPhib ( j , dt , this % b , lev % Q ( j + 1 )) end if !  Now we have to add in the tauQ if ( level_index < pf % state % finest_level ) then call lev % Q ( j + 1 )% axpy ( 1.0_pfdp , lev % tauQ ( j )) if ( j > 1 ) then ! The tau is not node to node, so subtract out call lev % Q ( j + 1 )% axpy ( - 1.0_pfdp , lev % tauQ ( j - 1 )) end if end if end do !  Substepping over nodes call this % f_eval ( lev % Q ( nnodes ), t0 + dt , lev % index , lev % F ( nnodes , 1 )) ! eval last nonlinear term call pf_residual ( pf , level_index , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  Sweeps end subroutine exp_sweep","tags":"","loc":"proc/exp_sweep.html","title":"exp_sweep – LibPFASST"},{"text":"public subroutine exp_integrate(this, pf, level_index, qSDC, fSDC, dt, fintsdc, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags Contents Source Code exp_integrate Source Code subroutine exp_integrate ( this , pf , level_index , qSDC , fSDC , dt , fintsdc , flags ) class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintsdc (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags ! local variables integer :: i , nnodes type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer nnodes = lev % nnodes do i = 1 , nnodes call this % f_old ( i )% copy ( fSDC ( i , 1 )) ! Save old f end do do i = 1 , nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} call LocalDerivsAtNode ( this , i , nnodes , this % f_old , this % b ) ! compute derivatives call this % b ( 1 )% copy ( qSDC ( i )) call fintsdc ( i )% setval ( 0.0_pfdp ) if ( this % use_phib ) then call this % phib ( this % eta ( i ), dt , this % b , fintsdc ( i )) else call this % swpPhib ( i , dt , this % b , fintsdc ( i )) end if call fintsdc ( i )% axpy ( - 1.0_pfdp , qSDC ( i )) if ( i > 1 ) then call fintsdc ( i )% axpy ( 1.0_pfdp , fintsdc ( i - 1 )) end if end do end subroutine exp_integrate","tags":"","loc":"proc/exp_integrate.html","title":"exp_integrate – LibPFASST"},{"text":"public subroutine exp_residual(this, pf, level_index, dt, flags) Compute the integral of F from t_n to t_m at each node add tau if it exists\n subtract out the solution value Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code exp_residual Source Code subroutine exp_residual ( this , pf , level_index , dt , flags ) class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: dt integer , intent ( in ), optional :: flags integer :: m type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( pf , level_index , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( level_index < pf % state % finest_level ) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if !> subtract out the solution value do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) end do end subroutine exp_residual","tags":"","loc":"proc/exp_residual.html","title":"exp_residual – LibPFASST"},{"text":"public subroutine exp_spreadq0(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code exp_spreadq0 Source Code subroutine exp_spreadq0 ( this , pf , level_index , t0 , flags , step ) class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call pf_generic_spreadq0 ( this , pf , level_index , t0 ) end subroutine exp_spreadq0","tags":"","loc":"proc/exp_spreadq0.html","title":"exp_spreadq0 – LibPFASST"},{"text":"public subroutine exp_evaluate(this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code exp_evaluate Source Code subroutine exp_evaluate ( this , pf , level_index , t , m , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine exp_evaluate","tags":"","loc":"proc/exp_evaluate.html","title":"exp_evaluate – LibPFASST"},{"text":"public subroutine exp_evaluate_all(this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code exp_evaluate_all Source Code subroutine exp_evaluate_all ( this , pf , level_index , t , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer call pf_generic_evaluate_all ( this , pf , level_index , t ) end subroutine exp_evaluate_all","tags":"","loc":"proc/exp_evaluate_all.html","title":"exp_evaluate_all – LibPFASST"},{"text":"public subroutine exp_destroy(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Contents Source Code exp_destroy Source Code subroutine exp_destroy ( this , pf , level_index ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index type ( pf_level_t ), pointer :: lev lev => pf % levels ( level_index ) !  Assign level pointer deallocate ( this % w ) deallocate ( this % eta ) deallocate ( this % newF ) call lev % ulevel % factory % destroy_array ( this % b ) call lev % ulevel % factory % destroy_array ( this % f_old ) end subroutine exp_destroy","tags":"","loc":"proc/exp_destroy.html","title":"exp_destroy – LibPFASST"},{"text":"public subroutine LocalDerivsAtNode(this, i, nnodes, N_eval, N_deriv) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: nnodes class( pf_encap_t ), intent(in) :: N_eval (:) class( pf_encap_t ), intent(inout) :: N_deriv (:) Contents Source Code LocalDerivsAtNode Source Code subroutine LocalDerivsAtNode ( this , i , nnodes , N_eval , N_deriv ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: i integer , intent ( in ) :: nnodes class ( pf_encap_t ), intent ( in ) :: N_eval (:) class ( pf_encap_t ), intent ( inout ) :: N_deriv (:) ! local variables integer :: j , k ! form nonlinear derivative vectors b do j = 1 , nnodes ! loop over derivatives j = 1 ... n call N_deriv ( j + 1 )% setval ( real ( 0.0 , pfdp )) do k = 1 , nnodes ! look over nodes k = 1 ... n call N_deriv ( j + 1 )% axpy ( this % w ( i , k , j ), N_eval ( k )) end do end do end subroutine LocalDerivsAtNode","tags":"","loc":"proc/localderivsatnode.html","title":"LocalDerivsAtNode – LibPFASST"},{"text":"public subroutine weights(this, z, x, m, W) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z real(kind=pfdp), intent(inout) :: x (:) integer, intent(in) :: m real(kind=pfdp), intent(out) :: W (m+1,m+1) Contents Source Code weights Source Code subroutine weights ( this , z , x , m , W ) ! Arguments class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z real ( pfdp ), intent ( inout ) :: x (:) integer , intent ( in ) :: m real ( pfdp ), intent ( out ) :: W ( m + 1 , m + 1 ) ! Variable Declarations real ( pfdp ) :: c1 , c2 , c3 , c4 , c5 integer :: ii , i , j , k , n , mn !        do ii = 1, m !        x = this%nodes - this%nodes(ii); c1 = 1.0_pfdp c4 = x ( 1 ) - z W = 0.0_pfdp W ( 1 , 1 ) = 1.0_pfdp n = size ( x ) do i = 2 , n mn = min ( i , m + 1 ) c2 = 1.0_pfdp c5 = c4 c4 = x ( i ) - z do j = 1 , i - 1 c3 = x ( i ) - x ( j ) c2 = c2 * c3 ; if ( j == i - 1 ) then do k = mn , 2 , - 1 W ( i , k ) = c1 * ( real ( k - 1 , pfdp ) * W ( i - 1 , k - 1 ) - c5 * W ( i - 1 , k )) / c2 ; enddo W ( i , 1 ) = - c1 * c5 * W ( i - 1 , 1 ) / c2 ; endif do k = mn , 2 , - 1 W ( j , k ) = ( c4 * W ( j , k ) - real ( k - 1 , pfdp ) * W ( j , k - 1 )) / c3 ; enddo W ( j , 1 ) = c4 * W ( j , 1 ) / c3 ; enddo c1 = c2 ; enddo !        end do end subroutine weights","tags":"","loc":"proc/weights.html","title":"weights – LibPFASST"},{"text":"interface public subroutine pf_phib(this, t, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_phib.html","title":"pf_phib – LibPFASST"},{"text":"interface public subroutine pf_swpPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_swpphib.html","title":"pf_swpPhib – LibPFASST"},{"text":"interface public subroutine pf_resPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_resphib.html","title":"pf_resPhib – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, n) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n","tags":"","loc":"interface/pf_f_eval_p~10.html","title":"pf_f_eval_p – LibPFASST"},{"text":"public subroutine pf_add_hook(pf, level_ind, hook, proc) Subroutine to add a procedure to the hook on the given level Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: level_ind which pfasst level to add hook integer, intent(in) :: hook which hook to add procedure( pf_hook_p ) :: proc precudre to call from hook Contents Source Code pf_add_hook Source Code subroutine pf_add_hook ( pf , level_ind , hook , proc ) type ( pf_pfasst_t ), intent ( inout ) :: pf !! main pfasst structure integer , intent ( in ) :: level_ind !! which pfasst level to add hook integer , intent ( in ) :: hook !! which hook to add procedure ( pf_hook_p ) :: proc !! precudre to call from hook integer :: l ! if ( level_ind == - 1 ) then ! Do to all levels do l = 1 , pf % nlevels pf % nhooks ( l , hook ) = pf % nhooks ( l , hook ) + 1 pf % hooks ( l , hook , pf % nhooks ( l , hook ))% proc => proc end do else ! Do to just level level_ind pf % nhooks ( level_ind , hook ) = pf % nhooks ( level_ind , hook ) + 1 pf % hooks ( level_ind , hook , pf % nhooks ( level_ind , hook ))% proc => proc end if end subroutine pf_add_hook","tags":"","loc":"proc/pf_add_hook.html","title":"pf_add_hook – LibPFASST"},{"text":"public subroutine call_hooks(pf, level_ind, hook) Uses pf_mod_timer Subroutine to call hooks associated with the hook and level Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf main pfasst structure integer, intent(in) :: level_ind which pfasst level to call hook integer, intent(in) :: hook which hook to call Contents Source Code call_hooks Source Code subroutine call_hooks ( pf , level_ind , hook ) use pf_mod_timer type ( pf_pfasst_t ), intent ( inout ), target :: pf !! main pfasst structure integer , intent ( in ) :: level_ind !! which pfasst level to call hook integer , intent ( in ) :: hook !! which hook to call integer :: i !!  hook loop index integer :: l !!  level loop index call start_timer ( pf , THOOKS ) pf % state % hook = hook if ( level_ind == - 1 ) then ! Do to all levels do l = 1 , pf % nlevels do i = 1 , pf % nhooks ( l , hook ) call pf % hooks ( l , hook , i )% proc ( pf , l ) end do end do else ! Do to just level level_ind do i = 1 , pf % nhooks ( level_ind , hook ) call pf % hooks ( level_ind , hook , i )% proc ( pf , level_ind ) end do end if call end_timer ( pf , THOOKS ) end subroutine call_hooks","tags":"","loc":"proc/call_hooks.html","title":"call_hooks – LibPFASST"},{"text":"public subroutine pf_logger_hook(pf, level_index) Subroutine defining log hook Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index Contents Source Code pf_logger_hook Source Code subroutine pf_logger_hook ( pf , level_index ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index print '(\"PF:: trank: \",i4,\", step: \",i6,\", iter: \",i3,\", level: \",i2,\" location: \",a)' , & pf % rank , pf % state % step , pf % state % iter , level_index , hook_names ( pf % state % hook ) end subroutine pf_logger_hook","tags":"","loc":"proc/pf_logger_hook.html","title":"pf_logger_hook – LibPFASST"},{"text":"public subroutine pf_logger_attach(pf) Subroutine to add log hook Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Contents Source Code pf_logger_attach Source Code subroutine pf_logger_attach ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: l , h do h = PF_HOOK_LOG_ONE , PF_HOOK_LOG_ALL - 1 call pf_add_hook ( pf , 1 , h , pf_logger_hook ) end do do l = 1 , pf % nlevels do h = PF_HOOK_LOG_ALL , PF_HOOK_LOG_LAST call pf_add_hook ( pf , l , h , pf_logger_hook ) end do end do end subroutine pf_logger_attach","tags":"","loc":"proc/pf_logger_attach.html","title":"pf_logger_attach – LibPFASST"},{"text":"public subroutine sweep_coupled_implicit_terms(this, pf, lev, t0, dt) Uses pf_mod_timer Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Contents Source Code sweep_coupled_implicit_terms Source Code subroutine sweep_coupled_implicit_terms ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhsA , rhsB , QA , QB class ( pf_encap_t ), allocatable :: S2 (:), S3 (:) call start_timer ( pf , TLEVEL + lev % index - 1 ) call lev % ulevel % factory % create_array ( S2 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( S3 , lev % nnodes - 1 , lev % index , lev % shape ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) call S2 ( m )% setval ( 0.0d0 ) call S3 ( m )% setval ( 0.0d0 ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( 1.0_pfdp * dt * lev % qmat ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( 1.0_pfdp * dt * lev % qmat ( m , n ), lev % F ( n , 3 )) call S2 ( m )% axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 2 )) call S3 ( m )% axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tauQ )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f1eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) call this % f2eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 )) call this % f3eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 )) call lev % ulevel % factory % create_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QB , lev % index , lev % shape ) call QA % setval ( 0.0_pfdp ) call QB % setval ( 0.0_pfdp ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhsA % copy ( lev % Q ( 1 )) ! First compute the explicit part of the right-hand side do n = 1 , m call rhsA % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) end do call rhsA % axpy ( 1.0_pfdp , lev % S ( m )) ! Save the right-hand side with only the explicit contribution call rhsB % copy ( rhsA ) ! Add the first implicit part to the right-hand side and solve for the first asynchronous update do n = 1 , m call rhsA % axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do call rhsA % axpy ( - 1.0_pfdp , S2 ( m )) call this % f2comp ( QA , t , 2.0_pfdp * dt * this % QtilI ( m , m + 1 ), rhsA , lev % index , lev % F ( m + 1 , 2 )) ! Add the second implicit part to the right-hand side and solve for the second asynchronous update do n = 1 , m call rhsB % axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do call rhsB % axpy ( - 1.0_pfdp , S3 ( m )) call this % f3comp ( QB , t , 2.0_pfdp * dt * this % QtilI ( m , m + 1 ), rhsB , lev % index , lev % F ( m + 1 , 3 )) ! Now we average the two asynchronous updates call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QA ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QB ) ! Evaluate the three right-hand sides with the updated variables call this % f1eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 )) call this % f2eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 )) call this % f3eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 3 )) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) call lev % ulevel % factory % destroy_array ( S2 ) call lev % ulevel % factory % destroy_array ( S3 ) call lev % ulevel % factory % destroy_single ( rhsA ) call lev % ulevel % factory % destroy_single ( rhsB ) call lev % ulevel % factory % destroy_single ( QA ) call lev % ulevel % factory % destroy_single ( QB ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine sweep_coupled_implicit_terms","tags":"","loc":"proc/sweep_coupled_implicit_terms.html","title":"sweep_coupled_implicit_terms – LibPFASST"},{"text":"public subroutine sweep_decoupled_implicit_terms(this, pf, lev, t0, dt) Uses pf_mod_timer Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Contents Source Code sweep_decoupled_implicit_terms Source Code subroutine sweep_decoupled_implicit_terms ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev ! integer                        :: m, n ! real(pfdp)                     :: t ! real(pfdp)                     :: dtsdc(1:lev%nnodes-1) ! class(pf_encap_t), allocatable :: rhsA, rhsB, QA, QB ! class(pf_encap_t), allocatable :: S2(:), S3(:) ! call start_timer(pf, TLEVEL+lev%index-1) ! call lev%ulevel%factory%create_array(S2,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%create_array(S3,lev%nnodes-1,lev%index,lev%shape) ! ! compute integrals and add fas correction ! do m = 1, lev%nnodes-1 !    call lev%S(m)%setval(0.0_pfdp) !    call S2(m)%setval(0.0d0) !    call S3(m)%setval(0.0d0) !    do n = 1, lev%nnodes !       call lev%S(m)%axpy(dt*this%QdiffE(m,n),       lev%F(n,1)) !       call S2(m)%axpy( 2.0_pfdp*dt*lev%qmat(m,n),   lev%F(n,2)) !       call S3(m)%axpy( 2.0_pfdp*dt*lev%qmat(m,n),   lev%F(n,3)) !       call S2(m)%axpy(-2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,2)) !       call S3(m)%axpy(-2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,3)) !    end do !    if (allocated(lev%tauQ)) then !       call lev%S(m)%axpy(1.0_pfdp, lev%tauQ(m)) !    end if ! end do ! ! do the time-stepping ! call lev%Q(1)%unpack(lev%q0) ! call this%f1eval(lev%Q(1), t0, lev%index, lev%F(1,1)) ! call this%f2eval(lev%Q(1), t0, lev%index, lev%F(1,2)) ! call this%f3eval(lev%Q(1), t0, lev%index, lev%F(1,3)) ! call lev%ulevel%factory%create_single(rhsA, lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(rhsB, lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(QA,   lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(QB,   lev%index,  lev%shape) ! call QA%setval(0.0_pfdp) ! call QB%setval(0.0_pfdp) ! t = t0 ! dtsdc = dt * (lev%nodes(2:lev%nnodes) - lev%nodes(1:lev%nnodes-1)) ! do m = 1, lev%nnodes-1 !    t = t + dtsdc(m) !    call rhsA%copy(lev%Q(1)) !    ! First compute the explicit part of the right-hand side !    do n = 1, m !       call rhsA%axpy(dt*this%QtilE(m,n), lev%F(n,1)) !    end do !    call rhsA%axpy(1.0_pfdp, lev%S(m)) !    ! Save the right-hand side with only the explicit contribution !    call rhsB%copy(rhsA) !    ! Add the first implicit part to the right-hand side and solve for the first asynchronous update !    do n = 1, m !       call rhsA%axpy(2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,2)) !    end do !    call rhsA%axpy(1.0_pfdp, S2(m)) !    call this%f2comp(QA, t, 2.0_pfdp*dt*this%QtilI(m,m+1), rhsA, lev%index, lev%F(m+1,2)) !    ! Add the second implicit part to the right-hand side and solve for the second asynchronous update !    do n = 1, m !       call rhsB%axpy(2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,3)) !    end do !    call rhsB%axpy(1.0_pfdp, S3(m)) !    call this%f3comp(QB, t, 2.0_pfdp*dt*this%QtilI(m,m+1), rhsB, lev%index, lev%F(m+1,3)) !    ! Now we average the two asynchronous updates !    call lev%Q(m+1)%setval(0.0_pfdp) !    call lev%Q(m+1)%axpy(0.5_pfdp, QA) !    call lev%Q(m+1)%axpy(0.5_pfdp, QB) !    ! Evaluate the three right-hand sides with the updated variables !    call this%f1eval(lev%Q(m+1), t, lev%index, lev%F(m+1,1)) !    call this%f2eval(lev%Q(m+1), t, lev%index, lev%F(m+1,2)) !    call this%f3eval(lev%Q(m+1), t, lev%index, lev%F(m+1,3)) ! end do ! call lev%qend%copy(lev%Q(lev%nnodes)) ! call lev%ulevel%factory%destroy_array(S2,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%destroy_array(S3,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%destroy_single(rhsA, lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(rhsB, lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(QA,   lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(QB,   lev%index,   lev%shape) ! call end_timer(pf, TLEVEL+lev%index-1) end subroutine sweep_decoupled_implicit_terms","tags":"","loc":"proc/sweep_decoupled_implicit_terms.html","title":"sweep_decoupled_implicit_terms – LibPFASST"},{"text":"public subroutine amisdcQ_sweep(this, pf, lev, t0, dt) Uses pf_mod_timer Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Contents Source Code amisdcQ_sweep Source Code subroutine amisdcQ_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev call sweep_coupled_implicit_terms ( this , pf , lev , t0 , dt ) end subroutine amisdcQ_sweep","tags":"","loc":"proc/amisdcq_sweep.html","title":"amisdcQ_sweep – LibPFASST"},{"text":"public subroutine amisdcQ_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev Contents Source Code amisdcQ_initialize Source Code subroutine amisdcQ_initialize ( this , lev ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , n , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) !  S-BE this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq_ ) then ! Get the LU call myLUq ( lev % qmat , lev % LUmat , lev % nnodes , 1 ) this % QtilI = lev % LUmat else do m = 1 , nnodes - 1 do n = 1 , m this % QtilI ( m , n + 1 ) = dsdc ( n ) end do end do end if ! Explicit matrix do m = 1 , nnodes - 1 do n = 1 , m this % QtilE ( m , n ) = dsdc ( n ) end do end do this % QdiffE = lev % qmat - this % QtilE this % QdiffI = lev % qmat - this % QtilI end subroutine amisdcQ_initialize","tags":"","loc":"proc/amisdcq_initialize.html","title":"amisdcQ_initialize – LibPFASST"},{"text":"public subroutine amisdcQ_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev Contents Source Code amisdcQ_destroy Source Code subroutine amisdcQ_destroy ( this , lev ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) end subroutine amisdcQ_destroy","tags":"","loc":"proc/amisdcq_destroy.html","title":"amisdcQ_destroy – LibPFASST"},{"text":"public subroutine amisdcQ_integrate(this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(in) :: lev class(pf_encap_t), intent(in) :: qSDC (:) class(pf_encap_t), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class(pf_encap_t), intent(inout) :: fintSDC (:) Contents Source Code amisdcQ_integrate Source Code subroutine amisdcQ_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % qmat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine amisdcQ_integrate","tags":"","loc":"proc/amisdcq_integrate.html","title":"amisdcQ_integrate – LibPFASST"},{"text":"public function not_proper(flags, node) Function to decide if the restriction of the nodes is pointwise, e.g. coarse nodes are every other fine node Arguments Type Intent Optional Attributes Name integer, intent(in) :: flags (:) integer, intent(in) :: node Return Value logical Contents Source Code not_proper Source Code logical function not_proper ( flags , node ) integer , intent ( in ) :: flags (:) integer , intent ( in ) :: node not_proper = . not . btest ( flags ( node ), 0 ) end function not_proper","tags":"","loc":"proc/not_proper.html","title":"not_proper – LibPFASST"},{"text":"public function poly_eval(p, n, x) result(v) Polynomial manipulation routines. A polynomial p p(x) = a_n x&#94;n + ... + a_2 x&#94;2 + a_1 x + a_0 is stored as a Fortran array p(0:n) according to p = [ a_0, a_1, ..., a_n ]. Function to evaluate real polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n real(kind=pfqp), intent(in) :: x Return Value real(kind=pfqp) Contents None","tags":"","loc":"proc/poly_eval.html","title":"poly_eval – LibPFASST"},{"text":"public function poly_eval_complex(p, n, x) result(v) Function to evaluate complex polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n complex(kind=pfqp), intent(in) :: x Return Value complex(kind=pfqp) Contents None","tags":"","loc":"proc/poly_eval_complex.html","title":"poly_eval_complex – LibPFASST"},{"text":"public subroutine pf_init_sdcmats(pf, SDCmats, nnodes, nflags) Uses pf_mod_utils Initialize the sdcmats type with the correct nodes and quadrature matrices\n Decide what the base integration type is Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf PFASST structure type( pf_sdcmats_t ), intent(inout) :: SDCmats integer, intent(in) :: nnodes integer, intent(inout) :: nflags (nnodes) Contents Source Code pf_init_sdcmats Source Code subroutine pf_init_sdcmats ( pf , SDCmats , nnodes , nflags ) use pf_mod_utils type ( pf_pfasst_t ), intent ( in ) :: pf !!  PFASST structure type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats integer , intent ( in ) :: nnodes ! Number of ndoes integer , intent ( inout ) :: nflags ( nnodes ) integer :: ierr integer :: nnodes0 !  Copy some info SDCmats % nnodes = nnodes SDCmats % qtype = pf % qtype SDCmats % use_proper_nodes = pf % use_proper_nodes SDCmats % use_composite_nodes = pf % use_composite_nodes SDCmats % use_no_left_q = pf % use_no_left_q !> Decide what the base integration type is if ( SDCmats % use_composite_nodes ) then nnodes0 = pf % levels ( 1 )% nnodes !  Will use the coarsest quadrature rule in composite else nnodes0 = pf % levels ( pf % nlevels )% nnodes ! Will use the end if !  Allocate nodes and collocation matrices allocate ( SDCmats % qnodes ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , & __ LINE__ , \"allocate error qnodes\" ) allocate ( SDCmats % Qmat ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error Qmat\" ) allocate ( SDCmats % Smat ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error Smat\" ) !  Make the nodes and collocation matrices call pf_quadrature ( SDCmats % qtype , nnodes , nnodes0 , & SDCmats % qnodes , nflags , SDCmats % Smat , SDCmats % Qmat , & SDCmats % use_proper_nodes , SDCmats % use_composite_nodes , SDCmats % use_no_left_q ) !  Make the substepping matrices call pf_make_matrices ( SDCmats ) end subroutine pf_init_sdcmats","tags":"","loc":"proc/pf_init_sdcmats.html","title":"pf_init_sdcmats – LibPFASST"},{"text":"public subroutine pf_destroy_sdcmats(SDCmats) Destroy the sdcmats structure Arguments Type Intent Optional Attributes Name type( pf_sdcmats_t ), intent(inout) :: SDCmats Contents Source Code pf_destroy_sdcmats Source Code subroutine pf_destroy_sdcmats ( SDCmats ) type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats deallocate ( SDCmats % Qmat ) deallocate ( SDCmats % QmatFE ) deallocate ( SDCmats % QmatBE ) deallocate ( SDCmats % QmatTrap ) deallocate ( SDCmats % QmatVer ) deallocate ( SDCmats % QmatLU ) deallocate ( SDCmats % Smat ) deallocate ( SDCmats % qnodes ) end subroutine pf_destroy_sdcmats","tags":"","loc":"proc/pf_destroy_sdcmats.html","title":"pf_destroy_sdcmats – LibPFASST"},{"text":"public subroutine myLUq(Q, QLU, Nnodes, fillq) Routine to compute the LU decomposition of spectral integration matrix Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: Q (Nnodes-1,Nnodes) real(kind=pfdp), intent(inout) :: QLU (Nnodes-1,Nnodes) integer, intent(in) :: Nnodes integer, intent(in) :: fillq Contents Source Code myLUq Source Code subroutine myLUq ( Q , QLU , Nnodes , fillq ) integer , intent ( in ) :: Nnodes real ( pfdp ), intent ( in ) :: Q ( Nnodes - 1 , Nnodes ) real ( pfdp ), intent ( inout ) :: QLU ( Nnodes - 1 , Nnodes ) integer , intent ( in ) :: fillq ! Return the QLU=U&#94;T where U is the LU decomposition of Q without pivoting ! if fillq is positive, then the first row of QLU is filled to make ! the matrix consistent integer :: i , j , N real ( pfdp ) :: c real ( pfdp ) :: U ( Nnodes - 1 , Nnodes - 1 ) real ( pfdp ) :: L ( Nnodes - 1 , Nnodes - 1 ) real ( pfdp ) :: LUerror L = 0.0_pfdp U = 0.0_pfdp N = Nnodes - 1 U = transpose ( Q ( 1 : Nnodes - 1 , 2 : Nnodes )) do i = 1 , N if ( abs ( U ( i , i )) . gt . 1.0e-15_pfdp ) then do j = i + 1 , N c = U ( j , i ) / U ( i , i ) U ( j , i : N ) = U ( j , i : N ) - c * U ( i , i : N ) L ( j , i ) = c end do end if L ( i , i ) = 1.0_pfdp end do !  Check LUerror = maxval ( abs ( matmul ( L , U ) - transpose ( Q ( 1 : Nnodes - 1 , 2 : Nnodes )))) if ( LUerror . gt . 1e-14 ) then call pf_stop ( __ FILE__ , __ LINE__ , 'error in LU too high' ) end if QLU = 0.0_pfdp QLU ( 1 : Nnodes - 1 , 2 : Nnodes ) = transpose ( U ) !  Now scale the columns of U to match the sum of A if ( fillq . eq . 1 ) then do j = 1 , Nnodes - 1 QLU ( j , 1 ) = sum ( Q ( j , 1 : Nnodes )) - sum ( U ( j , 1 : Nnodes - 1 )) end do end if end subroutine myLUq","tags":"","loc":"proc/myluq.html","title":"myLUq – LibPFASST"},{"text":"public subroutine pf_quadrature(qtype, nnodes, nnodes0, nodes, nflags, Smat, Qmat, proper, composite, no_left) Subroutine to create quadrature nodes and matrices Arguments Type Intent Optional Attributes Name integer, intent(in) :: qtype integer, intent(in) :: nnodes integer, intent(in) :: nnodes0 real(kind=pfdp), intent(out) :: nodes (nnodes) integer, intent(out) :: nflags (nnodes) real(kind=pfdp), intent(out) :: Smat (nnodes-1,nnodes) real(kind=pfdp), intent(out) :: Qmat (nnodes-1,nnodes) logical, intent(in) :: proper logical, intent(in) :: composite logical, intent(in) :: no_left Contents Source Code pf_quadrature Source Code subroutine pf_quadrature ( qtype , nnodes , nnodes0 , nodes , nflags , Smat , Qmat , proper , composite , no_left ) integer , intent ( in ) :: qtype ! Type of nodes integer , intent ( in ) :: nnodes ! Number of nodes on this level integer , intent ( in ) :: nnodes0 ! Number of node on base level (either finest or coarsest) real ( pfdp ), intent ( out ) :: nodes ( nnodes ) !  The nodes real ( pfdp ), intent ( out ) :: Smat ( nnodes - 1 , nnodes ) !  node to node integration matrix real ( pfdp ), intent ( out ) :: Qmat ( nnodes - 1 , nnodes ) !  O to node collocation matrix integer , intent ( out ) :: nflags ( nnodes ) !  Flags logical , intent ( in ) :: composite !  Use composite nodes logical , intent ( in ) :: proper !  Use proper nodes instead of node restriction logical , intent ( in ) :: no_left !  Don't use left hand end point real ( pfdp ) :: dt !  The size of the composite base rule real ( pfqp ) :: qnodes0 ( nnodes0 ) ! quad precision base nodes real ( pfqp ) :: qnodes ( nnodes ) ! quad precision nodes real ( pfdp ) :: Qmat0 ( nnodes0 - 1 , nnodes0 ), Smat0 ( nnodes0 - 1 , nnodes0 ), qcomp0 ( nnodes0 - 1 , nnodes0 ) integer :: flags0 ( nnodes0 ) integer :: i , j , ri , rj , refine , m Qmat = 0 Smat = 0 flags0 = 0 nflags = 0 if ( composite ) then ! nodes are given by repeating the coarsest set of nodes.  note ! that in this case nnodes0 corresponds to the coarsest number ! of nodes. refine = ( nnodes - 1 ) / ( nnodes0 - 1 ) call sdc_qnodes ( qnodes0 , flags0 , qtype , nnodes0 ) !  Make coarsest level nodes call sdc_qmats ( Qmat0 , Smat0 , qnodes0 , qnodes0 , flags0 , nnodes0 , nnodes0 ) !  Make coarsest level Qmat !  This block matrix will be used to fill in composite Qmat do m = 1 , nnodes0 - 1 qcomp0 ( m ,:) = Qmat0 ( nnodes0 - 1 ,:) !  load each row with the integral over the whole composite step end do !  Build big block matrix dt = 1.0_pfdp / refine do i = 1 , refine ri = ( i - 1 ) * ( nnodes0 - 1 ) + 1 !  beginning of ith composite rule qnodes ( ri : ri + nnodes0 - 1 ) = dt * (( i - 1 ) + qnodes0 ) !  Assigns endpoints of composites twice, but no biggie Smat ( ri : ri + nnodes0 - 2 , ri : ri + nnodes0 - 1 ) = dt * Smat0 ! Make block diagonal Smat Qmat ( ri : ri + nnodes0 - 2 , ri : ri + nnodes0 - 1 ) = dt * Qmat0 ! Make block diagonal Qmat do j = 1 , i - 1 !   column blocks to left of diag rj = ( j - 1 ) * ( nnodes0 - 1 ) + 1 Qmat ( ri : ri + nnodes0 - 2 , rj : rj + nnodes0 - 1 ) = Qmat ( ri : ri + nnodes0 - 2 , rj : rj + nnodes0 - 1 ) + dt * qcomp0 end do end do else if ( proper ) then ! nodes are given by proper quadrature rules call sdc_qnodes ( qnodes , nflags , qtype , nnodes ) call sdc_Qmats ( Qmat , Smat , qnodes , qnodes , nflags , nnodes , nnodes ) else ! nodes are given by refining the finest set of nodes.  note ! that in this case nnodes0 corresponds to the finest number of ! nodes. refine = ( nnodes0 - 1 ) / ( nnodes - 1 ) call sdc_qnodes ( qnodes0 , flags0 , qtype , nnodes0 ) !  Make finest nodes qnodes = qnodes0 ( :: refine ) nflags = flags0 ( :: refine ) if ( no_left ) nflags ( 1 ) = 0 call sdc_Qmats ( Qmat , Smat , qnodes , qnodes , nflags , nnodes , nnodes ) end if nodes = real ( qnodes , pfdp ) if ( all ( nodes == 0.0d0 )) then call pf_stop ( __ FILE__ , __ LINE__ ,& 'ERROR: pf_quadrature: invalid SDC nnodes.' ) end if end subroutine pf_quadrature","tags":"","loc":"proc/pf_quadrature.html","title":"pf_quadrature – LibPFASST"},{"text":"public subroutine pf_make_matrices(SDCmats) Arguments Type Intent Optional Attributes Name type( pf_sdcmats_t ), intent(inout) :: SDCmats Contents Source Code pf_make_matrices Source Code subroutine pf_make_matrices ( SDCmats ) type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats integer :: nnodes integer :: ierr , m , n nnodes = SDCmats % nnodes allocate ( SDCmats % QmatFE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatFE\" ) allocate ( SDCmats % QmatBE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatBE\" ) allocate ( SDCmats % QmatTrap ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatBE\" ) allocate ( SDCmats % QmatVer ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatBE\" ) allocate ( SDCmats % QmatLU ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error QmatLU\" ) !  Make implicit Euler matrices SDCmats % QmatBE = 0.0_pfdp do m = 1 , nnodes - 1 do n = 1 , m SDCmats % QmatBE ( m , n + 1 ) = SDCmats % qnodes ( n + 1 ) - SDCmats % qnodes ( n ) end do end do ! Make explicit matrix SDCmats % QmatFE = 0.0_pfdp do m = 1 , nnodes - 1 do n = 1 , m SDCmats % QmatFE ( m , n ) = SDCmats % qnodes ( n + 1 ) - SDCmats % qnodes ( n ) end do end do !  Trapezoid matrix SDCmats % QmatTrap = 0.5_pfdp * ( SDCmats % QmatFE + SDCmats % QmatBE ) !  Get the LU call myLUq ( SDCmats % Qmat , SDCmats % QmatLU , nnodes , 0 ) end subroutine pf_make_matrices","tags":"","loc":"proc/pf_make_matrices.html","title":"pf_make_matrices – LibPFASST"},{"text":"public subroutine sdc_qnodes(qnodes, flags, qtype, nnodes) Subroutine to compute high precision quadrature nodes. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: qnodes (nnodes) The computed quadrature nodes integer, intent(out) :: flags (nnodes) integer, intent(in), value :: qtype Type of nodes (see pf_dtype) integer, intent(in), value :: nnodes Number of nodes Contents Source Code sdc_qnodes Source Code subroutine sdc_qnodes ( qnodes , flags , qtype , nnodes ) integer , intent ( in ), value :: nnodes !!  Number of nodes integer , intent ( in ), value :: qtype !!  Type of nodes (see pf_dtype) real ( pfqp ), intent ( out ) :: qnodes ( nnodes ) !!  The computed quadrature nodes integer , intent ( out ) :: flags ( nnodes ) !! integer :: j , degree real ( pfqp ), allocatable :: roots (:) real ( pfqp ), allocatable :: coeffs (:), coeffs2 (:) real ( pfqp ), parameter :: pi = 3.141592653589793115997963468544185161590576171875_pfdp flags = 0 select case ( qtype ) case ( SDC_GAUSS_LEGENDRE ) degree = nnodes - 2 allocate ( roots ( degree )) allocate ( coeffs ( degree + 1 )) call poly_legendre ( coeffs , degree ) call poly_roots ( roots , coeffs , degree ) qnodes ( 1 ) = 0.0_pfqp qnodes ( 2 : nnodes - 1 ) = 0.5_pfqp * ( 1.0_pfqp + roots ) qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs ) deallocate ( roots ) do j = 2 , nnodes - 1 flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_GAUSS_LOBATTO ) degree = nnodes - 1 allocate ( roots ( degree - 1 )) allocate ( coeffs ( degree + 1 )) call poly_legendre ( coeffs , degree ) call poly_diff ( coeffs , degree ) call poly_roots ( roots , coeffs (: degree ), degree - 1 ) qnodes ( 1 ) = 0.0_pfqp qnodes ( 2 : nnodes - 1 ) = 0.5_pfqp * ( 1.0_pfqp + roots ) qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs ) deallocate ( roots ) do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_GAUSS_RADAU ) degree = nnodes - 1 allocate ( roots ( degree )) allocate ( coeffs ( degree + 1 )) allocate ( coeffs2 ( degree )) call poly_legendre ( coeffs , degree ) call poly_legendre ( coeffs2 , degree - 1 ) coeffs (: degree ) = coeffs (: degree ) + coeffs2 call poly_roots ( roots , coeffs , degree ) qnodes ( 1 ) = 0.0_pfqp do j = 2 , nnodes - 1 qnodes ( j ) = 0.5_pfqp * ( 1.0_pfqp - roots ( nnodes + 1 - j )) end do qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs2 ) deallocate ( coeffs ) deallocate ( roots ) do j = 2 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_CLENSHAW_CURTIS ) do j = 0 , nnodes - 1 qnodes ( j + 1 ) = 0.5_pfqp * ( 1.0_pfqp - cos ( j * pi / ( nnodes - 1 ))) end do do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_UNIFORM ) do j = 0 , nnodes - 1 qnodes ( j + 1 ) = j * ( 1.0_pfqp / ( nnodes - 1 )) end do do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_CHEBYSHEV ) qnodes ( 1 ) = 0.0_pfqp do j = 1 , nnodes - 2 qnodes ( j + 1 ) = 0.5_pfqp * ( 1.0_pfqp - cos (( j - 1 / 2 ) * pi / ( nnodes - 2 ))) end do qnodes ( nnodes ) = 0.0_pfqp do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , qtype ) end select end subroutine sdc_qnodes","tags":"","loc":"proc/sdc_qnodes.html","title":"sdc_qnodes – LibPFASST"},{"text":"public subroutine sdc_qmats(Qmat, Smat, dst, src, flags, ndst, nsrc) Subroutine to compute the quadrature matrices Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(out) :: Qmat (ndst-1,nsrc) O to dst quadrature weights real(kind=pfdp), intent(out) :: Smat (ndst-1,nsrc) dst(m) to dst(m+1) quadrature weights real(kind=pfqp), intent(in) :: dst (ndst) Destination points real(kind=pfqp), intent(in) :: src (nsrc) Source points integer, intent(in) :: flags (nsrc) integer, intent(in), value :: ndst Number of destination points integer, intent(in), value :: nsrc Number of source points Contents Source Code sdc_qmats Source Code subroutine sdc_qmats ( Qmat , Smat , dst , src , flags , ndst , nsrc ) integer , intent ( in ), value :: ndst !!  Number of destination points integer , intent ( in ), value :: nsrc !!  Number of source points real ( pfqp ), intent ( in ) :: dst ( ndst ) !!  Destination points real ( pfqp ), intent ( in ) :: src ( nsrc ) !!  Source points real ( pfdp ), intent ( out ) :: Qmat ( ndst - 1 , nsrc ) !!  O to dst quadrature weights real ( pfdp ), intent ( out ) :: Smat ( ndst - 1 , nsrc ) !! dst(m) to dst(m+1) quadrature weights integer , intent ( in ) :: flags ( nsrc ) integer :: i , j , m real ( pfqp ) :: q , s , den , p ( 0 : nsrc ) Qmat = 0.0_pfdp Smat = 0.0_pfdp ! construct Qmat and Smat do i = 1 , nsrc if ( not_proper ( flags , i )) cycle ! construct interpolating polynomial coefficients p = 0.0_pfdp p ( 0 ) = 1.0_pfdp do m = 1 , nsrc if ( not_proper ( flags , m ) . or . m == i ) cycle p = eoshift ( p , - 1 ) - src ( m ) * p end do den = poly_eval ( p , nsrc , src ( i )) call poly_int ( p , nsrc ) ! evaluate integrals do j = 2 , ndst q = poly_eval ( p , nsrc , dst ( j )) - poly_eval ( p , nsrc , 0.0_pfqp ) s = poly_eval ( p , nsrc , dst ( j )) - poly_eval ( p , nsrc , dst ( j - 1 )) Qmat ( j - 1 , i ) = real ( q / den , pfdp ) Smat ( j - 1 , i ) = real ( s / den , pfdp ) end do end do end subroutine sdc_qmats","tags":"","loc":"proc/sdc_qmats.html","title":"sdc_qmats – LibPFASST"},{"text":"public subroutine poly_diff(p, n) Subroutine to differentiate polynomial (in place) Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: p (0:n) integer, intent(in), value :: n Contents Source Code poly_diff Source Code subroutine poly_diff ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( inout ) :: p ( 0 : n ) integer :: j real ( pfqp ) :: pp ( 0 : n ) pp = 0.0_pfqp do j = 1 , n pp ( j - 1 ) = j * p ( j ) end do p = pp end subroutine poly_diff","tags":"","loc":"proc/poly_diff.html","title":"poly_diff – LibPFASST"},{"text":"public subroutine poly_int(p, n) Subroutine to integrate polynomial (in place) Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: p (0:n) integer, intent(in), value :: n Contents Source Code poly_int Source Code subroutine poly_int ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( inout ) :: p ( 0 : n ) integer :: j real ( pfqp ) :: pp ( 0 : n ) pp = 0.0_pfqp do j = 0 , n - 1 pp ( j + 1 ) = p ( j ) / ( j + 1 ) end do p = pp end subroutine poly_int","tags":"","loc":"proc/poly_int.html","title":"poly_int – LibPFASST"},{"text":"public subroutine poly_legendre(p, n) Subroutine to compute Legendre polynomial coefficients using Bonnet's recursion formula. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: p (0:n) integer, intent(in), value :: n Contents Source Code poly_legendre Source Code subroutine poly_legendre ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( out ) :: p ( 0 : n ) real ( pfqp ), dimension ( 0 : n ) :: p0 , p1 , p2 integer :: j , m if ( n == 0 ) then p = [ 1.0_pfqp ] return end if if ( n == 1 ) then p = [ 0.0_pfqp , 1.0_pfqp ] return end if p0 = 0.0_pfqp ; p1 = 0.0_pfqp ; p2 = 0.0_pfqp p0 ( 0 ) = 1.0_pfqp p1 ( 1 ) = 1.0_pfqp ! (n + 1) P_{n+1} = (2n + 1) x P_{n} - n P_{n-1} do m = 1 , n - 1 do j = 1 , n p2 ( j ) = ( ( 2 * m + 1 ) * p1 ( j - 1 ) - m * p0 ( j ) ) / ( m + 1 ) end do p2 ( 0 ) = - m * p0 ( 0 ) / ( m + 1 ) p0 = p1 p1 = p2 end do p = p2 end subroutine poly_legendre","tags":"","loc":"proc/poly_legendre.html","title":"poly_legendre – LibPFASST"},{"text":"public subroutine poly_roots(roots, p0, n) Subroutine to compute polynomial roots using the Durand-Kerner algorithm.\n The roots are assumed to be real. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: roots (n) real(kind=pfqp), intent(in) :: p0 (0:n) integer, intent(in), value :: n Contents Source Code poly_roots Source Code subroutine poly_roots ( roots , p0 , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( out ) :: roots ( n ) real ( pfqp ), intent ( in ) :: p0 ( 0 : n ) integer :: i , j , k complex ( pfqp ) :: num , den , z0 ( n ), z1 ( n ) real ( pfqp ) :: p ( 0 : n ) real ( pfqp ) :: eps eps = epsilon ( 1.0_pfqp ) * 10 0.0_pfqp p = p0 / p0 ( n ) ! initial guess do i = 1 , n z0 ( i ) = ( 0.4_pfqp , 0.9_pfqp ) ** i end do ! durand-kerner-weierstrass iterations z1 = z0 do k = 1 , 100 do i = 1 , n ! evaluate poly at z0(i) num = poly_eval_complex ( p , n , z0 ( i )) ! evaluate denominator den = 1.0_pfqp do j = 1 , n if ( j == i ) cycle den = den * ( z0 ( i ) - z0 ( j )) end do ! update z0 ( i ) = z0 ( i ) - num / den end do ! converged? if ( sum ( abs ( z0 - z1 )) < eps ) exit z1 = z0 end do roots = real ( z0 ) where ( abs ( roots ) < eps ) roots = 0.0_pfqp call qsort ( roots ) end subroutine poly_roots","tags":"","loc":"proc/poly_roots.html","title":"poly_roots – LibPFASST"},{"text":"public recursive subroutine qsort(a) Subroutine to sort (inplace) using the quick sort algorithm.\n Adapted from http://www.fortran.com/qsort_c.f95. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: a (:) Contents Source Code qsort Source Code recursive subroutine qsort ( a ) real ( pfqp ), intent ( inout ) :: a (:) integer :: iq if ( size ( a ) > 1 ) then call qsort_partition ( a , iq ) call qsort ( a (: iq - 1 )) call qsort ( a ( iq :)) end if end subroutine qsort","tags":"","loc":"proc/qsort.html","title":"qsort – LibPFASST"},{"text":"public interface poly_eval Contents Module Procedures poly_eval poly_eval_complex Module Procedures public interface poly_eval () Arguments None public function poly_eval_complex (p, n, x) result(v) Function to evaluate complex polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n complex(kind=pfqp), intent(in) :: x Return Value complex(kind=pfqp)","tags":"","loc":"interface/poly_eval.html","title":"poly_eval – LibPFASST"},{"text":"public function ndarray_oc_norm(this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code ndarray_oc_norm Source Code function ndarray_oc_norm ( this , flags ) result ( norm ) class ( ndarray_oc ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm integer :: which which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) print * , \"norm without flags\" select case ( which ) case ( 0 ) norm = max ( maxval ( abs ( this % yflatarray )), maxval ( abs ( this % pflatarray ))) case ( 1 ) norm = maxval ( abs ( this % yflatarray )) case ( 2 ) norm = maxval ( abs ( this % pflatarray )) case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end function ndarray_oc_norm","tags":"","loc":"proc/ndarray_oc_norm.html","title":"ndarray_oc_norm – LibPFASST"},{"text":"public function cast_as_ndarray_oc(encap_polymorph) result(ndarray_oc_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndarray_oc ),\n  pointer Contents Source Code cast_as_ndarray_oc Source Code function cast_as_ndarray_oc ( encap_polymorph ) result ( ndarray_oc_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndarray_oc ), pointer :: ndarray_oc_obj select type ( encap_polymorph ) type is ( ndarray_oc ) ndarray_oc_obj => encap_polymorph class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function cast_as_ndarray_oc","tags":"","loc":"proc/cast_as_ndarray_oc.html","title":"cast_as_ndarray_oc – LibPFASST"},{"text":"public function get_array1d_oc(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d_oc Source Code function get_array1d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"array1d_oc without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r => x % yflatarray case ( 2 ) r => x % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array1d_oc","tags":"","loc":"proc/get_array1d_oc.html","title":"get_array1d_oc – LibPFASST"},{"text":"public function get_array2d_oc(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d_oc Source Code function get_array2d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"array2d_oc without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % yflatarray case ( 2 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % pflatarray case default stop \"ERROR in get_array1d_oc: only 1, 2 allowed as flags\" end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array2d_oc","tags":"","loc":"proc/get_array2d_oc.html","title":"get_array2d_oc – LibPFASST"},{"text":"public function get_array3d_oc(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d_oc Source Code function get_array3d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ), target :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) integer :: which which = 0 if ( present ( flags )) which = flags select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % yflatarray case ( 2 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % pflatarray case default stop \"ERROR in get_array1d_oc: only 1, 2 allowed as flags\" end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array3d_oc","tags":"","loc":"proc/get_array3d_oc.html","title":"get_array3d_oc – LibPFASST"},{"text":"public subroutine ndarray_oc_build(q, shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) Contents Source Code ndarray_oc_build Source Code subroutine ndarray_oc_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) select type ( q ) class is ( ndarray_oc ) allocate ( q % shape ( size ( shape ))) allocate ( q % yflatarray ( product ( shape ))) allocate ( q % pflatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_build","tags":"","loc":"proc/ndarray_oc_build.html","title":"ndarray_oc_build – LibPFASST"},{"text":"public subroutine ndarray_oc_create_single(this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndarray_oc_create_single Source Code subroutine ndarray_oc_create_single ( this , x , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( ndarray_oc :: x ) call ndarray_oc_build ( x , shape ) end subroutine ndarray_oc_create_single","tags":"","loc":"proc/ndarray_oc_create_single.html","title":"ndarray_oc_create_single – LibPFASST"},{"text":"public subroutine ndarray_oc_create_array(this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndarray_oc_create_array Source Code subroutine ndarray_oc_create_array ( this , x , n , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndarray_oc :: x ( n )) do i = 1 , n call ndarray_oc_build ( x ( i ), shape ) end do end subroutine ndarray_oc_create_array","tags":"","loc":"proc/ndarray_oc_create_array.html","title":"ndarray_oc_create_array – LibPFASST"},{"text":"public subroutine ndarray_oc_destroy(encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Contents Source Code ndarray_oc_destroy Source Code subroutine ndarray_oc_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndarray_oc ), pointer :: ndarray_oc_obj ndarray_oc_obj => cast_as_ndarray_oc ( encap ) !?? deallocate ( ndarray_oc_obj % pflatarray ) deallocate ( ndarray_oc_obj % yflatarray ) deallocate ( ndarray_oc_obj % shape ) nullify ( ndarray_oc_obj ) end subroutine ndarray_oc_destroy","tags":"","loc":"proc/ndarray_oc_destroy.html","title":"ndarray_oc_destroy – LibPFASST"},{"text":"public subroutine ndarray_oc_destroy_single(this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x Contents Source Code ndarray_oc_destroy_single Source Code subroutine ndarray_oc_destroy_single ( this , x ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x select type ( x ) class is ( ndarray_oc ) deallocate ( x % pflatarray ) deallocate ( x % yflatarray ) deallocate ( x % shape ) class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select deallocate ( x ) end subroutine ndarray_oc_destroy_single","tags":"","loc":"proc/ndarray_oc_destroy_single.html","title":"ndarray_oc_destroy_single – LibPFASST"},{"text":"public subroutine ndarray_oc_destroy_array(this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) Contents Source Code ndarray_oc_destroy_array Source Code subroutine ndarray_oc_destroy_array ( this , x ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer :: i select type ( x ) class is ( ndarray_oc ) do i = 1 , size ( x ) deallocate ( x ( i )% pflatarray ) deallocate ( x ( i )% yflatarray ) deallocate ( x ( i )% shape ) end do class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select deallocate ( x ) end subroutine ndarray_oc_destroy_array","tags":"","loc":"proc/ndarray_oc_destroy_array.html","title":"ndarray_oc_destroy_array – LibPFASST"},{"text":"public subroutine ndarray_oc_setval(this, val, flags) Subroutine to set array to a scalar  value. Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code ndarray_oc_setval Source Code subroutine ndarray_oc_setval ( this , val , flags ) class ( ndarray_oc ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"setval without flags\" select case ( which ) case ( 0 ) this % yflatarray = val this % pflatarray = val case ( 1 ) this % yflatarray = val case ( 2 ) this % pflatarray = val case default call pf_stop ( __ FILE__ , __ LINE__ , 'Select case error' , which ) end select end subroutine ndarray_oc_setval","tags":"","loc":"proc/ndarray_oc_setval.html","title":"ndarray_oc_setval – LibPFASST"},{"text":"public subroutine ndarray_oc_copy(this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Contents Source Code ndarray_oc_copy Source Code subroutine ndarray_oc_copy ( this , src , flags ) class ( ndarray_oc ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"copy without flags\" select type ( src ) type is ( ndarray_oc ) select case ( which ) case ( 0 ) this % yflatarray = src % yflatarray this % pflatarray = src % pflatarray case ( 1 ) this % yflatarray = src % yflatarray case ( 2 ) this % pflatarray = src % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_copy","tags":"","loc":"proc/ndarray_oc_copy.html","title":"ndarray_oc_copy – LibPFASST"},{"text":"public subroutine ndarray_oc_pack(this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndarray_oc_pack Source Code subroutine ndarray_oc_pack ( this , z , flags ) class ( ndarray_oc ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags select case ( which ) case ( 0 ) !z = [sol%yflatarray, sol%pflatarray] !z has to be right size? initialized to nvars, so it can hold either y or p !is it ever needed to pack y and p simultaneously? stop \"ERROR in ndarray_oc_pack: only 1, 2 allowed as flags\" case ( 1 ) z = this % yflatarray case ( 2 ) z = this % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine ndarray_oc_pack","tags":"","loc":"proc/ndarray_oc_pack.html","title":"ndarray_oc_pack – LibPFASST"},{"text":"public subroutine ndarray_oc_unpack(this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndarray_oc_unpack Source Code subroutine ndarray_oc_unpack ( this , z , flags ) class ( ndarray_oc ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags select case ( which ) case ( 0 ) stop \"ERROR in ndarray_oc_unpack: only 1, 2 allowed as flags\" case ( 1 ) this % yflatarray = z case ( 2 ) this % pflatarray = z case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine ndarray_oc_unpack","tags":"","loc":"proc/ndarray_oc_unpack.html","title":"ndarray_oc_unpack – LibPFASST"},{"text":"public subroutine ndarray_oc_axpy(this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Contents Source Code ndarray_oc_axpy Source Code subroutine ndarray_oc_axpy ( this , a , x , flags ) class ( ndarray_oc ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if (.not.present(flags)) stop \"axpy without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 0 ) this % yflatarray = a * x % yflatarray + this % yflatarray this % pflatarray = a * x % pflatarray + this % pflatarray case ( 1 ) this % yflatarray = a * x % yflatarray + this % yflatarray case ( 2 ) this % pflatarray = a * x % pflatarray + this % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_axpy","tags":"","loc":"proc/ndarray_oc_axpy.html","title":"ndarray_oc_axpy – LibPFASST"},{"text":"public subroutine ndarray_oc_dump_hook(pf, level_index) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index Contents Source Code ndarray_oc_dump_hook Source Code subroutine ndarray_oc_dump_hook ( pf , level_index ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index character ( len = 256 ) :: fnamey , fnamep type ( ndarray_oc ), pointer :: qend qend => cast_as_ndarray_oc ( pf % levels ( level_index )% qend ) write ( fnamey , \"('y_s',i0.2,'i',i0.3,'l',i0.2,'.npy')\" ) & pf % state % step , pf % state % iter , level_index call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamey ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % yflatarray ), qend % yflatarray ) write ( fnamep , \"('p_s',i0.2,'i',i0.3,'l',i0.2,'.npy')\" ) & pf % state % step , pf % state % iter , level_index call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamep ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % pflatarray ), qend % pflatarray ) end subroutine ndarray_oc_dump_hook","tags":"","loc":"proc/ndarray_oc_dump_hook.html","title":"ndarray_oc_dump_hook – LibPFASST"},{"text":"public subroutine ndarray_oc_dump_all_hook(pf, level_index) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index Contents Source Code ndarray_oc_dump_all_hook Source Code subroutine ndarray_oc_dump_all_hook ( pf , level_index ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index character ( len = 256 ) :: fnamey , fnamep integer :: m type ( ndarray_oc ), pointer :: qend do m = 1 , pf % levels ( level_index )% nnodes qend => cast_as_ndarray_oc ( pf % levels ( level_index )% Q ( m )) write ( fnamey , \"('y_s',i0.2,'l',i0.2,'m',i0.2,'.npy')\" ) & pf % state % step , level_index , m call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamey ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % yflatarray ), qend % yflatarray ) write ( fnamep , \"('p_s',i0.2,'l',i0.2,'m',i0.2,'.npy')\" ) & pf % state % step , level_index , m call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamep ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % pflatarray ), qend % pflatarray ) end do end subroutine ndarray_oc_dump_all_hook","tags":"","loc":"proc/ndarray_oc_dump_all_hook.html","title":"ndarray_oc_dump_all_hook – LibPFASST"},{"text":"public subroutine ndarray_oc_eprint(this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code ndarray_oc_eprint Source Code subroutine ndarray_oc_eprint ( this , flags ) class ( ndarray_oc ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % yflatarray ( 1 : 10 ) print * , this % pflatarray ( 1 : 10 ) end subroutine ndarray_oc_eprint","tags":"","loc":"proc/ndarray_oc_eprint.html","title":"ndarray_oc_eprint – LibPFASST"},{"text":"interface public subroutine ndarray_dump_numpy(dname, fname, endian, dim, shape, nvars, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer(kind=c_int), intent(in), value :: dim integer(kind=c_int), intent(in) :: shape (dim) integer(kind=c_int), intent(in), value :: nvars real(kind=pfdp), intent(in) :: array (nvars)","tags":"","loc":"interface/ndarray_dump_numpy~2.html","title":"ndarray_dump_numpy – LibPFASST"},{"text":"public subroutine pf_parareal_run(pf, q0, dt, tend, nsteps, qend) Do the parareal algorithm\n  Set the number of time steps to do\n  The user can either pass in the number of time steps or\n  pass in the time step size and length of run\n  Allocate stuff for holding results deallocate results data Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf The complete PFASST structure class( pf_encap_t ), intent(in) :: q0 The initial condition real(kind=pfdp), intent(in) :: dt The time step for each processor real(kind=pfdp), intent(in) :: tend The final time of run integer, intent(in), optional :: nsteps The number of time steps class( pf_encap_t ), intent(inout), optional :: qend The computed solution at tend Contents Source Code pf_parareal_run Source Code subroutine pf_parareal_run ( pf , q0 , dt , tend , nsteps , qend ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  The complete PFASST structure class ( pf_encap_t ), intent ( in ) :: q0 !!  The initial condition real ( pfdp ), intent ( in ) :: dt !!  The time step for each processor real ( pfdp ), intent ( in ) :: tend !!  The final time of run integer , intent ( in ), optional :: nsteps !!  The number of time steps class ( pf_encap_t ), intent ( inout ), optional :: qend !!  The computed solution at tend !  Local variables integer :: nproc !!  Total number of processors integer :: nsteps_loc !!  local number of time steps real ( pfdp ) :: tend_loc !!  The final time of run ! make a local copy of nproc nproc = pf % comm % nproc !>  Set the number of time steps to do !!  The user can either pass in the number of time steps or !!  pass in the time step size and length of run if ( present ( nsteps )) then nsteps_loc = nsteps tend_loc = dble ( nsteps_loc * dt ) else nsteps_loc = ceiling ( tend / dt ) !  Do  sanity check on steps if ( abs ( real ( nsteps_loc , pfdp ) - tend / dt ) > dt / 10 0.0 ) then print * , 'dt=' , dt print * , 'nsteps=' , nsteps_loc print * , 'tend=' , tend stop \"Invalid nsteps\" end if end if pf % state % nsteps = nsteps_loc !>  Allocate stuff for holding results call pf_initialize_results ( pf ) !  do sanity checks on Nproc if ( mod ( nsteps , nproc ) > 0 ) stop \"ERROR: nsteps must be multiple of nproc (pf_parallel.f90).\" if ( present ( qend )) then call pf_parareal_block_run ( pf , q0 , dt , nsteps_loc , qend = qend ) else call pf_parareal_block_run ( pf , q0 , dt , nsteps_loc ) end if call pf_dump_results ( pf ) !>   deallocate results data call pf_destroy_results ( pf ) end subroutine pf_parareal_run","tags":"","loc":"proc/pf_parareal_run.html","title":"pf_parareal_run – LibPFASST"},{"text":"public subroutine pf_parareal_block_run(pf, q0, dt, nsteps, qend, flags) parareal controller for block mode\n  When starting a new block, broadcast new initial conditions to all procs\n  For initial block, this is done when initial conditions are set\n Reset some flags\n  Pack away your last solution\n  Everyone resets their q0\n  Just stick qend in q0\n  Update the step and t0 variables for new block\n Call the predictor to get an initial guess on all levels and all processors Start the parareal iterations Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf class( pf_encap_t ), intent(in) :: q0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps class( pf_encap_t ), intent(inout), optional :: qend integer, intent(in), optional :: flags (:) Contents Source Code pf_parareal_block_run Source Code subroutine pf_parareal_block_run ( pf , q0 , dt , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf class ( pf_encap_t ), intent ( in ) :: q0 real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps class ( pf_encap_t ), intent ( inout ), optional :: qend integer , intent ( in ), optional :: flags (:) class ( pf_level_t ), pointer :: lev_p !!  pointer to the one level we are operating on integer :: j , k integer :: nblocks !!  The number of blocks of steps to do integer :: nproc !!  The number of processors being used integer :: level_index_c !!  Coarsest level in V (Lambda)-cycle integer :: level_max_depth !!  Finest level in V-cycle integer :: nsteps_c , nsteps_f call start_timer ( pf , TTOTAL ) pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % step = pf % rank pf % state % t0 = pf % state % step * dt ! set finest level to visit in the following run pf % state % finest_level = pf % nlevels !  pointer to finest  level to start lev_p => pf % levels ( pf % state % finest_level ) !  Stick the initial condition into q0 (will happen on all processors) call lev_p % q0 % copy ( q0 , flags = 0 ) nproc = pf % comm % nproc nblocks = nsteps / nproc !  Decide what the coarsest level in the V-cycle is level_index_c = 1 if (. not . pf % Vcycle ) level_index_c = pf % state % finest_level do k = 1 , nblocks !  Loop over blocks of time steps ! print *,'Starting  step=',pf%state%step,'  block k=',k ! Each block will consist of !  1.  predictor !  2.  Vcycle until max iterations, or tolerances met !  3.  Move solution to next block !  Reset some flags !>  When starting a new block, broadcast new initial conditions to all procs !>  For initial block, this is done when initial conditions are set !> Reset some flags pf % state % iter = - 1 pf % state % itcnt = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % pfblock = k pf % state % sweep = 1 !  Needed for compatibility of residual storage if ( k > 1 ) then if ( nproc > 1 ) then call lev_p % qend % pack ( lev_p % send ) !!  Pack away your last solution call pf_broadcast ( pf , lev_p % send , lev_p % mpibuflen , pf % comm % nproc - 1 ) call lev_p % q0 % unpack ( lev_p % send ) !!  Everyone resets their q0 else call lev_p % q0 % copy ( lev_p % qend , flags = 0 ) !!  Just stick qend in q0 end if !>  Update the step and t0 variables for new block pf % state % step = pf % state % step + pf % comm % nproc pf % state % t0 = pf % state % step * dt end if !> Call the predictor to get an initial guess on all levels and all processors call pf_parareal_predictor ( pf , pf % state % t0 , dt , flags ) !>  Start the parareal iterations call start_timer ( pf , TITERATION ) do j = 1 , pf % niters call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle call pf_parareal_v_cycle ( pf , k , pf % state % t0 , dt , 1 , 2 ) !  Check for convergence call pf_check_convergence_block ( pf , pf % state % finest_level , send_tag = 1111 * k + j ) call call_hooks ( pf , - 1 , PF_POST_ITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) exit end do !  Loop over the iteration in this bloc call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) call end_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_POST_STEP ) end do !  Loop over the blocks call end_timer ( pf , TTOTAL ) !  Grab the last solution for return (if wanted) if ( present ( qend )) then call qend % copy ( lev_p % qend , flags = 0 ) end if end subroutine pf_parareal_block_run","tags":"","loc":"proc/pf_parareal_block_run.html","title":"pf_parareal_block_run – LibPFASST"},{"text":"public subroutine pf_parareal_predictor(pf, t0, dt, flags) The parareal predictor does a serial integration on the coarse level followed\n  by a fine integration if there is a fine level\n Step 1. Getting the initial condition on the coarsest level Step 2. Do coarse level integration, no communication necessary\n  Step 3:  Return to fine level and Step there Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags Contents Source Code pf_parareal_predictor Source Code subroutine pf_parareal_predictor ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p !! integer :: k , n !!  Loop indices integer :: nsteps_c , nsteps_f !!  Number of RK  steps integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k pf % state % iter = 0 call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) !  This is for one two levels only or one if only RK is done c_lev_p => pf % levels ( 1 ) f_lev_p => pf % levels ( pf % state % finest_level ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning parareal predictor' !! Step 1. Getting the initial condition on the coarsest level if ( pf % state % finest_level > 1 ) then if ( pf % q0_style < 2 ) then !  Copy coarse call c_lev_p % q0 % copy ( f_lev_p % q0 ) end if end if level_index = 1 !! !! Step 2. Do coarse level integration, no communication necessary nsteps_c = c_lev_p % ulevel % stepper % nsteps !  Each processor integrates alone do n = 1 , pf % rank + 1 if ( n . gt . 1 ) call c_lev_p % q0 % copy ( c_lev_p % qend ) t0k = dt * real ( n - 1 , pfdp ) call c_lev_p % ulevel % stepper % do_n_steps ( pf , 1 , t0k , c_lev_p % q0 , c_lev_p % qend , dt , nsteps_c ) end do ! Save the coarse level value call c_lev_p % Q ( 2 )% copy ( c_lev_p % qend , flags = 0 ) !!  Step 3:  Return to fine level and Step there !    if(pf%state%finest_level > 1) then  !  Will do nothing with one level !       call f_lev_p%q0%copy(c_lev_p%q0, flags=0)       !  Get fine initial condition !       nsteps_f= f_lev_p%ulevel%stepper%nsteps  !  Each processor integrates alone !       call f_lev_p%ulevel%stepper%do_n_steps(pf, level_index,pf%state%t0, f_lev_p%q0,f_lev_p%qend, dt, nsteps_f) !    endif call end_timer ( pf , TPREDICTOR ) pf % state % iter = 1 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) end subroutine pf_parareal_predictor","tags":"","loc":"proc/pf_parareal_predictor.html","title":"pf_parareal_predictor – LibPFASST"},{"text":"public subroutine pf_parareal_v_cycle(pf, iteration, t0, dt, level_index_c, level_index_f, flags) Execute a V-cycle between levels nfine and ncoarse $    print *,'after fine steps '\n$    call f_lev_p%qend%eprint()\n$    call c_lev_p%qend%eprint() Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags Contents Source Code pf_parareal_v_cycle Source Code subroutine pf_parareal_v_cycle ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j , nsteps_f , nsteps_c if ( pf % nlevels < 2 ) return !  This is for two levels only c_lev_p => pf % levels ( 1 ) f_lev_p => pf % levels ( 2 ) nsteps_c = c_lev_p % ulevel % stepper % nsteps nsteps_f = f_lev_p % ulevel % stepper % nsteps !  Do fine steps with old initial condition if ( pf % rank /= 0 ) then call f_lev_p % q0 % copy ( c_lev_p % q0 , flags = 0 ) !  Get fine initial condition end if call f_lev_p % ulevel % stepper % do_n_steps ( pf , 2 , pf % state % t0 , f_lev_p % q0 , f_lev_p % qend , dt , nsteps_f ) ! Get a new initial condition on coarse call pf_recv ( pf , c_lev_p , 10000 + iteration , . true .) !  Step on coarse call c_lev_p % ulevel % stepper % do_n_steps ( pf , 1 , pf % state % t0 , c_lev_p % q0 , c_lev_p % qend , dt , nsteps_c ) !  Compute the correction (store in Q(1)) call c_lev_p % Q ( 1 )% copy ( f_lev_p % qend , flags = 0 ) !  Current call c_lev_p % Q ( 1 )% axpy ( - 1.0_pfdp , c_lev_p % Q ( 2 )) ! ! Save the result of the coarse sweep call c_lev_p % Q ( 2 )% copy ( c_lev_p % qend , flags = 0 ) ! correct coarse level solution at end (the parareal correction) call c_lev_p % qend % axpy ( 1.0_pfdp , c_lev_p % Q ( 1 )) !  Send coarse forward  (nonblocking) call pf_send ( pf , c_lev_p , 10000 + iteration , . false .) !  Compute the jump in the initial condition call f_lev_p % q0_delta % copy ( c_lev_p % q0 , flags = 0 ) call f_lev_p % q0_delta % axpy ( - 1.0d0 , f_lev_p % q0 , flags = 0 ) f_lev_p % residual = f_lev_p % q0_delta % norm ( flags = 0 ) call pf_set_resid ( pf , 2 , f_lev_p % residual ) !!$    print *,'after fine steps ' !!$    call f_lev_p%qend%eprint() !!$    call c_lev_p%qend%eprint() end subroutine pf_parareal_v_cycle","tags":"","loc":"proc/pf_parareal_v_cycle.html","title":"pf_parareal_v_cycle – LibPFASST"},{"text":"public subroutine pf_check_convergence_block(pf, level_index, send_tag) Subroutine to check if the current processor has converged and\n to update the next processor on the status\n Note that if the previous processor hasn't converged yet\n (pstatus), the current processor can't be converged yet either\n Check to see if tolerances are met Until I hear the previous processor is done, recieve it's status Check to see if I am converged\n  For parareal, Proc N is converged after iteration N\n Assign status and send it forward Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index integer, intent(in) :: send_tag identifier for status send and receive Contents Source Code pf_check_convergence_block Source Code subroutine pf_check_convergence_block ( pf , level_index , send_tag ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index integer , intent ( in ) :: send_tag !! identifier for status send and receive logical :: residual_converged , converged ! Shortcut for fixed iteration mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual ( pf , level_index , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 ) then converged = . true . else !  I am not the first processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !>  For parareal, Proc N is converged after iteration N if ( pf % rank . lt . pf % state % iter ) then converged = . true . end if !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag ) end if end subroutine pf_check_convergence_block","tags":"","loc":"proc/pf_check_convergence_block~2.html","title":"pf_check_convergence_block – LibPFASST"},{"text":"public subroutine pf_check_residual(pf, level_index, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index logical, intent(out) :: residual_converged Return true if residual is below tolerances Contents Source Code pf_check_residual Source Code subroutine pf_check_residual ( pf , level_index , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: level_index logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if absolute tolerance is met if ( pf % levels ( level_index )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( level_index )% residual residual_converged = . true . end if end subroutine pf_check_residual","tags":"","loc":"proc/pf_check_residual~2.html","title":"pf_check_residual – LibPFASST"},{"text":"Module to do Runge-Kutta stepping Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_ark_stepper_t Subroutines ark_do_n_steps ark_initialize ark_destroy Interfaces interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dtq class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece Derived Types type, public, abstract, extends( pf_stepper_t ) :: pf_ark_stepper_t IMEX or additive or semi-implicit Runge-Kutta stepper  type Components Type Visibility Attributes Name Initial integer, public :: npieces integer, public :: order integer, public :: nsteps real(kind=pfdp), public, allocatable :: AmatI (:,:) real(kind=pfdp), public, allocatable :: AmatE (:,:) real(kind=pfdp), public, allocatable :: cvec (:) real(kind=pfdp), public, allocatable :: bvecI (:) real(kind=pfdp), public, allocatable :: bvecE (:) real(kind=pfdp), public, allocatable :: QtilI (:,:) logical, public :: explicit = .true. logical, public :: implicit = .true. integer, public :: nstages class( pf_encap_t ), public, allocatable :: rhs Accumulated right hand side for implicit solves class( pf_encap_t ), public, allocatable :: qtemp Temp for y class( pf_encap_t ), public, allocatable :: q0 Local q0 class( pf_encap_t ), public, allocatable :: qend Local qend class( pf_encap_t ), public, pointer :: F (:,:) Pointer to F Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: do_n_steps => ark_do_n_steps procedure, public :: initialize => ark_initialize procedure, public :: destroy => ark_destroy procedure, public :: ark_initialize procedure, public :: ark_destroy Subroutines public subroutine ark_do_n_steps (this, pf, level_index, t0, q0, qend, big_dt, nsteps_rk) Perform N steps of ark on level level_index and set qend appropriately.\n Assign pointer to appropriate level Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Level of the index to step on real(kind=pfdp), intent(in) :: t0 Time at start of time interval class( pf_encap_t ), intent(in) :: q0 Starting value class( pf_encap_t ), intent(inout) :: qend Final value real(kind=pfdp), intent(in) :: big_dt Size of time interval to integrato on integer, intent(in) :: nsteps_rk Number of steps to use public subroutine ark_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize public subroutine ark_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_ark_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index","tags":"","loc":"module/pf_mod_rkstepper.html","title":"pf_mod_rkstepper – LibPFASST"},{"text":"IMEX Sweeper Module\n  Module of the  the derived sweeper class for doing IMEX sweeps for an equation of the form y' = f_1(y) + f_2(y) The f_1 piece is treated explicitly and f_2 implicitl\n  Afer this sweeper is initialized (usually in main), the logical flags can be changed if desired explicit : Make false if there is no explicit piece implicit : Make false if there is no implicit piece The user needs to supply the feval and fcomp routines for a given example Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_imex_sweeper_t Subroutines imex_sweep imex_initialize imex_destroy imex_integrate imex_residual imex_spreadq0 imex_evaluate imex_evaluate_all Interfaces interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) The interface to the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) The interface to the routine to do implicit solve \n  i.e, solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_imex_sweeper_t IMEX SDC sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QtilE (:,:) Approximate explicit quadrature rule real(kind=pfdp), public, allocatable :: QtilI (:,:) Approximate implicit quadrature rule real(kind=pfdp), public, allocatable :: dtsdc (:) SDC step sizes real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: QdiffI (:,:) qmat-QtilI logical, public :: explicit True if there is an explicit piece (must set in derived sweeper) logical, public :: implicit True if there an implicit piece (must set in derived sweeper) class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval RHS function evaluations procedure(pf_f_comp_p), public :: f_comp Implicit solver procedure, public :: sweep => imex_sweep Set the generic functions procedure, public :: initialize => imex_initialize procedure, public :: evaluate => imex_evaluate procedure, public :: integrate => imex_integrate procedure, public :: residual => imex_residual procedure, public :: spreadq0 => imex_spreadq0 procedure, public :: evaluate_all => imex_evaluate_all procedure, public :: destroy => imex_destroy procedure, public :: imex_destroy procedure, public :: imex_initialize Subroutines public subroutine imex_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform nsweeps SDC sweeps on level level_index and set qend appropriately.\n  Loop over sweeps\n  Loop over substeps\n  Accumulate rhs\n  Add the integral term Read more… Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to sweep real(kind=pfdp), intent(in) :: t0 time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags sweep specific flags public subroutine imex_initialize (this, pf, level_index) Subroutine to initialize matrices and space for sweeper\n  Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize public subroutine imex_destroy (this, pf, level_index) Subroutine to deallocate sweeper Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine imex_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Subroutine to compute  Picard integral of function values Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags public subroutine imex_residual (this, pf, level_index, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags public subroutine imex_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imex_evaluate (this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imex_evaluate_all (this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_imex_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"module/pf_mod_imex_sweeper.html","title":"pf_mod_imex_sweeper – LibPFASST"},{"text":"Module of the  the derived sweeper class for doing MISDC sweeps for an equation of the form y' = f_1(y) + f_2(y) + f_3(y) The f_1 piece is treated explicitly and f_2 and f_3 implicitly\n  Afer this sweeper is initialized (usually in main), the locgical flags can be changed if desired Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_misdcQ_t Subroutines misdcQ_sweep misdcQ_initialize misdcQ_destroy misdcQ_integrate misdcQ_evaluate misdcQ_evaluate_all misdcQ_residual misdcQ_spreadq0 Interfaces interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_misdcQ_t Multi-implicit SDC sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) class( pf_encap_t ), public, allocatable :: I3 (:) class( pf_encap_t ), public, allocatable :: rhs Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: sweep => misdcQ_sweep procedure, public :: initialize => misdcQ_initialize procedure, public :: integrate => misdcQ_integrate procedure, public :: residual => misdcQ_residual procedure, public :: spreadq0 => misdcQ_spreadq0 procedure, public :: evaluate_all => misdcQ_evaluate_all procedure, public :: evaluate => misdcQ_evaluate procedure, public :: destroy => misdcQ_destroy procedure, public :: misdcQ_destroy procedure, public :: misdcQ_initialize Subroutines public subroutine misdcQ_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Loop over sweeps Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine misdcQ_initialize (this, pf, level_index) Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine misdcQ_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine misdcQ_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine misdcQ_evaluate (this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine misdcQ_evaluate_all (this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine misdcQ_residual (this, pf, level_index, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags public subroutine misdcQ_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"module/pf_mod_misdcq.html","title":"pf_mod_misdcQ – LibPFASST"},{"text":"Multi-implicit SDC sweeper type (old style), extends abstract sweeper Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_misdc_t Subroutines misdc_sweep misdc_evaluate misdc_initialize misdc_destroy misdc_integrate misdc_residual misdc_evaluate_all Interfaces interface public subroutine pf_f_eval_p(this, y, t, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece interface public subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_misdc_t MISDC sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure(pf_spreadq0_p), public :: spreadq0 procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: sweep => misdc_sweep procedure, public :: initialize => misdc_initialize procedure, public :: evaluate => misdc_evaluate procedure, public :: integrate => misdc_integrate procedure, public :: residual => misdc_residual procedure, public :: evaluate_all => misdc_evaluate_all procedure, public :: destroy => misdc_destroy procedure, public :: misdc_destroy Subroutines public subroutine misdc_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine misdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m public subroutine misdc_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine misdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine misdc_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) public subroutine misdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt public subroutine misdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:)","tags":"","loc":"module/pf_mod_misdc.html","title":"pf_mod_misdc – LibPFASST"},{"text":"Module for using fftpack Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_fft_s_p pf_fft_p Derived Types pf_fft_abs_t Subroutines get_wk_ptr_1d get_wk_ptr_2d get_wk_ptr_3d fft_1d fft_2d fft_3d ifft_1d ifft_2d ifft_3d zfft_1d zfft_2d zfft_3d izfft_1d izfft_2d izfft_3d conv_1d conv_2d conv_3d zconv_1d zconv_2d zconv_3d make_lap_1d make_deriv_1d make_lap_2d make_deriv_2d make_deriv_3d make_lap_3d restrict_1d restrict_2d restrict_3d zrestrict_1d zrestrict_2d zrestrict_3d Interfaces interface public subroutine pf_fft_s_p(this, grid_shape, dim, grid_size) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) interface public subroutine pf_fft_p(this) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this Derived Types type, public, abstract :: pf_fft_abs_t Variables and storage for FFT Components Type Visibility Attributes Name Initial integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes integer, public :: dim spatial dimension real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size complex(kind=pfdp), public, pointer :: wk_1d (:) complex(kind=pfdp), public, pointer :: wk_2d (:,:) complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) Type-Bound Procedures procedure(pf_fft_s_p), public :: fft_setup procedure(pf_fft_p), public :: fft_destroy procedure(pf_fft_p), public :: fftf procedure(pf_fft_p), public :: fftb generic, public :: fft => fft_1d, fft_2d, fft_3d, zfft_1d, zfft_2d, zfft_3d generic, public :: ifft => ifft_1d, ifft_2d, ifft_3d, izfft_1d, izfft_2d, izfft_3d generic, public :: conv => conv_1d, conv_2d, conv_3d generic, public :: zconv => zconv_1d, zconv_2d, zconv_3d generic, public :: get_wk_ptr => get_wk_ptr_1d, get_wk_ptr_2d, get_wk_ptr_3d generic, public :: make_lap => make_lap_1d, make_lap_2d, make_lap_3d generic, public :: make_deriv => make_deriv_1d, make_deriv_2d, make_deriv_3d generic, public :: restrict => restrict_1d, restrict_2d, restrict_3d, zrestrict_1d, zrestrict_2d, zrestrict_3d Subroutines public subroutine get_wk_ptr_1d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:) public subroutine get_wk_ptr_2d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:) public subroutine get_wk_ptr_3d (this, wk) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout), pointer :: wk (:,:,:) public subroutine fft_1d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) public subroutine fft_2d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) public subroutine fft_3d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) public subroutine ifft_1d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) real(kind=pfdp), intent(inout) :: g (:) public subroutine ifft_2d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) real(kind=pfdp), intent(inout) :: g (:,:) public subroutine ifft_3d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) real(kind=pfdp), intent(inout) :: g (:,:,:) public subroutine zfft_1d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) complex(kind=pfdp), intent(inout) :: ghat (:) public subroutine zfft_2d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:) public subroutine zfft_3d (this, g, ghat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(inout) :: ghat (:,:,:) public subroutine izfft_1d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(inout) :: g (:) public subroutine izfft_2d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(inout) :: g (:,:) public subroutine izfft_3d (this, ghat, g) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(inout) :: g (:,:,:) public subroutine conv_1d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(inout) :: g (:) complex(kind=pfdp), intent(in) :: op (:) real(kind=pfdp), intent(inout) :: c (:) public subroutine conv_2d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:) complex(kind=pfdp), intent(in) :: op (:,:) real(kind=pfdp), intent(inout) :: c (:,:) public subroutine conv_3d (this, g, op, c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: g (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) real(kind=pfdp), intent(inout) :: c (:,:,:) public subroutine zconv_1d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:) complex(kind=pfdp), intent(in) :: op (:) complex(kind=pfdp), intent(inout) :: chat (:) public subroutine zconv_2d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:) complex(kind=pfdp), intent(in) :: op (:,:) complex(kind=pfdp), intent(inout) :: chat (:,:) public subroutine zconv_3d (this, ghat, op, chat) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: ghat (:,:,:) complex(kind=pfdp), intent(in) :: op (:,:,:) complex(kind=pfdp), intent(inout) :: chat (:,:,:) public subroutine make_lap_1d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) public subroutine make_deriv_1d (this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) public subroutine make_lap_2d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) public subroutine make_deriv_2d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir public subroutine make_deriv_3d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir public subroutine make_lap_3d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) public subroutine restrict_1d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:) real(kind=pfdp), pointer :: yvec_c (:) public subroutine restrict_2d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:) real(kind=pfdp), pointer :: yvec_c (:,:) public subroutine restrict_3d (this, yvec_f, yvec_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this real(kind=pfdp), pointer :: yvec_f (:,:,:) real(kind=pfdp), pointer :: yvec_c (:,:,:) public subroutine zrestrict_1d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:) complex(kind=pfdp), pointer :: yhat_c (:) public subroutine zrestrict_2d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:) complex(kind=pfdp), pointer :: yhat_c (:,:) public subroutine zrestrict_3d (this, yhat_f, yhat_c) Arguments Type Intent Optional Attributes Name class( pf_fft_abs_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_f (:,:,:) complex(kind=pfdp), pointer :: yhat_c (:,:,:)","tags":"","loc":"module/pf_mod_fft_abs.html","title":"pf_mod_fft_abs – LibPFASST"},{"text":"Module containing the routines to create, setup, and destroy the main data structure in PFASST Uses pf_mod_dtype pf_mod_comm_mpi pf_mod_utils pf_mod_results Contents Subroutines pf_pfasst_create pf_level_set_size pf_pfasst_setup pf_level_setup pf_pfasst_destroy pf_level_destroy pf_read_opts pf_print_options pf_time_interpolation_matrix pf_initialize_results pf_dump_results pf_destroy_results Subroutines public subroutine pf_pfasst_create (pf, comm, nlevels, fname, nocmd) Create a PFASST object\n gather some input from a file and command line\n  fname  present,  read inputs from a file (and maybe command line)\n  fname not present, only call read_opts if we want command line read\n  set communicator Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst object type( pf_comm_t ), intent(inout), target :: comm Communicator integer, intent(in), optional :: nlevels number of pfasst levels character(len=*), intent(in), optional :: fname Input file for pfasst parameters logical, intent(in), optional :: nocmd Determines if command line variables are to be read public subroutine pf_level_set_size (pf, level_index, shape_in, buflen_in) Helper routine to set the size and mpi buffer length for regular grids Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst structure integer, intent(in) :: level_index integer, intent(in) :: shape_in (:) integer, intent(in), optional :: buflen_in public subroutine pf_pfasst_setup (pf) Setup both the PFASST object and the comm object\n  loop over levels to set parameters\n  set default finest level\n  Loop over levels setting interpolation and restriction matrices (in time) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf Main pfasst structure public subroutine pf_level_setup (pf, level_index) Setup (allocate) PFASST level\n If the level is already setup, calling this again will allocate\n (or deallocate) tauQ appropriately.\n  Assign level pointer Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf Main pfasst structure integer, intent(in) :: level_index level to set up public subroutine pf_pfasst_destroy (pf) Deallocate PFASST object\n  destroy all levels\n  deallocate pfasst pointer arrays Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst structure public subroutine pf_level_destroy (pf, level_index) Deallocate PFASST level\n  Assign level pointer Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf Main pfasst structure integer, intent(in) :: level_index public subroutine pf_read_opts (pf, read_cmd, fname) Subroutine to read pfasst options from file and command line\n define the namelist for reading\n set local variables to pf_pfasst defaults\n open the file \"fname\" and read the pfasst namelist\n overwrite parameters defined on  command line\n re-assign the pfasst internals\n  Sanity check Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf logical, intent(in) :: read_cmd character(len=*), intent(in), optional :: fname public subroutine pf_print_options (pf, un_opt, show_mats_opt) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in), optional :: un_opt logical, intent(in), optional :: show_mats_opt public subroutine pf_time_interpolation_matrix (f_nodes, f_nnodes, c_nodes, c_nnodes, tmat) Subroutine to make the matrices for interpolation  between noodes Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: f_nodes (0:f_nnodes-1) quadrature nodes on fine  level integer, intent(in) :: f_nnodes number of nodes on fine level real(kind=pfdp), intent(in) :: c_nodes (0:c_nnodes-1) quadrature nodes on coarse  level integer, intent(in) :: c_nnodes number of nodes on coarse  level real(kind=pfdp), intent(out) :: tmat (0:f_nnodes-1,0:c_nnodes-1) Interpolation matrix to compute public subroutine pf_initialize_results (pf) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf public subroutine pf_dump_results (pf) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf public subroutine pf_destroy_results (pf) Subroutine to destroy the results Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf","tags":"","loc":"module/pf_mod_pfasst.html","title":"pf_mod_pfasst – LibPFASST"},{"text":"Module for providing FFTs based on fftw\n  To use this module, fftw must be installed.\n  This can be done by the libpfasst make system with the comment make fftw3 Uses pf_mod_dtype pf_mod_utils pf_mod_fft_abs Contents Derived Types pf_fft_t Subroutines fft_setup fft_destroy fftf fftb interp_1d interp_2d interp_3d zinterp_1d zinterp_2d zinterp_3d Derived Types type, public, extends( pf_fft_abs_t ) :: pf_fft_t Variables and storage for FFTW Components Type Visibility Attributes Name Initial integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes integer, public :: dim spatial dimension real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size complex(kind=pfdp), public, pointer :: wk_1d (:) complex(kind=pfdp), public, pointer :: wk_2d (:,:) complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) type(c_ptr), public :: ffftw fftw pointers type(c_ptr), public :: ifftw fftw pointers real(kind=pfdp), public :: normfact normalization factor Type-Bound Procedures generic, public :: fft => fft_1d, fft_2d, fft_3d, zfft_1d, zfft_2d, zfft_3d generic, public :: ifft => ifft_1d, ifft_2d, ifft_3d, izfft_1d, izfft_2d, izfft_3d generic, public :: conv => conv_1d, conv_2d, conv_3d generic, public :: zconv => zconv_1d, zconv_2d, zconv_3d generic, public :: get_wk_ptr => get_wk_ptr_1d, get_wk_ptr_2d, get_wk_ptr_3d generic, public :: make_lap => make_lap_1d, make_lap_2d, make_lap_3d generic, public :: make_deriv => make_deriv_1d, make_deriv_2d, make_deriv_3d generic, public :: restrict => restrict_1d, restrict_2d, restrict_3d, zrestrict_1d, zrestrict_2d, zrestrict_3d procedure, public :: fft_setup procedure, public :: fft_destroy procedure, public :: fftf procedure, public :: fftb generic, public :: interp => interp_1d, interp_2d, interp_3d, zinterp_1d, zinterp_2d, zinterp_3d Subroutines public subroutine fft_setup (this, grid_shape, dim, grid_size) Initialize the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) public subroutine fft_destroy (this) Destroy the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine fftf (this) Routine to take foreward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine fftb (this) Routine to take inverse or backward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine interp_1d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:) public subroutine interp_2d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:) public subroutine interp_3d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:,:) public subroutine zinterp_1d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:) complex(kind=pfdp), pointer :: yhat_f (:) public subroutine zinterp_2d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:) complex(kind=pfdp), pointer :: yhat_f (:,:) public subroutine zinterp_3d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:,:) complex(kind=pfdp), pointer :: yhat_f (:,:,:)","tags":"","loc":"module/pf_mod_fftpackage.html","title":"pf_mod_fftpackage – LibPFASST"},{"text":"Verlet type sweeper for 2nd order problems This is intended for Hamiltonian problems of the form q'=p, p'=f(q) or x'=v, x''=f(x) So p is not momentum here, but velocity Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_hamiltonian_p pf_f_eval_p pf_f_comp_p Derived Types pf_verlet_t Subroutines verlet_sweep verlet_initialize verlet_integrate verlet_residual verlet_destroy verlet_spreadq0 verlet_evaluate verlet_evaluate_all Interfaces interface public function pf_hamiltonian_p(this, y, t, level_index) result(H) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Variable real(kind=pfdp), intent(in) :: t Time of solve integer, intent(in) :: level_index Level index Return Value real(kind=pfdp) interface public subroutine pf_f_eval_p(this, y, t, level_index, f) This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_verlet_t Verlet SDC sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq integer, public :: whichQQ = 0 integer, public :: doLU real(kind=pfdp), public :: Htol real(kind=pfdp), public :: H0 real(kind=pfdp), public, ALLOCATABLE :: Qmat (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQmat (:,:) real(kind=pfdp), public, ALLOCATABLE :: Qver (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: Qtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: bvec (:) real(kind=pfdp), public, ALLOCATABLE :: bbarvec (:) real(kind=pfdp), public, allocatable :: dtsdc (:) real(kind=pfdp), public, allocatable :: tsdc (:) logical, public :: iqend class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval RHS function evaluations procedure(pf_f_comp_p), public :: f_comp Implicit solver procedure(pf_hamiltonian_p), public :: hamiltonian Hamiltonian procedure, public :: sweep => verlet_sweep Set the generic functions procedure, public :: initialize => verlet_initialize procedure, public :: evaluate => verlet_evaluate procedure, public :: integrate => verlet_integrate procedure, public :: residual => verlet_residual procedure, public :: spreadq0 => verlet_spreadq0 procedure, public :: evaluate_all => verlet_evaluate_all procedure, public :: destroy => verlet_destroy Subroutines public subroutine verlet_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform one SDC sweep on level level_index and set qend appropriately\n  Assign level pointer\n  Add the integral term Read more… Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine verlet_initialize (this, pf, level_index) Initialize integration matrices\n  Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine verlet_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Integrate (t_n to node)\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags public subroutine verlet_residual (this, pf, level_index, dt, flags) Compute residual (t_n to node)\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags public subroutine verlet_destroy (this, pf, level_index) Destroy Verlet sweeper matrices\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine verlet_spreadq0 (this, pf, level_index, t0, flags, step) Spread the intial data for Verlet sweepers\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine verlet_evaluate (this, pf, level_index, t, m, flags, step) Subroutine to evaluate function value at node m\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine verlet_evaluate_all (this, pf, level_index, t, flags, step) Subroutine to evaluate the function values at all nodes\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"module/pf_mod_verlet.html","title":"pf_mod_verlet – LibPFASST"},{"text":"This module implements fully implicit Magnus method using explicit Picard sweeping Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f_eval_p pf_compute_single_commutators_p pf_compute_omega_p pf_propagate_solution_p Derived Types pf_magpicard_t Subroutines magpicard_sweep magpicard_initialize magpicard_integrate magpicard_evaluate magpicard_evaluate_all magpicard_residual magpicard_spreadq0 magpicard_destroy get_commutator_coefs Interfaces interface public subroutine pf_f_eval_p(this, y, t, level, f) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f interface public subroutine pf_compute_single_commutators_p(this, f) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: f (:,:) interface public subroutine pf_compute_omega_p(this, omega, integrals, f, nodes, qmat, dt, this_node, coefs) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: integrals (:) class( pf_encap_t ), intent(inout) :: f (:,:) real(kind=pfdp), intent(in) :: nodes (:) real(kind=pfdp), intent(in) :: qmat (:,:) real(kind=pfdp), intent(in) :: dt integer, intent(in) :: this_node real(kind=pfdp), intent(in) :: coefs (:,:) interface public subroutine pf_propagate_solution_p(this, sol_t0, sol_tn, omega, level) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: sol_t0 class( pf_encap_t ), intent(inout) :: sol_tn class( pf_encap_t ), intent(inout) :: omega integer, intent(in) :: level Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_magpicard_t Magnus Picard sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: dtsdc (:) integer, public :: magnus_order integer, public :: qtype real(kind=pfdp), public :: dt real(kind=pfdp), public :: commutator_coefs (9,3,4) complex(kind=pfdp), public, allocatable :: commutators (:,:,:) class( pf_encap_t ), public, allocatable :: omega (:) class( pf_encap_t ), public, allocatable :: time_ev_op (:) Type-Bound Procedures procedure, public :: sweep => magpicard_sweep procedure, public :: initialize => magpicard_initialize procedure, public :: evaluate => magpicard_evaluate procedure, public :: integrate => magpicard_integrate procedure, public :: residual => magpicard_residual procedure, public :: spreadq0 => magpicard_spreadq0 procedure, public :: evaluate_all => magpicard_evaluate_all procedure(pf_f_eval_p), public :: f_eval procedure(pf_compute_single_commutators_p), public :: compute_single_commutators procedure(pf_compute_omega_p), public :: compute_omega procedure(pf_propagate_solution_p), public :: propagate_solution procedure, public :: destroy => magpicard_destroy procedure, public :: magpicard_destroy procedure, public :: magpicard_initialize Subroutines public subroutine magpicard_sweep (this, pf, level_index, t0, dt, nsweeps, flags) this loop not OMP'd because the deferred procs are OMP'd Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags public subroutine magpicard_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize public subroutine magpicard_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Compute SDC integral\n  fintSDC = \\int_{t_n}&#94;{t_m} fSDC dt Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine magpicard_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine magpicard_evaluate_all (this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine magpicard_residual (this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine magpicard_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine magpicard_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize public subroutine get_commutator_coefs (qtype, nnodes, dt, coefs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: qtype integer, intent(in) :: nnodes real(kind=pfdp), intent(in) :: dt real(kind=pfdp), intent(inout) :: coefs (:,:,:)","tags":"","loc":"module/pf_mod_magnus_picard.html","title":"pf_mod_magnus_picard – LibPFASST"},{"text":"Module to hold include statement Uses mpi Contents None","tags":"","loc":"module/pf_mod_mpi.html","title":"pf_mod_mpi – LibPFASST"},{"text":"Module to implement communication routines in  MPI. Uses pf_mod_dtype pf_mod_mpi Contents Variables myMPI_Datatype Subroutines pf_mpi_create pf_mpi_setup pf_mpi_destroy pf_mpi_post pf_mpi_send_status pf_mpi_recv_status pf_mpi_send pf_mpi_recv pf_mpi_wait pf_mpi_broadcast Variables Type Visibility Attributes Name Initial integer, public, parameter :: myMPI_Datatype = MPI_REAL8 Subroutines public subroutine pf_mpi_create (pf_comm, mpi_comm) Subroutine to create an MPI based PFASST communicator using the MPI communicator mpi_comm .\n assign communicator Read more… Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(out) :: pf_comm integer, intent(in) :: mpi_comm public subroutine pf_mpi_setup (pf_comm, pf, ierror) Subroutine to set up the PFASST communicator.\n This should be called soon after adding levels to the PFASST controller \n  set the rank Read more… Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(inout) :: pf_comm communicator type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(inout) :: ierror error flag public subroutine pf_mpi_destroy (pf_comm) Subroutine to destroy the PFASST communicator. Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(inout) :: pf_comm public subroutine pf_mpi_post (pf, level, tag, ierror, source) Subroutine to post receive requests. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf class( pf_level_t ), intent(inout) :: level level to send from integer, intent(in) :: tag message tag integer, intent(inout) :: ierror error flag integer, intent(in) :: source public subroutine pf_mpi_send_status (pf, tag, istatus, ierror, dest) Subroutine to send convergence status information Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: tag message tag integer, intent(in) :: istatus status flag to send integer, intent(inout) :: ierror error flag integer, intent(in) :: dest public subroutine pf_mpi_recv_status (pf, tag, istatus, ierror, source) Subroutine to receive convergence status information Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: tag message tag integer, intent(inout) :: istatus status flag to receive integer, intent(inout) :: ierror error flag integer, intent(in) :: source public subroutine pf_mpi_send (pf, level, tag, blocking, ierror, dest) Subroutine to send solutions Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: level level to send from integer, intent(in) :: tag message tag logical, intent(in) :: blocking true if send is blocking integer, intent(inout) :: ierror error flag integer, intent(in) :: dest public subroutine pf_mpi_recv (pf, level, tag, blocking, ierror, source) Subroutine to receive solutions\n Note when blocking == .false. this is actually a wait because the\n nonblocking receive  should have already been posted Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: level level to recieve into integer, intent(in) :: tag message tag logical, intent(in) :: blocking true if receive is blocking integer, intent(inout) :: ierror error flag integer, intent(in) :: source public subroutine pf_mpi_wait (pf, level, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf main pfasst structure integer, intent(in) :: level level on which to wait integer, intent(inout) :: ierror error flag public subroutine pf_mpi_broadcast (pf, y, nvar, root, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure real(kind=pfdp), intent(in) :: y (nvar) data to broadcast integer, intent(in) :: nvar size of data to broadcast integer, intent(in) :: root rank of broadcaster integer, intent(inout) :: ierror error flag","tags":"","loc":"module/pf_mod_comm_mpi.html","title":"pf_mod_comm_mpi – LibPFASST"},{"text":"This module implements fully implicit Munthe-Kaas Runge Kutta methods using explicit SDC sweeping The equation to be solved is y'=A(y,t)y where A is a matrix and (y)\\ is  a vector or matrix or if Lax_pair = true Y'=[A(Y,t),Y] where both A and Y are matrices We solve this by finding the solution to Q' = dexpinv_Q(A) Using PFASST Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f_eval_p pf_dexpinv_p pf_propagate_p pf_commutator_p Derived Types pf_imk_t Subroutines imk_sweep rk_step mkrk_step imk_actually_sweep imk_initialize imk_integrate imk_evaluate imk_evaluate_all imk_residual imk_spreadq0 imk_save imk_destroy Interfaces interface public subroutine pf_f_eval_p(this, y, t, level, f) Subroutine f_eval computes A(y,t) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer(kind=c_int), intent(in) :: level class( pf_encap_t ), intent(inout) :: f interface public subroutine pf_dexpinv_p(this, a, omega, f) Subroutine dexpinv computes Om'=F=dexpinv_Om(A) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: f The result interface public subroutine pf_propagate_p(this, q0, q) Subroutine propagate   computes y_m=expm(Om_m)y_0(expm(Om_m))-1 or (expm(Om_m))y_0 or Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: q0 class( pf_encap_t ), intent(inout) :: q interface public subroutine pf_commutator_p(this, a, b, out, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: b class( pf_encap_t ), intent(inout) :: out integer, intent(in), optional :: flags Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_imk_t Implicit Munthe-Kaas Runge-Kutta sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq class( pf_encap_t ), public, allocatable :: A (:) real(kind=pfdp), public, allocatable :: QtilE (:,:) Aproximate quadrature matric real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: dtsdc (:) SDC substep size real(kind=pfdp), public, allocatable :: tsdc (:) real(kind=pfdp), public :: bernoullis (20) Bernoulli numbers real(kind=pfdp), public :: t0 Time at beginning of time step real(kind=pfdp), public :: dt Time step size integer, public :: qtype integer, public :: nterms logical, public :: Lax_pair logical, public :: use_SDC logical, public :: debug logical, public :: mkrk logical, public :: rk Type-Bound Procedures procedure, public :: sweep => imk_sweep procedure, public :: initialize => imk_initialize procedure, public :: evaluate => imk_evaluate procedure, public :: integrate => imk_integrate procedure, public :: residual => imk_residual procedure, public :: spreadq0 => imk_spreadq0 procedure, public :: evaluate_all => imk_evaluate_all procedure, public :: destroy => imk_destroy procedure(pf_f_eval_p), public :: f_eval procedure(pf_dexpinv_p), public :: dexpinv procedure(pf_propagate_p), public :: propagate procedure(pf_commutator_p), public :: commutator_p Subroutines public subroutine imk_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform nsweep  sweeps on level  and set qend appropriately. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine rk_step (this, pf, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size public subroutine mkrk_step (this, pf, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size public subroutine imk_actually_sweep (this, pf, level_index, t0, dt, nsweeps) Loop over sweeps\n  Loop over substeps\n  Accumulate rhs\n  Add the tau term Read more… Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do public subroutine imk_initialize (this, pf, level_index) Assign explicit approximate quadrature rule\n  Make space for temporary variables Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize public subroutine imk_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine imk_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imk_evaluate_all (this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imk_residual (this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine imk_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imk_save (lev) Save function values so that difference can be computed Arguments Type Intent Optional Attributes Name type( pf_level_t ), intent(inout) :: lev Level to save on public subroutine imk_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to initialize","tags":"","loc":"module/pf_mod_imk.html","title":"pf_mod_imk – LibPFASST"},{"text":"N-dimensional complex array encapsulation. When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'shape' attribute to create a new array with that\n shape.  Thus, the 'shape' attributes of the PFASST levels should be\n set appropriately.  For example, before calling pf_pfasst_run we can\n set the shape of the coarsest level by doing: allocate(pf%levels(1)%shape(2))\n   pf%levels(1)%shape = [ 3, 10 ] The helper routines array1, array2, array3, etc can be used to\n extract pointers to the encapsulated array  without\n performing any copies. Uses iso_c_binding pf_mod_dtype pf_mod_utils Contents Derived Types zndarray_factory zndarray Functions cast_as_zndarray zndarray_norm get_array1d get_array2d get_array3d Subroutines zndarray_build zndarray_destroy zndarray_create_single zndarray_create_array zndarray_destroy_single zndarray_destroy_array zndarray_setval zndarray_copy zndarray_pack zndarray_unpack zndarray_axpy zndarray_eprint write_to_disk Derived Types type, public, extends( pf_factory_t ) :: zndarray_factory Factory for making zndarray Type-Bound Procedures procedure, public :: create_single => zndarray_create_single procedure, public :: create_array => zndarray_create_array procedure, public :: destroy_single => zndarray_destroy_single procedure, public :: destroy_array => zndarray_destroy_array type, public, extends( pf_encap_t ) :: zndarray Complex ndarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) complex(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => zndarray_setval procedure, public :: copy => zndarray_copy procedure, public :: norm => zndarray_norm procedure, public :: pack => zndarray_pack procedure, public :: unpack => zndarray_unpack procedure, public :: axpy => zndarray_axpy procedure, public :: eprint => zndarray_eprint procedure, public :: write_to_disk Functions public function cast_as_zndarray (encap_polymorph) result(zndarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( zndarray ),\n  pointer public function zndarray_norm (this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function get_array1d (x, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:) public function get_array2d (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:,:) public function get_array3d (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine zndarray_build (q, shape) Allocates complex ndarray Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) public subroutine zndarray_destroy (encap) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine zndarray_create_single (this, x, level, shape) Wrapper routine for allocation of a single zndarray type array Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndarray_create_array (this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndarray_destroy_single (this, x) Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x public subroutine zndarray_destroy_array (this, x) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) public subroutine zndarray_setval (this, val, flags) Set solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine zndarray_copy (this, src, flags) Copy solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine zndarray_pack (this, z, flags) Pack solution q into a flat array. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine zndarray_unpack (this, z, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine zndarray_axpy (this, a, x, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine zndarray_eprint (this, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this integer, intent(in), optional :: flags public subroutine write_to_disk (this, filename) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this character(len=*), intent(in) :: filename","tags":"","loc":"module/pf_mod_zndarray.html","title":"pf_mod_zndarray – LibPFASST"},{"text":"Module to define the main parameters, data types, and interfaces in pfasst Uses iso_c_binding Contents Variables pfdp pfqp ZERO ONE TWO THREE HALF ZI Z0 two_pi PF_MAXLEVS PF_MAX_HOOKS SDC_GAUSS_LOBATTO SDC_GAUSS_RADAU SDC_CLENSHAW_CURTIS SDC_UNIFORM SDC_GAUSS_LEGENDRE SDC_CHEBYSHEV PF_STATUS_ITERATING PF_STATUS_CONVERGED PF_STATUS_PREDICTOR Interfaces pf_encap_norm_p pf_hook_p pf_sweep_p pf_evaluate_p pf_evaluate_all_p pf_initialize_p pf_destroy_sweeper_p pf_integrate_p pf_residual_p pf_spreadq0_p pf_destroy_p pf_do_n_steps_p pf_initialize_stepper_p pf_destroy_stepper_p pf_transfer_p pf_encap_create_single_p pf_encap_create_array_p pf_encap_destroy_single_p pf_encap_destroy_array_p pf_encap_setval_p pf_encap_copy_p pf_encap_pack_p pf_encap_unpack_p pf_encap_axpy_p pf_encap_eprint_p pf_post_p pf_recv_p pf_recv_status_p pf_send_p pf_send_status_p pf_wait_p pf_broadcast_p pf_results_p Derived Types pf_state_t pf_hook_t pf_sweeper_t pf_stepper_t pf_encap_t pf_factory_t pf_user_level_t pf_sdcmats_t pf_level_t pf_comm_t pf_results_t pf_pfasst_t Variables Type Visibility Attributes Name Initial integer, public, parameter :: pfdp = selected_real_kind(15, 307) pfasst static  paramters\n  Defines double precision type for all real and complex variables integer, public, parameter :: pfqp = selected_real_kind(33, 4931) Defines quad precision type for all real and complex variables real(kind=pfdp), public, parameter :: ZERO = 0.0_pfdp real(kind=pfdp), public, parameter :: ONE = 1.0_pfdp real(kind=pfdp), public, parameter :: TWO = 2.0_pfdp real(kind=pfdp), public, parameter :: THREE = 3.0_pfdp real(kind=pfdp), public, parameter :: HALF = 0.5_pfdp complex(kind=pfdp), public, parameter :: ZI = cmplx(0.0, 1.0, pfdp) complex(kind=pfdp), public, parameter :: Z0 = cmplx(0.0, 0.0, pfdp) real(kind=pfdp), public, parameter :: two_pi = 6.2831853071795862_pfdp integer, public, parameter :: PF_MAXLEVS = 4 integer, public, parameter :: PF_MAX_HOOKS = 32 integer, public, parameter :: SDC_GAUSS_LOBATTO = 1 Quadrature node varieties integer, public, parameter :: SDC_GAUSS_RADAU = 2 integer, public, parameter :: SDC_CLENSHAW_CURTIS = 3 integer, public, parameter :: SDC_UNIFORM = 4 integer, public, parameter :: SDC_GAUSS_LEGENDRE = 5 integer, public, parameter :: SDC_CHEBYSHEV = 6 integer, public, parameter :: PF_STATUS_ITERATING = 1 States of operation integer, public, parameter :: PF_STATUS_CONVERGED = 2 integer, public, parameter :: PF_STATUS_PREDICTOR = 3 Interfaces interface Interfaces for subroutines public function pf_encap_norm_p(this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) interface Interfaces for subroutines public subroutine pf_hook_p(pf, level_index) hooks subroutines Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index interface Interfaces for subroutines public subroutine pf_sweep_p(this, pf, level_index, t0, dt, nsweeps, flags) SDC sweeper subroutines Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_evaluate_p(this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step interface Interfaces for subroutines public subroutine pf_evaluate_all_p(this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step interface Interfaces for subroutines public subroutine pf_initialize_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index interface Interfaces for subroutines public subroutine pf_destroy_sweeper_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index interface Interfaces for subroutines public subroutine pf_integrate_p(this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt Time step size class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_residual_p(this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt Time step size integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_spreadq0_p(this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step interface Interfaces for subroutines public subroutine pf_destroy_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index interface Interfaces for subroutines public subroutine pf_do_n_steps_p(this, pf, level_index, t0, q0, qend, big_dt, nsteps_rk) time stepper interfaces Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 class( pf_encap_t ), intent(in) :: q0 Starting value class( pf_encap_t ), intent(inout) :: qend Final value real(kind=pfdp), intent(in) :: big_dt Time step size integer, intent(in) :: nsteps_rk interface Interfaces for subroutines public subroutine pf_initialize_stepper_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index interface Interfaces for subroutines public subroutine pf_destroy_stepper_p(this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index interface Interfaces for subroutines public subroutine pf_transfer_p(this, f_lev, c_lev, f_vec, c_vec, t, flags) transfer interfaces used for restriction and interpolation Arguments Type Intent Optional Attributes Name class( pf_user_level_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: f_lev class( pf_level_t ), intent(inout) :: c_lev class( pf_encap_t ), intent(inout) :: f_vec class( pf_encap_t ), intent(inout) :: c_vec real(kind=pfdp), intent(in) :: t integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_create_single_p(this, x, level, shape) encapsulation interfaces Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) interface Interfaces for subroutines public subroutine pf_encap_create_array_p(this, x, n, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) interface Interfaces for subroutines public subroutine pf_encap_destroy_single_p(this, x) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x interface Interfaces for subroutines public subroutine pf_encap_destroy_array_p(this, x) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) interface Interfaces for subroutines public subroutine pf_encap_setval_p(this, val, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_copy_p(this, src, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_pack_p(this, z, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_unpack_p(this, z, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_axpy_p(this, a, x, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_eprint_p(this, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_post_p(pf, level, tag, ierror, source) communicator interfaces Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag integer, intent(inout) :: ierror integer, intent(in) :: source interface Interfaces for subroutines public subroutine pf_recv_p(pf, level, tag, blocking, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(inout) :: ierror integer, intent(in) :: source interface Interfaces for subroutines public subroutine pf_recv_status_p(pf, tag, istatus, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: tag integer, intent(inout) :: istatus integer, intent(inout) :: ierror integer, intent(in) :: source interface Interfaces for subroutines public subroutine pf_send_p(pf, level, tag, blocking, ierror, dest) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(inout) :: ierror integer, intent(in) :: dest interface Interfaces for subroutines public subroutine pf_send_status_p(pf, tag, istatus, ierror, dest) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in) :: istatus integer, intent(inout) :: ierror integer, intent(in) :: dest interface Interfaces for subroutines public subroutine pf_wait_p(pf, level, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf integer, intent(in) :: level integer, intent(inout) :: ierror interface Interfaces for subroutines public subroutine pf_broadcast_p(pf, y, nvar, root, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf real(kind=pfdp), intent(in) :: y (nvar) integer, intent(in) :: nvar integer, intent(in) :: root integer, intent(inout) :: ierror interface Interfaces for subroutines public subroutine pf_results_p(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this Derived Types type, public, bind(c) :: pf_state_t The type that holds the state of the system Components Type Visibility Attributes Name Initial real(kind=pfdp), public :: t0 Time at beginning of this time step real(kind=pfdp), public :: dt Time step size integer, public :: nsteps total number of time steps integer, public :: pfblock pfasst block being worked on integer, public :: iter current iteration number integer, public :: step current time step number assigned to processor integer, public :: level which level is currently being operated on integer, public :: finest_level the current finest level (for variable depth V cycles) integer, public :: hook which hook integer, public :: proc which processor integer, public :: sweep sweep number integer, public :: status status (iterating, converged etc) integer, public :: pstatus previous rank's status integer, public :: itcnt total iterations by this processor integer, public :: skippedy skipped sweeps for state (for mixed integration) integer, public :: mysteps steps I did type, public :: pf_hook_t Abstract hook type: hooks call diagnostic routines from various places in code Components Type Visibility Attributes Name Initial procedure( pf_hook_p ), public, pointer, nopass :: proc type, public, abstract :: pf_sweeper_t The abstract SDC sweeper type (must be extended) Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq Type-Bound Procedures procedure(pf_sweep_p), public :: sweep procedure(pf_initialize_p), public :: initialize procedure(pf_evaluate_p), public :: evaluate procedure(pf_integrate_p), public :: integrate procedure(pf_evaluate_all_p), public :: evaluate_all procedure(pf_residual_p), public :: residual procedure(pf_spreadq0_p), public :: spreadq0 procedure(pf_destroy_sweeper_p), public :: destroy type, public, abstract :: pf_stepper_t The abstract time stepper type (must be extended) Components Type Visibility Attributes Name Initial integer, public :: npieces integer, public :: order integer, public :: nsteps Type-Bound Procedures procedure(pf_do_n_steps_p), public :: do_n_steps procedure(pf_initialize_stepper_p), public :: initialize procedure(pf_destroy_stepper_p), public :: destroy type, public, abstract :: pf_encap_t The abstract data type of the solution (must be extended) Type-Bound Procedures procedure(pf_encap_setval_p), public :: setval procedure(pf_encap_copy_p), public :: copy procedure(pf_encap_norm_p), public :: norm procedure(pf_encap_pack_p), public :: pack procedure(pf_encap_unpack_p), public :: unpack procedure(pf_encap_axpy_p), public :: axpy procedure(pf_encap_eprint_p), public :: eprint type, public, abstract :: pf_factory_t Abstract type for creation and destruction of objects Type-Bound Procedures procedure(pf_encap_create_single_p), public :: create_single procedure(pf_encap_create_array_p), public :: create_array procedure(pf_encap_destroy_single_p), public :: destroy_single procedure(pf_encap_destroy_array_p), public :: destroy_array type, public, abstract :: pf_user_level_t The absract definition of level which is inherited  to include problem dependent stuff Components Type Visibility Attributes Name Initial class( pf_factory_t ), public, allocatable :: factory class( pf_sweeper_t ), public, allocatable :: sweeper class( pf_stepper_t ), public, allocatable :: stepper Type-Bound Procedures procedure(pf_transfer_p), public :: restrict procedure(pf_transfer_p), public :: interpolate type, public :: pf_sdcmats_t The type to store quadrature matrices Components Type Visibility Attributes Name Initial integer, public :: nnodes integer, public :: qtype real(kind=pfdp), public, allocatable :: qnodes (:) real(kind=pfdp), public, allocatable :: Qmat (:,:) real(kind=pfdp), public, allocatable :: QmatFE (:,:) real(kind=pfdp), public, allocatable :: QmatBE (:,:) real(kind=pfdp), public, allocatable :: QmatTrap (:,:) real(kind=pfdp), public, allocatable :: QmatVer (:,:) real(kind=pfdp), public, allocatable :: QmatLU (:,:) real(kind=pfdp), public, allocatable :: Smat (:,:) logical, public :: use_proper_nodes = .false. logical, public :: use_composite_nodes = .false. logical, public :: use_no_left_q = .false. type, public :: pf_level_t Data type of a PFASST level Components Type Visibility Attributes Name Initial integer, public :: mpibuflen = -1 size of solution in pfdp units integer, public :: index = -1 level number (1 is the coarsest) integer, public :: nnodes = -1 number of sdc nodes integer, public :: nsteps_rk = -1 number of rk steps to perform integer, public :: nsweeps = -1 number of sdc sweeps to perform integer, public :: nsweeps_pred = -1 number of coarse sdc sweeps to perform predictor in predictor logical, public :: Finterp = .false. interpolate functions instead of solutions real(kind=pfdp), public :: error holds the user defined error real(kind=pfdp), public :: residual holds the user defined residual real(kind=pfdp), public :: residual_rel holds the user defined relative residual (scaled by solution magnitude) class( pf_user_level_t ), public, allocatable :: ulevel user customized level info real(kind=pfdp), public, allocatable :: send (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: recv (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: nodes (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: rmat (:,:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: tmat (:,:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix integer, public, allocatable :: nflags (:) sdc node flags class( pf_encap_t ), public, allocatable :: Q (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: pQ (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: R (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: I (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: Fflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: Frkflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: tauQ (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: pFflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: q0 Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: q0_delta Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, allocatable :: qend Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n  Stage Function values\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition\n Space for interpolating q0, qend\n solution at end time class( pf_encap_t ), public, pointer :: F (:,:) Function  storage\n functions values at sdc nodes\n functions at sdc nodes, previous sweep class( pf_encap_t ), public, pointer :: pF (:,:) Function  storage\n functions values at sdc nodes\n functions at sdc nodes, previous sweep logical, public :: interp_workspace_allocated = .false. Interpolation and restriction data structures class( pf_encap_t ), public, allocatable :: cf_delta (:) class( pf_encap_t ), public, allocatable :: c_delta (:) integer, public, allocatable :: shape (:) user defined shape array type( pf_sdcmats_t ), public, allocatable :: sdcmats logical, public :: allocated = .false. type, public :: pf_comm_t Data type to define the communicator Components Type Visibility Attributes Name Initial integer, public :: nproc = -1 integer, public :: comm = -1 integer, public, pointer :: recvreq (:) integer, public, pointer :: sendreq (:) integer, public :: statreq procedure( pf_post_p ), public, pointer, nopass :: post Procedure interfaces procedure( pf_recv_p ), public, pointer, nopass :: recv procedure( pf_recv_status_p ), public, pointer, nopass :: recv_status procedure( pf_send_p ), public, pointer, nopass :: send procedure( pf_send_status_p ), public, pointer, nopass :: send_status procedure( pf_wait_p ), public, pointer, nopass :: wait procedure( pf_broadcast_p ), public, pointer, nopass :: broadcast type, public :: pf_results_t Type for storing results for later output Components Type Visibility Attributes Name Initial real(kind=pfdp), public, allocatable :: errors (:,:,:) real(kind=pfdp), public, allocatable :: residuals (:,:,:) integer, public :: nsteps integer, public :: niters integer, public :: nprocs integer, public :: p_index integer, public :: nblocks integer, public :: nsweeps integer, public :: rank integer, public :: level character(len=128), public :: datpath procedure( pf_results_p ), public, pointer, nopass :: destroy type, public :: pf_pfasst_t The main PFASST data type which includes pretty much everythingl Components Type Visibility Attributes Name Initial integer, public :: nlevels = -1 === Mandatory pfasst parameters (must be set on command line or input file)  ===\n number of pfasst levels integer, public :: niters = 5 ===  Optional pfasst parameters ====\n number of PFASST iterations to do integer, public :: qtype = SDC_GAUSS_LOBATTO type of nodes logical, public :: use_proper_nodes = .false. logical, public :: use_composite_nodes = .false. logical, public :: use_no_left_q = .false. integer, public :: nsweeps (PF_MAXLEVS) = 1 number of sweeps at each levels integer, public :: nsweeps_pred (PF_MAXLEVS) = 1 number of sweeps during predictor integer, public :: nnodes (PF_MAXLEVS) = 3 number of nodes real(kind=pfdp), public :: abs_res_tol = 0.d0 absolute convergence tolerance real(kind=pfdp), public :: rel_res_tol = 0.d0 relative convergence tolerance logical, public :: PFASST_pred = .true. true if the PFASST type predictor is used logical, public :: pipeline_pred = .false. true if coarse sweeps after burn in are pipelined  (if nsweeps_pred>1 on coarse level) integer, public :: nsweeps_burn = 1 number of sdc sweeps to perform during coarse level burn in integer, public :: q0_style = 0 q0 can take 3 values\n  0:  Only the q0 at t=0 is valid  (default)\n  1:  The q0 at each processor is valid\n  2:  q0 and all nodes at each processor is valid logical, public :: Vcycle = .true. decides if Vcycles are done logical, public :: Finterp = .false. True if transfer functions operate on rhs logical, public :: use_LUq = .true. True if LU type implicit matrix is used logical, public :: use_Sform = .false. True if Qmat type of stepping is used integer, public :: taui0 = -999999 iteration cutoff for tau inclusion logical, public :: use_rk_stepper = .false. decides if RK steps are used instead of the sweeps integer, public :: nsteps_rk (PF_MAXLEVS) = 3 number of runge-kutta steps per time step logical, public :: RK_pred = .false. true if the coarse level is initialized with Runge-Kutta instead of PFASST logical, public :: debug = .false. If true, debug diagnostics are printed logical, public :: save_residuals = .false. If true, residuals are saved and output logical, public :: save_timings = .false. If true, timings are saved and  output logical, public :: echo_timings = .false. If true, timings are  output to screen logical, public :: save_errors = .false. If true, errors  are saved and output integer, public :: rank = -1 rank of current processor type( pf_state_t ), public, allocatable :: state pf objects\n  Describes where in the algorithm proc is type( pf_level_t ), public, allocatable :: levels (:) Holds the levels type( pf_comm_t ), public, pointer :: comm Points to communicator type( pf_results_t ), public, allocatable :: results (:) Hold results for each level type( pf_hook_t ), public, allocatable :: hooks (:,:,:) hooks variables\n  Holds the hooks integer, public, allocatable :: nhooks (:,:) Holds the number hooks double precision, public :: timers (100) = 0.0d0 timing variables double precision, public :: runtimes (100) = 0.0d0 character(len=256), public :: outdir output directory","tags":"","loc":"module/pf_mod_dtype.html","title":"pf_mod_dtype – LibPFASST"},{"text":"System of complex N-dimensional arrays encapsulation. When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'arr_shape' attribute to create a new multi-component array with that\n shape.  Thus, the 'arr_shape' attributes of the PFASST levels should be\n set appropriately.  The last component of arr_shape is the number of components in the system For example, before calling pf_pfasst_run we can\n set the arr_shape of the coarsest level by doing: allocate(pf%levels(1)%arr_shape(3))\n   pf%levels(1)%arr_shape = [ nx, ny, 3 ] Which would imply that a 3 component system of two-dimensional solutions. The helper routines array1, array2, array3, etc can be used to\n extract pointers to a component of  encapsulated system\n performing any copies. Uses iso_c_binding pf_mod_dtype Contents Interfaces zndsysarray_dump_numpy Derived Types zndsysarray_factory zndsysarray Functions zndsysarray_norm cast_as_zndsysarray get_array1d get_array2d get_array3d Subroutines zndsysarray_build zndsysarray_create_single zndsysarray_create_array zndsysarray_destroy zndsysarray_destroy_single zndsysarray_destroy_array zndsysarray_setval zndsysarray_copy zndsysarray_pack zndsysarray_unpack zndsysarray_axpy zndsysarray_eprint Interfaces interface Interfaces to output routines in pf_numpy.c public subroutine zndsysarray_dump_numpy(dname, fname, endian, dim, mpibuflen, arr_shape, array) bind(c) Subroutine to write an the array to a file Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: arr_shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Derived Types type, public, extends( pf_factory_t ) :: zndsysarray_factory Type to create and destroy the arrays Type-Bound Procedures procedure, public :: create_single => zndsysarray_create_single procedure, public :: create_array => zndsysarray_create_array procedure, public :: destroy_single => zndsysarray_destroy_single procedure, public :: destroy_array => zndsysarray_destroy_array type, public, extends( pf_encap_t ) :: zndsysarray Type to extend the abstract encap and set procedure pointers Components Type Visibility Attributes Name Initial integer, public :: dim integer, public :: ncomp integer, public :: ndof integer, public, allocatable :: arr_shape (:) complex(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => zndsysarray_setval procedure, public :: copy => zndsysarray_copy procedure, public :: norm => zndsysarray_norm procedure, public :: pack => zndsysarray_pack procedure, public :: unpack => zndsysarray_unpack procedure, public :: axpy => zndsysarray_axpy procedure, public :: eprint => zndsysarray_eprint Functions public function zndsysarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function cast_as_zndsysarray (encap_polymorph) result(zndsysarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( zndsysarray ),\n  pointer public function get_array1d (x, n, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:) public function get_array2d (x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:,:) public function get_array3d (x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine zndsysarray_build (q, arr_shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: arr_shape (:) public subroutine zndsysarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndsysarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndsysarray_destroy (encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine zndsysarray_destroy_single (this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x public subroutine zndsysarray_destroy_array (this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) public subroutine zndsysarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine zndsysarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine zndsysarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine zndsysarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine zndsysarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine zndsysarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_zndsysarray.html","title":"pf_mod_zndsysarray – LibPFASST"},{"text":"Module with useful subroutines that don't  fit in other modules\n$  subroutine exact_kdv_2dz(t, uex,beta,Lx)\n$    real(pfdp), intent(in)  :: t\n$    complex(pfdp), intent(inout) :: uex(:,:)\n$    real(pfdp), intent(in) :: Lx(2)\n$ $    integer    :: nx,ny, i,j\n$    real(pfdp) :: x, y,L\n$ $    nx = size(uex,1)\n$    ny = size(uex,2)\n$    L=0.5_pfdp (Lx(1)+Lx(2))\n$    do j = 1, ny\n$       y = Lx(2) real(j-1,pfdp)/real(ny,pfdp)\n$       do i = 1, nx\n$          x = Lx(1) real(i-1,pfdp)/real(nx,pfdp) \n$          uex(i,j) = kdv_ex(2.0_pfdp t,x+y,L)\n$       end do\n$    end do\n$ $  end subroutine exact_kdv_2dz\n$ $  subroutine exact_kdv_3dz(t, uex,Lx)\n$    real(pfdp), intent(in)  :: t\n$    complex(pfdp), intent(inout) :: uex(:,:,:)\n$    real(pfdp), intent(in) :: Lx(3)\n$ $    integer    :: nx,ny,nz, i,j,k\n$    real(pfdp) :: x, y,z,L\n$ $    nx = size(uex,1)\n$    ny = size(uex,2) $    nz = size(uex,3) $    L=(Lx(1)+Lx(2)+Lx(3))/3.0_pfdp\n$    do k = 1, nz\n$       z = Lx(3) real(k-1,pfdp)/real(nz,pfdp) \n$       do j = 1, ny\n$          y = Lx(2) real(j-1,pfdp)/real(ny,pfdp)\n$          do i = 1, nx\n$             x = Lx(1) real(i-1,pfdp)/real(nx,pfdp) \n$             uex(i,j,k) = kdv_ex(3.0_pfdp t,x+y+z,L)\n$          end do\n$       end do\n$    end do\n$\n$  end subroutine exact_kdv_3dz\n$ Uses pf_mod_dtype Contents Interfaces exact_ad_cos exact_ad_exp exact_burg_sin exact_nls exact_kdv Functions ad_cos_ex ad_exp_ex burg_sin_ex nls_ex kdv_ex Subroutines exact_ad_cos_1d exact_ad_cos_1dz exact_ad_cos_2d exact_ad_cos_2dz exact_ad_cos_3d exact_ad_cos_3dz exact_ad_exp_1d exact_ad_exp_1dz exact_ad_exp_2d exact_ad_exp_2dz exact_ad_exp_3d exact_ad_exp_3dz exact_burg_sin_1d exact_burg_sin_1dz exact_burg_sin_2d exact_burg_sin_2dz exact_burg_sin_3d exact_burg_sin_3dz exact_nls_1dz exact_nls_2dz exact_nls_3dz exact_kdv_1dz exact_kdv_1d Interfaces public interface exact_ad_cos public subroutine exact_ad_cos_1d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_cos_1dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_cos_2d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: kfreq (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_cos_2dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: kfreq (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_cos_3d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: kfreq (3) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_ad_cos_3dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: kfreq (3) real(kind=pfdp), intent(in) :: Lx (3) public interface exact_ad_exp public subroutine exact_ad_exp_1d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_exp_1dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_exp_2d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_exp_2dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_exp_3d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_ad_exp_3dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: Lx (3) public interface exact_burg_sin public subroutine exact_burg_sin_1d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx public subroutine exact_burg_sin_1dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx public subroutine exact_burg_sin_2d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_burg_sin_2dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_burg_sin_3d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_burg_sin_3dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (3) public interface exact_nls public subroutine exact_nls_1dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: Lx public subroutine exact_nls_2dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_nls_3dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: Lx (3) public interface exact_kdv public subroutine exact_kdv_1d (t, uex, beta, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx public subroutine exact_kdv_1dz (t, uex, beta, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx Functions public function ad_cos_ex (t, x, nu, v, kfreq, Lx) result(u) Routine to return the exact solution for advection diffusion\n Routine to return the exact solution for advection diffusion Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx Return Value real(kind=pfdp) public function ad_exp_ex (t, x, nu, v, Lx) result(u) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx Return Value real(kind=pfdp) public function burg_sin_ex (t, x, nu, Lx) result(u) Routine to return the exact solution for inviscid Burgers based on Platzman\nSee \"A Simple Illustration of a Weak Spectral Cascade\", Muraki D,SIAM J Appl Math,2007 Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx Return Value real(kind=pfdp) public function nls_ex (t, x, Lx) result(u) Routine to return the exact solution for the nonlinear Schoedinger Eq  u_t=i2}u|&#94;2u +i u_xx\nSee Tuncay Aktosun et al 2007 Inverse Problems 23 217\n  Note the domain size should be 2*pi Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: Lx Return Value complex(kind=pfdp) public function kdv_ex (t, x, beta, Lx) result(u) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: x real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx Return Value real(kind=pfdp) Subroutines public subroutine exact_ad_cos_1d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_cos_1dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: kfreq real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_cos_2d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: kfreq (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_cos_2dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: kfreq (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_cos_3d (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: kfreq (3) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_ad_cos_3dz (t, uex, nu, v, kfreq, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: kfreq (3) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_ad_exp_1d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_exp_1dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v real(kind=pfdp), intent(in) :: Lx public subroutine exact_ad_exp_2d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_exp_2dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (2) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_ad_exp_3d (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_ad_exp_3dz (t, uex, nu, v, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: v (3) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_burg_sin_1d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx public subroutine exact_burg_sin_1dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx public subroutine exact_burg_sin_2d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_burg_sin_2dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_burg_sin_3d (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_burg_sin_3dz (t, uex, nu, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: nu real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_nls_1dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: Lx public subroutine exact_nls_2dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:) real(kind=pfdp), intent(in) :: Lx (2) public subroutine exact_nls_3dz (t, uex, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:,:,:) real(kind=pfdp), intent(in) :: Lx (3) public subroutine exact_kdv_1dz (t, uex, beta, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t complex(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx public subroutine exact_kdv_1d (t, uex, beta, Lx) Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(inout) :: uex (:) real(kind=pfdp), intent(in) :: beta real(kind=pfdp), intent(in) :: Lx","tags":"","loc":"module/pf_mod_solutions.html","title":"pf_mod_solutions – LibPFASST"},{"text":"System of N-dimensional arrays encapsulation. When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'arr_shape' attribute to create a new multi-component array with that\n shape.  Thus, the 'arr_shape' attributes of the PFASST levels should be\n set appropriately.  The last component of arr_shape is the number of components in the system For example, before calling pf_pfasst_run we can\n set the arr_shape of the coarsest level by doing: allocate(pf%levels(1)%arr_shape(3))\n   pf%levels(1)%arr_shape = [ nx, ny, 3 ] Which would imply that a 3 component system of two-dimensional solutions. The helper routines array1, array2, array3, etc can be used to\n extract pointers to a component of  encapsulated system\n performing any copies. $ Uses iso_c_binding pf_mod_dtype Contents Interfaces ndsysarray_dump_numpy Derived Types ndsysarray_factory ndsysarray Functions ndsysarray_norm cast_as_ndsysarray get_array1d get_array2d get_array3d Subroutines ndsysarray_build ndsysarray_create_single ndsysarray_create_array ndsysarray_destroy ndsysarray_destroy_single ndsysarray_destroy_array ndsysarray_setval ndsysarray_copy ndsysarray_pack ndsysarray_unpack ndsysarray_axpy ndsysarray_eprint Interfaces interface Interfaces to output routines in pf_numpy.c public subroutine ndsysarray_dump_numpy(dname, fname, endian, dim, mpibuflen, arr_shape, array) bind(c) Subroutine to write an the array to a file Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: arr_shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Derived Types type, public, extends( pf_factory_t ) :: ndsysarray_factory Type to create and destroy systems of N-dimensional arrays Type-Bound Procedures procedure, public :: create_single => ndsysarray_create_single procedure, public :: create_array => ndsysarray_create_array procedure, public :: destroy_single => ndsysarray_destroy_single procedure, public :: destroy_array => ndsysarray_destroy_array type, public, extends( pf_encap_t ) :: ndsysarray Type for system of  N-dimensional arrays,  extends the abstract encap type Components Type Visibility Attributes Name Initial integer, public :: dim integer, public :: ncomp integer, public :: ndof integer, public, allocatable :: arr_shape (:) real(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => ndsysarray_setval procedure, public :: copy => ndsysarray_copy procedure, public :: norm => ndsysarray_norm procedure, public :: pack => ndsysarray_pack procedure, public :: unpack => ndsysarray_unpack procedure, public :: axpy => ndsysarray_axpy procedure, public :: eprint => ndsysarray_eprint Functions public function ndsysarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function cast_as_ndsysarray (encap_polymorph) result(ndsysarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndsysarray ),\n  pointer public function get_array1d (x, n, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:) public function get_array2d (x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:) public function get_array3d (x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine ndsysarray_build (q, arr_shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: arr_shape (:) public subroutine ndsysarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndsysarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndsysarray_destroy (encap) Subroutine to destroy array (simple) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine ndsysarray_destroy_single (this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x public subroutine ndsysarray_destroy_array (this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) public subroutine ndsysarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine ndsysarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine ndsysarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine ndsysarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine ndsysarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine ndsysarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_ndsysarray.html","title":"pf_mod_ndsysarray – LibPFASST"},{"text":"Module to do imex SDC sweeps in the optimal control setting Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_imexQ_oc_t Subroutines imexQ_oc_sweep imexQ_oc_evaluate imexQ_oc_evaluate_all imexQ_oc_initialize imexQ_oc_integrate imexQ_oc_residual imexQ_oc_spreadq0 imexQ_oc_destroy Interfaces interface This is the interface for the routine to compute the RHS function values public subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Evaluae f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags integer, intent(in), optional :: idx integer, intent(in), optional :: step interface This is the interface for the routine to compute the RHS function values public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_imexQ_oc_t IMEX SDC sweeper type for optimal control, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QtilE (:,:) Approximate explcit quadrature rule real(kind=pfdp), public, allocatable :: QtilI (:,:) Approximate implcit quadrature rule real(kind=pfdp), public, allocatable :: dtsdc (:) SDC step sizes real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: QdiffI (:,:) qmat-QtilI logical, public :: explicit = .true. Is there an explicit piece logical, public :: implicit = .true. Is there an implicit piece class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval RHS function evaluations procedure(pf_f_comp_p), public :: f_comp Implicit solver procedure, public :: sweep => imexQ_oc_sweep Set the generic functions procedure, public :: initialize => imexQ_oc_initialize procedure, public :: evaluate => imexQ_oc_evaluate procedure, public :: integrate => imexQ_oc_integrate procedure, public :: residual => imexQ_oc_residual procedure, public :: evaluate_all => imexQ_oc_evaluate_all procedure, public :: spreadq0 => imexQ_oc_spreadq0 procedure, public :: destroy => imexQ_oc_destroy procedure, public :: imexQ_oc_destroy procedure, public :: imexQ_oc_initialize Subroutines public subroutine imexQ_oc_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Loop over sweeps Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level this is real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine imexQ_oc_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imexQ_oc_evaluate_all (this, pf, level_index, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imexQ_oc_initialize (this, pf, level_index) Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine imexQ_oc_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine imexQ_oc_residual (this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine imexQ_oc_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imexQ_oc_destroy (this, pf, level_index) Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index","tags":"","loc":"module/pf_mod_imexq_oc.html","title":"pf_mod_imexQ_oc – LibPFASST"},{"text":"Module for using fftpack Uses pf_mod_dtype pf_mod_utils pf_mod_fft_abs Contents Derived Types pf_fft_t Subroutines fft_setup fft_destroy fftf fftb interp_1d interp_2d interp_3d zinterp_1d zinterp_2d zinterp_3d Derived Types type, public, extends( pf_fft_abs_t ) :: pf_fft_t Variables and storage for FFT Components Type Visibility Attributes Name Initial integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes integer, public :: dim spatial dimension real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size complex(kind=pfdp), public, pointer :: wk_1d (:) complex(kind=pfdp), public, pointer :: wk_2d (:,:) complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) integer, public :: lensavx workspace lengths integer, public :: lensavy workspace lengths integer, public :: lensavz workspace lengths real(kind=pfdp), public :: normfact normalization factor real(kind=pfdp), public, allocatable :: wsavex (:) real(kind=pfdp), public, allocatable :: wsavey (:) real(kind=pfdp), public, allocatable :: wsavez (:) complex(kind=pfdp), public, pointer :: workhatx (:) complex(kind=pfdp), public, pointer :: workhaty (:) complex(kind=pfdp), public, pointer :: workhatz (:) Type-Bound Procedures generic, public :: fft => fft_1d, fft_2d, fft_3d, zfft_1d, zfft_2d, zfft_3d generic, public :: ifft => ifft_1d, ifft_2d, ifft_3d, izfft_1d, izfft_2d, izfft_3d generic, public :: conv => conv_1d, conv_2d, conv_3d generic, public :: zconv => zconv_1d, zconv_2d, zconv_3d generic, public :: get_wk_ptr => get_wk_ptr_1d, get_wk_ptr_2d, get_wk_ptr_3d generic, public :: make_lap => make_lap_1d, make_lap_2d, make_lap_3d generic, public :: make_deriv => make_deriv_1d, make_deriv_2d, make_deriv_3d generic, public :: restrict => restrict_1d, restrict_2d, restrict_3d, zrestrict_1d, zrestrict_2d, zrestrict_3d procedure, public :: fft_setup procedure, public :: fft_destroy procedure, public :: fftf procedure, public :: fftb generic, public :: interp => interp_1d, interp_2d, interp_3d, zinterp_1d, zinterp_2d, zinterp_3d Subroutines public subroutine fft_setup (this, grid_shape, dim, grid_size) Allocate and initialize FFT structure Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) public subroutine fft_destroy (this) Deallocate and destroy fft structures Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine fftf (this) Forward fft call Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine fftb (this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine interp_1d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:) public subroutine interp_2d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:) public subroutine interp_3d (this, yvec_c, fft_f, yvec_f) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this real(kind=pfdp), intent(inout), pointer :: yvec_c (:,:,:) type( pf_fft_t ), intent(in), pointer :: fft_f real(kind=pfdp), intent(inout), pointer :: yvec_f (:,:,:) public subroutine zinterp_1d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:) complex(kind=pfdp), pointer :: yhat_f (:) public subroutine zinterp_2d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:) complex(kind=pfdp), pointer :: yhat_f (:,:) public subroutine zinterp_3d (this, yhat_c, yhat_f) Interpolate from coarse  level to fine Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), pointer :: yhat_c (:,:,:) complex(kind=pfdp), pointer :: yhat_f (:,:,:)","tags":"","loc":"module/pf_mod_fftpackage~2.html","title":"pf_mod_fftpackage – LibPFASST"},{"text":"Module with useful subroutines that don't  fit in other modules Uses pf_mod_dtype pf_mod_timer Contents Subroutines pf_residual pf_generic_residual pf_echo_residual pf_set_resid pf_set_error pf_generic_evaluate_all pf_generic_spreadq0 pf_stop pf_apply_mat pf_apply_mat_backward Subroutines public subroutine pf_residual (pf, level_index, dt, flag) Compute full residual at each node and measure its size Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flag public subroutine pf_generic_residual (this, pf, level_index, dt, flags) Generic residual\n Each sweeper can define its own residual, or use this generic one\n This routine is in the \"Q\" form, so the residual approximates\n R(m)=y(t_n) + \\int_{t_n}&#94;t_m f(y,s) ds - y(t_m)\n  Compute the integral of F from t_n to t_m at each node Read more… Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine pf_echo_residual (pf, level_index) Output the current residual in the solution Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index public subroutine pf_set_resid (pf, level_index, resid) Subroutine to store a residual value Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: resid public subroutine pf_set_error (pf, level_index, error) Subroutine to store a residual value Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: error public subroutine pf_generic_evaluate_all (this, pf, level_index, t, flags, step) Generic evaluate all\n Each sweeper can define its own evaluate_all or use this generic one\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine pf_generic_spreadq0 (this, pf, level_index, t0) Generic routine to spread initial conditions\n Each sweeper can define its own spreadq0 or use this generic one\n  Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index level on which to sweep real(kind=pfdp), intent(in) :: t0 time at beginning of interval public subroutine pf_stop (pf_file, Nline, msg, N) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: pf_file integer, intent(in) :: Nline character(len=*), intent(in) :: msg integer, intent(in), optional :: N public subroutine pf_apply_mat (dst, a, mat, src, zero_first, flags) Apply a matrix (tmat or rmat) to src and add to dst.\n Mathematically this is \n     dst= dst + a mat src\n  Where dst and src are vectors, mat is a matrix, and a is a scalar\n  If the optional variable \"zero\" is provided and is true, then we compute\n     dst=  a mat src Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: dst (:) destination vector real(kind=pfdp), intent(in) :: a scalar real(kind=pfdp), intent(in) :: mat (:,:) matrix class( pf_encap_t ), intent(in) :: src (:) src vector logical, intent(in), optional :: zero_first If true, zero out the the dst variable before computing integer, intent(in), optional :: flags Used for choosing which variable to operate on Read more… public subroutine pf_apply_mat_backward (dst, a, mat, src, zero_first, flags) Apply a matrix (tmat or rmat) to src and add to dst. Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: dst (:) destination vector real(kind=pfdp), intent(in) :: a scalar real(kind=pfdp), intent(in) :: mat (:,:) matrix class( pf_encap_t ), intent(in) :: src (:) src vector logical, intent(in), optional :: zero_first If true, zero out the the dst variable before computing integer, intent(in), optional :: flags Used for choosing which variable to operate on Read more…","tags":"","loc":"module/pf_mod_utils.html","title":"pf_mod_utils – LibPFASST"},{"text":"Module to restrict solutions between pfasst levels and create the FAS tau correction Uses pf_mod_dtype pf_mod_timer pf_mod_hooks pf_mod_utils Contents Subroutines restrict_time_space_fas restrict_ts restrict_ts_integral Subroutines public subroutine restrict_time_space_fas (pf, t0, dt, level_index, flags, mystep) Restrict (in time and space) fine level to coarse and set coarse level FAS correction. Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf real(kind=pfdp), intent(in) :: t0 time at beginning of step real(kind=pfdp), intent(in) :: dt time step integer, intent(in) :: level_index defines which level to restrict integer, intent(in), optional :: flags integer, intent(in), optional :: mystep public subroutine restrict_ts (f_lev_p, c_lev_p, f_encap_array, c_encap_array, f_time, flags) Restrict (in time and space) f_sol_array  to c_sol_array\n This version is for point values (either functions or solutions) Read more… Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: f_lev_p pointer to fine level class( pf_level_t ), intent(inout) :: c_lev_p pointer to coarse level class( pf_encap_t ), intent(inout) :: f_encap_array (:) array of fine level data to be restricted class( pf_encap_t ), intent(inout) :: c_encap_array (:) array of coarse level data to be computed real(kind=pfdp), intent(in) :: f_time (:) time at the fine nodes integer, intent(in), optional :: flags public subroutine restrict_ts_integral (f_lev_p, c_lev_p, f_encap_array, c_encap_array, f_time, flags) Restrict (in time and space) f_sol_array  to c_sol_array\n This version is for integrals Read more… Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: f_lev_p pointer to fine level class( pf_level_t ), intent(inout) :: c_lev_p pointer to coarse level class( pf_encap_t ), intent(inout) :: f_encap_array (:) array of fine level data to be restricted class( pf_encap_t ), intent(inout) :: c_encap_array (:) array of coarse level data to be computed real(kind=pfdp), intent(in) :: f_time (:) time at the fine nodes integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_restrict.html","title":"pf_mod_restrict – LibPFASST"},{"text":"Module of parallel PFASST routines for optimal control problems. Uses pf_mod_pfasst pf_mod_interpolate pf_mod_restrict pf_mod_utils pf_mod_timer pf_mod_dtype pf_mod_hooks pf_mod_comm Contents Subroutines pf_predictor_oc pf_check_residual_oc pf_check_convergence_oc pf_pfasst_block_oc pf_v_cycle_oc Subroutines public subroutine pf_predictor_oc (pf, t0, dt, flags) Step 1. Getting the  initial condition on the finest level at each processor\n         If we are doing multiple levels, then we need to coarsen to fine level\n  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction\n If RK_pred is true, just do some RK_steps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags public subroutine pf_check_residual_oc (pf, level_index, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index logical, intent(out) :: residual_converged Return true if residual is below tolerances public subroutine pf_check_convergence_oc (pf, level_index, send_tag, flags) Test residuals to determine if the current processor has converged,\n adapted to optimal control. Can probably be removed, when pf_pfasst_block_oc\n is changed to use pf_check_convergence of pf_check_convergence_old. Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index integer, intent(in) :: send_tag integer, intent(in), optional :: flags public subroutine pf_pfasst_block_oc (pf, dt, nsteps, predict, flags, step) Routine to do the pfasst iterations for optimal control problems on one block of processors until completion.\n  Each processor will do either a fixed number of iterations, or iterate until a tolerance is met\n  On calling, it is assumed that the levels are already loaded with the initial guesses Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps logical, intent(in) :: predict integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine pf_v_cycle_oc (pf, iteration, t0, dt, level_index_c, level_index_f, flags) Post the nonblocking receives on the all the levels that will be recieving later\n    (for single level this will be skipped)\n move from fine to coarse doing sweeps\n Do the coarsest level\n Now move coarse to fine interpolating and sweeping Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_parallel_oc.html","title":"pf_mod_parallel_oc – LibPFASST"},{"text":"Old style Asynchronous MISDC sweeper Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f1eval_p pf_f2eval_p pf_f2comp_p pf_f3eval_p pf_f3comp_p Derived Types pf_amisdc_t Subroutines amisdc_sweep amisdc_evaluate amisdc_initialize amisdc_destroy amisdc_integrate amisdc_residual amisdc_evaluate_all Interfaces interface public subroutine pf_f1eval_p(this, y, t, level, f1) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f1 interface public subroutine pf_f2eval_p(this, y, t, level, f2) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 interface public subroutine pf_f2comp_p(this, y, t, dt, rhs, level, f2) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 interface public subroutine pf_f3eval_p(this, y, t, level, f3) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 interface public subroutine pf_f3comp_p(this, y, t, dt, rhs, level, f3) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_amisdc_t Asynchronous multi-implicit sweeper type (old style) Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure(pf_spreadq0_p), public :: spreadq0 procedure(pf_f1eval_p), public :: f1eval procedure(pf_f2eval_p), public :: f2eval procedure(pf_f2comp_p), public :: f2comp procedure(pf_f3eval_p), public :: f3eval procedure(pf_f3comp_p), public :: f3comp procedure, public :: sweep => amisdc_sweep procedure, public :: initialize => amisdc_initialize procedure, public :: evaluate => amisdc_evaluate procedure, public :: integrate => amisdc_integrate procedure, public :: residual => amisdc_residual procedure, public :: evaluate_all => amisdc_evaluate_all procedure, public :: destroy => amisdc_destroy procedure, public :: amisdc_destroy Subroutines public subroutine amisdc_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine amisdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m public subroutine amisdc_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine amisdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine amisdc_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) public subroutine amisdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt public subroutine amisdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:)","tags":"","loc":"module/pf_mod_amisdc.html","title":"pf_mod_amisdc – LibPFASST"},{"text":"Module for setting timers Uses pf_mod_dtype pf_mod_mpi Contents Variables TTOTAL TPREDICTOR TITERATION THOOKS TSTEP TRESIDUAL TBROADCAST TINTERPOLATE TRESTRICT TRECEIVE TSEND TLEVEL TAUX timer_names Subroutines start_timer end_timer Variables Type Visibility Attributes Name Initial integer, public, parameter :: TTOTAL = 1 integer, public, parameter :: TPREDICTOR = 2 integer, public, parameter :: TITERATION = 3 integer, public, parameter :: THOOKS = 4 integer, public, parameter :: TSTEP = 5 integer, public, parameter :: TRESIDUAL = 6 integer, public, parameter :: TBROADCAST = 7 integer, public, parameter :: TINTERPOLATE = 10 integer, public, parameter :: TRESTRICT = 20 integer, public, parameter :: TRECEIVE = 30 integer, public, parameter :: TSEND = 40 integer, public, parameter :: TLEVEL = 50 integer, public, parameter :: TAUX = 60 character(len=14), public, parameter :: timer_names (62) = (/'total       ', 'predictor   ', 'iteration   ', 'hooks       ', 'step        ', 'residual    ', 'broadcast   ', '8           ', '9           ', 'interpL1    ', 'interpL2    ', 'interpL3    ', 'interpL4    ', 'interpL5    ', 'interpL6    ', 'interpL7    ', 'interpL8    ', 'interpL9    ', 'interpL10   ', 'restrictL1  ', 'restrictL2  ', 'restrictL3  ', 'restrictL4  ', 'restrictL5  ', 'restrictL6  ', 'restrictL7  ', 'restrictL8  ', 'restrictL9  ', 'restrictL10 ', 'recvL1      ', 'recvL2      ', 'recvL3      ', 'recvL4      ', 'recvL5      ', 'recvL6      ', 'recvL7      ', 'recvL8      ', 'recvL9      ', 'recvL10     ', 'sendL1      ', 'sendL2      ', 'sendL3      ', 'sendL4      ', 'sendL5      ', 'sendL6      ', 'sendL7      ', 'sendL8      ', 'sendL9      ', 'sendL10     ', 'sweepL1     ', 'sweepL2     ', 'sweepL3     ', 'sweepL4     ', 'sweepL5     ', 'sweepL6     ', 'sweepL7     ', 'sweepL8     ', 'sweepL9     ', 'sweepL10    ', 'exp         ', 'omega       ', 'feval       '/) Subroutines public subroutine start_timer (pf, timer) Subroutine to start a timer Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: timer public subroutine end_timer (pf, timer) Subroutine to stop a timer Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: timer","tags":"","loc":"module/pf_mod_timer.html","title":"pf_mod_timer – LibPFASST"},{"text":"Module containing a collection of \"use\" statements to simplify\n  including the common main modules in writing applications that use libpfasst Uses pf_mod_dtype pf_mod_hooks pf_mod_results pf_mod_parallel pf_mod_pfasst pf_mod_utils pf_mod_comm_mpi Contents None","tags":"","loc":"module/pfasst.html","title":"pfasst – LibPFASST"},{"text":"Module for the storing results for eventual output Uses pf_mod_dtype pf_mod_utils Contents Subroutines initialize_results dump_resids dump_errors dump_timings destroy_results Subroutines public subroutine initialize_results (this, nsteps_in, niters_in, nprocs_in, nsweeps_in, rank_in, level_index, datpath, save_residuals) Arguments Type Intent Optional Attributes Name class( pf_results_t ), intent(inout) :: this integer, intent(in) :: nsteps_in integer, intent(in) :: niters_in integer, intent(in) :: nprocs_in integer, intent(in) :: nsweeps_in integer, intent(in) :: rank_in integer, intent(in) :: level_index character(len=*), intent(in) :: datpath logical, intent(in) :: save_residuals public subroutine dump_resids (this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this public subroutine dump_errors (this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this public subroutine dump_timings (pf) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf public subroutine destroy_results (this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this","tags":"","loc":"module/pf_mod_results.html","title":"pf_mod_results – LibPFASST"},{"text":"N-dimensional array encapsulation. When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'shape' attribute to create a new array with that\n shape.  Thus, the 'shape' attributes of the PFASST levels should be\n set appropriately.  For example, before calling pf_pfasst_run we can\n set the shape of the coarsest level by doing: allocate(pf%levels(1)%shape(2))\n   pf%levels(1)%shape = [ 3, 10 ] The helper routines array1, array2, array3, etc can be used to\n extract pointers to the encapsulated array without\n performing any copies. Uses iso_c_binding pf_mod_dtype pf_mod_utils Contents Interfaces ndarray_dump_numpy Derived Types ndarray_factory ndarray Functions cast_as_ndarray ndarray_norm get_array1d get_array2d get_array3d Subroutines ndarray_build ndarray_create_single ndarray_create_array ndarray_destroy ndarray_destroy_single ndarray_destroy_array ndarray_setval ndarray_copy ndarray_pack ndarray_unpack ndarray_axpy ndarray_eprint Interfaces interface Interfaces to output routines in pf_numpy.c public subroutine ndarray_dump_numpy(dname, fname, endian, dim, mpibuflen, shape, array) bind(c) Subroutine to write an the array to a file Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Derived Types type, public, extends( pf_factory_t ) :: ndarray_factory Type to create and destroy N-dimenstional arrays Type-Bound Procedures procedure, public :: create_single => ndarray_create_single procedure, public :: create_array => ndarray_create_array procedure, public :: destroy_single => ndarray_destroy_single procedure, public :: destroy_array => ndarray_destroy_array type, public, extends( pf_encap_t ) :: ndarray N-dimensional array type,  extends the abstract encap type Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) real(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => ndarray_setval procedure, public :: copy => ndarray_copy procedure, public :: norm => ndarray_norm procedure, public :: pack => ndarray_pack procedure, public :: unpack => ndarray_unpack procedure, public :: axpy => ndarray_axpy procedure, public :: eprint => ndarray_eprint Functions public function cast_as_ndarray (encap_polymorph) result(ndarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndarray ),\n  pointer public function ndarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function get_array1d (x, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:) public function get_array2d (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:) public function get_array3d (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine ndarray_build (q, shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) public subroutine ndarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_destroy (encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine ndarray_destroy_single (this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x public subroutine ndarray_destroy_array (this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) public subroutine ndarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine ndarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine ndarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine ndarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine ndarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine ndarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_ndarray.html","title":"pf_mod_ndarray – LibPFASST"},{"text":"Module of the  the derived sweeper class for doing MISDC sweeps for an equation of the form y' = f_1(y) + f_2(y) + f_3(y) The f_1 piece is treated explicitly and f_2 and f_3 implicitly\n  Afer this sweeper is initialized (usually in main), the locgical flags can be changed if desired Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_misdcQ_oc_t Subroutines misdcQ_oc_sweep misdcQ_oc_initialize misdcQ_oc_destroy misdcQ_oc_integrate misdcQ_oc_evaluate misdcQ_oc_evaluate_all misdcQ_oc_residual misdcQ_oc_spreadq0 Interfaces interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two\n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward integer, intent(in), optional :: idx index of quadrature node integer, intent(in), optional :: step time step for sequential version interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_misdcQ_oc_t Multi-implicit SDC sweeper type for optimal control, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) class( pf_encap_t ), public, allocatable :: I3 (:) class( pf_encap_t ), public, allocatable :: rhs Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: sweep => misdcQ_oc_sweep procedure, public :: initialize => misdcQ_oc_initialize procedure, public :: integrate => misdcQ_oc_integrate procedure, public :: residual => misdcQ_oc_residual procedure, public :: spreadq0 => misdcQ_oc_spreadq0 procedure, public :: evaluate_all => misdcQ_oc_evaluate_all procedure, public :: evaluate => misdcQ_oc_evaluate procedure, public :: destroy => misdcQ_oc_destroy procedure, public :: misdcQ_oc_destroy procedure, public :: misdcQ_oc_initialize Subroutines public subroutine misdcQ_oc_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags public subroutine misdcQ_oc_initialize (this, pf, level_index) Make space for rhs Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine misdcQ_oc_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine misdcQ_oc_integrate (this, pf, level_index, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine misdcQ_oc_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine misdcQ_oc_evaluate_all (this, pf, level_index, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine misdcQ_oc_residual (this, pf, level_index, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine misdcQ_oc_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"module/pf_mod_misdcq_oc.html","title":"pf_mod_misdcQ_oc – LibPFASST"},{"text":"Module of routines to run  PFASST Uses pf_mod_pfasst pf_mod_interpolate pf_mod_restrict pf_mod_utils pf_mod_timer pf_mod_dtype pf_mod_hooks pf_mod_comm pf_mod_results Contents Subroutines pf_pfasst_run pf_predictor pf_check_residual pf_check_convergence_block pf_block_run pf_v_cycle Subroutines public subroutine pf_pfasst_run (pf, q0, dt, tend, nsteps, qend, flags) This is the main interface to pfasst.\n  It examines the parameters and decides which subroutine to call\n  to execute the code correctly\n  Set the number of time steps to do\n  The user can either pass in the number of time steps or\n  pass in the time step size and length of run\n  Allocate stuff for holding results Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf The complete PFASST structure class( pf_encap_t ), intent(inout) :: q0 The initial condition real(kind=pfdp), intent(in) :: dt The time step for each processor real(kind=pfdp), intent(in) :: tend The final time of run integer, intent(in), optional :: nsteps The number of time steps class( pf_encap_t ), intent(inout), optional :: qend The computed solution at tend integer, intent(in), optional :: flags (:) User defnined flags public subroutine pf_predictor (pf, t0, dt, flags) PFASST Predictor.\n  Subroutine  to initialize the solution on each processor\n  The goal is to have a solution at each level and each node set to a consistent value\n  When this is called, the value of q0 at the fine level on each processor has been set somehow (see q0_style below) Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags public subroutine pf_check_residual (pf, level_index, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index logical, intent(out) :: residual_converged Return true if residual is below tolerances public subroutine pf_check_convergence_block (pf, level_index, send_tag) Subroutine to check if the current processor has converged and\n to update the next processor on the status\n Note that if the previous processor hasn't converged yet\n (pstatus), the current processor can't be converged yet either\n Check to see if tolerances are met Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index integer, intent(in) :: send_tag identifier for status send and receive public subroutine pf_block_run (pf, q0, dt, nsteps, qend, flags) PFASST controller for block mode\n  When starting a new block, broadcast new initial conditions to all procs\n  For initial block, this is done when initial conditions are set\n Reset some flags\n  Pack away your last solution\n  Everyone resets their q0\n  Just stick qend in q0\n  Update the step and t0 variables for new block\n Call the predictor to get an initial guess on all levels and all processors Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf class( pf_encap_t ), intent(in) :: q0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps class( pf_encap_t ), intent(inout), optional :: qend integer, intent(in), optional :: flags (:) public subroutine pf_v_cycle (pf, iteration, t0, dt, level_index_c, level_index_f, flags) Execute a V-cycle between levels nfine and ncoarse Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_parallel.html","title":"pf_mod_parallel – LibPFASST"},{"text":"Module of communication wrappers Uses pf_mod_pfasst Contents Subroutines pf_post pf_send_status pf_recv_status pf_send pf_recv pf_broadcast save Subroutines public subroutine pf_post (pf, level, tag, direction) Subroutine to post a receive request for a new initial condition to be received after doing some work Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(in) :: pf class(pf_level_t), intent(inout) :: level integer, intent(in) :: tag integer, intent(in), optional :: direction public subroutine pf_send_status (pf, tag, direction) Subroutine to send this processor's convergence status to the next processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in), optional :: direction public subroutine pf_recv_status (pf, tag, direction) Subroutine to receive the convergence status from the previous processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in), optional :: direction public subroutine pf_send (pf, level, tag, blocking, direction) Subroutine to send the solution to the next processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(in), optional :: direction public subroutine pf_recv (pf, level, tag, blocking, direction) Subroutine to recieve the solution from the previous processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf type(pf_level_t), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(in), optional :: direction public subroutine pf_broadcast (pf, y, nvar, root) Subroutine to broadcast the initial condition to all processors Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf real(kind=pfdp), intent(in) :: y (nvar) integer, intent(in) :: nvar integer, intent(in) :: root public subroutine save (pf, lev, flags) Save current solution and function value so that future corrections can be computed Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev Level to save on integer, intent(in), optional :: flags which component to save (state/adjoint)","tags":"","loc":"module/pf_mod_comm.html","title":"pf_mod_comm – LibPFASST"},{"text":"Module to do interpolation between pfasst levels Uses pf_mod_dtype pf_mod_timer pf_mod_hooks pf_mod_utils Contents Subroutines interpolate_time_space interpolate_q0 interpolate_qend Subroutines public subroutine interpolate_time_space (pf, t0, dt, level_index, F_INTERP, flags) Subroutine to interpolate (in time and space) level_index-1 to level_index\n Interpolation is done by interpolating increments. The fine function values are re-evaluated after interpolation.\n create workspaces\n set time at coarse and fine nodes\n  interpolate coarse level correction in space only\n interpolate corrections in time Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf main pfasst structure real(kind=pfdp), intent(in) :: t0 time at beginning of time interval real(kind=pfdp), intent(in) :: dt time step integer, intent(in) :: level_index defines which level to interpolate to logical, intent(in) :: F_INTERP Flag, if true, then do interp on f not sol integer, intent(in), optional :: flags public subroutine interpolate_q0 (pf, f_lev_p, c_lev_p, flags) Subroutine to update the fine initial condition from coarse increment by spatial interpolation Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: f_lev_p fine level class( pf_level_t ), intent(inout) :: c_lev_p coarse level integer, intent(in), optional :: flags public subroutine interpolate_qend (pf, f_lev_p, c_lev_p) Subroutine to update the fine terminal condition from coarse increment by spatial interpolation\n  used for adjoint solver Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: f_lev_p fine level class( pf_level_t ), intent(inout) :: c_lev_p coarse level","tags":"","loc":"module/pf_mod_interpolate.html","title":"pf_mod_interpolate – LibPFASST"},{"text":"Exponential integrator module This module extends pf_sweeper_t and is used for creating an exponential sweeper \n  that solves equations of the form y' = L y + N(t,y) When extending this class, you must supply the functions phib, swpPhib, and resPhib\n  that each compute matrix-vector products of the form \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i in addition to the function f_eval for compluting the nonlinear term N(t,y).\n  The complete description of these three functions is contained below. Uses pf_mod_dtype pf_mod_utils Contents Interfaces pf_phib pf_swpPhib pf_resPhib pf_f_eval_p Derived Types pf_exp_t Subroutines exp_initialize exp_sweep exp_integrate exp_residual exp_spreadq0 exp_evaluate exp_evaluate_all exp_destroy LocalDerivsAtNode weights Interfaces interface public subroutine pf_phib(this, t, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_swpPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_resPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_f_eval_p(this, y, t, level, n) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_exp_t Exponential SDC sweeper type, extends abstract pf_sweeper_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: w (:,:,:) real(kind=pfdp), public, allocatable :: nodes (:) real(kind=pfdp), public, allocatable :: eta (:) class( pf_encap_t ), public, allocatable :: b (:) class( pf_encap_t ), public, allocatable :: f_old (:) class( pf_encap_t ), public, allocatable :: newF logical, public :: use_phib = .true. Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_phib), public :: phib procedure(pf_swpPhib), public :: swpPhib procedure(pf_resPhib), public :: resPhib procedure, public :: initialize => exp_initialize procedure, public :: sweep => exp_sweep procedure, public :: evaluate => exp_evaluate procedure, public :: integrate => exp_integrate procedure, public :: residual => exp_residual procedure, public :: spreadq0 => exp_spreadq0 procedure, public :: evaluate_all => exp_evaluate_all procedure, public :: destroy => exp_destroy procedure, public :: exp_destroy procedure, public :: exp_initialize Subroutines public subroutine exp_initialize (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine exp_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine exp_integrate (this, pf, level_index, qSDC, fSDC, dt, fintsdc, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags public subroutine exp_residual (this, pf, level_index, dt, flags) Compute the integral of F from t_n to t_m at each node Read more… Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine exp_spreadq0 (this, pf, level_index, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_evaluate (this, pf, level_index, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_evaluate_all (this, pf, level_index, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_destroy (this, pf, level_index) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index public subroutine LocalDerivsAtNode (this, i, nnodes, N_eval, N_deriv) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: nnodes class( pf_encap_t ), intent(in) :: N_eval (:) class( pf_encap_t ), intent(inout) :: N_deriv (:) public subroutine weights (this, z, x, m, W) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z real(kind=pfdp), intent(inout) :: x (:) integer, intent(in) :: m real(kind=pfdp), intent(out) :: W (m+1,m+1)","tags":"","loc":"module/pf_mod_exp.html","title":"pf_mod_exp – LibPFASST"},{"text":"Module for the calling of user defined routines from various places in the pfasst algorithm Uses pf_mod_dtype Contents Variables PF_PRE_PREDICTOR PF_POST_PREDICTOR PF_PRE_ITERATION PF_POST_ITERATION PF_PRE_SWEEP PF_POST_SWEEP PF_PRE_STEP PF_POST_STEP PF_PRE_INTERP_ALL PF_POST_INTERP_ALL PF_PRE_INTERP_Q0 PF_POST_INTERP_Q0 PF_PRE_RESTRICT_ALL PF_POST_RESTRICT_ALL PF_PRE_CONVERGENCE PF_POST_CONVERGENCE PF_MAX_HOOK PF_HOOK_LOG_ONE PF_HOOK_LOG_ALL PF_HOOK_LOG_LAST hook_names Subroutines pf_add_hook call_hooks pf_logger_hook pf_logger_attach Variables Type Visibility Attributes Name Initial integer, public, parameter :: PF_PRE_PREDICTOR = 1 Define hook indices integer, public, parameter :: PF_POST_PREDICTOR = 2 Define hook indices integer, public, parameter :: PF_PRE_ITERATION = 3 Define hook indices integer, public, parameter :: PF_POST_ITERATION = 4 Define hook indices integer, public, parameter :: PF_PRE_SWEEP = 5 Define hook indices integer, public, parameter :: PF_POST_SWEEP = 6 Define hook indices integer, public, parameter :: PF_PRE_STEP = 7 Define hook indices integer, public, parameter :: PF_POST_STEP = 8 Define hook indices integer, public, parameter :: PF_PRE_INTERP_ALL = 9 Define hook indices integer, public, parameter :: PF_POST_INTERP_ALL = 10 Define hook indices integer, public, parameter :: PF_PRE_INTERP_Q0 = 11 Define hook indices integer, public, parameter :: PF_POST_INTERP_Q0 = 12 Define hook indices integer, public, parameter :: PF_PRE_RESTRICT_ALL = 13 Define hook indices integer, public, parameter :: PF_POST_RESTRICT_ALL = 14 Define hook indices integer, public, parameter :: PF_PRE_CONVERGENCE = 15 Define hook indices integer, public, parameter :: PF_POST_CONVERGENCE = 16 Define hook indices integer, public, parameter :: PF_MAX_HOOK = 16 Define hook indices integer, public, parameter :: PF_HOOK_LOG_ONE = 1 integer, public, parameter :: PF_HOOK_LOG_ALL = 7 integer, public, parameter :: PF_HOOK_LOG_LAST = PF_MAX_HOOK character(len=20), public, parameter :: hook_names (PF_HOOK_LOG_LAST) = (/'pre-predictor      ', 'post-predictor     ', 'pre-iteration      ', 'post-iteration     ', 'pre-sweep          ', 'post-sweep         ', 'pre-step           ', 'post-step          ', 'pre-interp-all     ', 'post-interp-all    ', 'pre-interp-q0      ', 'post-interp-q0     ', 'pre-restrict-all   ', 'post-restrict-all  ', 'pre-convergence    ', 'post-convergence   '/) Define hook names Subroutines public subroutine pf_add_hook (pf, level_ind, hook, proc) Subroutine to add a procedure to the hook on the given level Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: level_ind which pfasst level to add hook integer, intent(in) :: hook which hook to add procedure( pf_hook_p ) :: proc precudre to call from hook public subroutine call_hooks (pf, level_ind, hook) Subroutine to call hooks associated with the hook and level Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf main pfasst structure integer, intent(in) :: level_ind which pfasst level to call hook integer, intent(in) :: hook which hook to call public subroutine pf_logger_hook (pf, level_index) Subroutine defining log hook Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index public subroutine pf_logger_attach (pf) Subroutine to add log hook Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf","tags":"","loc":"module/pf_mod_hooks.html","title":"pf_mod_hooks – LibPFASST"},{"text":"Asynchronous multi-implicit sweeper Uses pf_mod_amisdc Contents Derived Types pf_amisdcQ_t Subroutines sweep_coupled_implicit_terms sweep_decoupled_implicit_terms amisdcQ_sweep amisdcQ_initialize amisdcQ_destroy amisdcQ_integrate Derived Types type, public, abstract, extends( pf_amisdc_t ) :: pf_amisdcQ_t Asynchronous multi-implicit sweeper type Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) logical, public :: use_LUq_ = .true. Type-Bound Procedures procedure(pf_spreadq0_p), public :: spreadq0 procedure(pf_f1eval_p), public :: f1eval procedure(pf_f2eval_p), public :: f2eval procedure(pf_f2comp_p), public :: f2comp procedure(pf_f3eval_p), public :: f3eval procedure(pf_f3comp_p), public :: f3comp procedure, public :: evaluate => amisdc_evaluate procedure, public :: residual => amisdc_residual procedure, public :: evaluate_all => amisdc_evaluate_all procedure, public :: amisdc_destroy procedure, public :: sweep => amisdcQ_sweep procedure, public :: initialize => amisdcQ_initialize procedure, public :: integrate => amisdcQ_integrate procedure, public :: destroy => amisdcQ_destroy procedure, public :: sweep_coupled_implicit_terms procedure, public :: sweep_decoupled_implicit_terms procedure, public :: amisdcQ_destroy procedure, public :: amisdcQ_initialize Subroutines public subroutine sweep_coupled_implicit_terms (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine sweep_decoupled_implicit_terms (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine amisdcQ_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine amisdcQ_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev public subroutine amisdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev public subroutine amisdcQ_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(in) :: lev class(pf_encap_t), intent(in) :: qSDC (:) class(pf_encap_t), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class(pf_encap_t), intent(inout) :: fintSDC (:)","tags":"","loc":"module/pf_mod_amisdcq.html","title":"pf_mod_amisdcQ – LibPFASST"},{"text":"Module to create quadrature matrices and accompanying routines Uses pf_mod_dtype pf_mod_utils Contents Variables qp dp eps Interfaces poly_eval Functions not_proper poly_eval poly_eval_complex Subroutines pf_init_sdcmats pf_destroy_sdcmats myLUq pf_quadrature pf_make_matrices sdc_qnodes sdc_qmats poly_diff poly_int poly_legendre poly_roots qsort Variables Type Visibility Attributes Name Initial integer, public, parameter :: qp = c_long_double integer, public, parameter :: dp = c_double real(kind=qp), public, parameter :: eps = 1.0e-23_qp Interfaces public interface poly_eval public interface poly_eval () Arguments None public function poly_eval_complex (p, n, x) result(v) Function to evaluate complex polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n complex(kind=pfqp), intent(in) :: x Return Value complex(kind=pfqp) Functions public function not_proper (flags, node) Function to decide if the restriction of the nodes is pointwise, e.g. coarse nodes are every other fine node Arguments Type Intent Optional Attributes Name integer, intent(in) :: flags (:) integer, intent(in) :: node Return Value logical public function poly_eval (p, n, x) result(v) Polynomial manipulation routines. Read more… Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n real(kind=pfqp), intent(in) :: x Return Value real(kind=pfqp) public function poly_eval_complex (p, n, x) result(v) Function to evaluate complex polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n complex(kind=pfqp), intent(in) :: x Return Value complex(kind=pfqp) Subroutines public subroutine pf_init_sdcmats (pf, SDCmats, nnodes, nflags) Initialize the sdcmats type with the correct nodes and quadrature matrices\n Decide what the base integration type is Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf PFASST structure type( pf_sdcmats_t ), intent(inout) :: SDCmats integer, intent(in) :: nnodes integer, intent(inout) :: nflags (nnodes) public subroutine pf_destroy_sdcmats (SDCmats) Destroy the sdcmats structure Arguments Type Intent Optional Attributes Name type( pf_sdcmats_t ), intent(inout) :: SDCmats public subroutine myLUq (Q, QLU, Nnodes, fillq) Routine to compute the LU decomposition of spectral integration matrix Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: Q (Nnodes-1,Nnodes) real(kind=pfdp), intent(inout) :: QLU (Nnodes-1,Nnodes) integer, intent(in) :: Nnodes integer, intent(in) :: fillq public subroutine pf_quadrature (qtype, nnodes, nnodes0, nodes, nflags, Smat, Qmat, proper, composite, no_left) Subroutine to create quadrature nodes and matrices Arguments Type Intent Optional Attributes Name integer, intent(in) :: qtype integer, intent(in) :: nnodes integer, intent(in) :: nnodes0 real(kind=pfdp), intent(out) :: nodes (nnodes) integer, intent(out) :: nflags (nnodes) real(kind=pfdp), intent(out) :: Smat (nnodes-1,nnodes) real(kind=pfdp), intent(out) :: Qmat (nnodes-1,nnodes) logical, intent(in) :: proper logical, intent(in) :: composite logical, intent(in) :: no_left public subroutine pf_make_matrices (SDCmats) Arguments Type Intent Optional Attributes Name type( pf_sdcmats_t ), intent(inout) :: SDCmats public subroutine sdc_qnodes (qnodes, flags, qtype, nnodes) Subroutine to compute high precision quadrature nodes. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: qnodes (nnodes) The computed quadrature nodes integer, intent(out) :: flags (nnodes) integer, intent(in), value :: qtype Type of nodes (see pf_dtype) integer, intent(in), value :: nnodes Number of nodes public subroutine sdc_qmats (Qmat, Smat, dst, src, flags, ndst, nsrc) Subroutine to compute the quadrature matrices Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(out) :: Qmat (ndst-1,nsrc) O to dst quadrature weights real(kind=pfdp), intent(out) :: Smat (ndst-1,nsrc) dst(m) to dst(m+1) quadrature weights real(kind=pfqp), intent(in) :: dst (ndst) Destination points real(kind=pfqp), intent(in) :: src (nsrc) Source points integer, intent(in) :: flags (nsrc) integer, intent(in), value :: ndst Number of destination points integer, intent(in), value :: nsrc Number of source points public subroutine poly_diff (p, n) Subroutine to differentiate polynomial (in place) Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: p (0:n) integer, intent(in), value :: n public subroutine poly_int (p, n) Subroutine to integrate polynomial (in place) Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: p (0:n) integer, intent(in), value :: n public subroutine poly_legendre (p, n) Subroutine to compute Legendre polynomial coefficients using Bonnet's recursion formula. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: p (0:n) integer, intent(in), value :: n public subroutine poly_roots (roots, p0, n) Subroutine to compute polynomial roots using the Durand-Kerner algorithm.\n The roots are assumed to be real. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: roots (n) real(kind=pfqp), intent(in) :: p0 (0:n) integer, intent(in), value :: n public recursive subroutine qsort (a) Subroutine to sort (inplace) using the quick sort algorithm.\n Adapted from http://www.fortran.com/qsort_c.f95. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: a (:)","tags":"","loc":"module/pf_mod_quadrature.html","title":"pf_mod_quadrature – LibPFASST"},{"text":"When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'shape' attribute to create a new array with that\n shape.  Thus, the 'shape' attributes of the PFASST levels should be\n set appropriately.  For example, before calling pf_pfasst_run we can\n set the shape of the coarsest level by doing: allocate(pf%levels(1)%shape(2))\n   pf%levels(1)%shape = [ 3, 10 ] The helper routines array1, array2, array3, etc can be used to\n extract pointers to the encapsulated array from a C pointer without\n performing any copies. Uses iso_c_binding pf_mod_dtype pf_mod_utils Contents Interfaces ndarray_dump_numpy Derived Types ndarray_oc_factory ndarray_oc Functions ndarray_oc_norm cast_as_ndarray_oc get_array1d_oc get_array2d_oc get_array3d_oc Subroutines ndarray_oc_build ndarray_oc_create_single ndarray_oc_create_array ndarray_oc_destroy ndarray_oc_destroy_single ndarray_oc_destroy_array ndarray_oc_setval ndarray_oc_copy ndarray_oc_pack ndarray_oc_unpack ndarray_oc_axpy ndarray_oc_dump_hook ndarray_oc_dump_all_hook ndarray_oc_eprint Interfaces interface public subroutine ndarray_dump_numpy(dname, fname, endian, dim, shape, nvars, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer(kind=c_int), intent(in), value :: dim integer(kind=c_int), intent(in) :: shape (dim) integer(kind=c_int), intent(in), value :: nvars real(kind=pfdp), intent(in) :: array (nvars) Derived Types type, public, extends( pf_factory_t ) :: ndarray_oc_factory Type to create and destroy N-dimenstional arrays for optimal control Type-Bound Procedures procedure, public :: create_single => ndarray_oc_create_single procedure, public :: create_array => ndarray_oc_create_array procedure, public :: destroy_single => ndarray_oc_destroy_single procedure, public :: destroy_array => ndarray_oc_destroy_array type, public, extends( pf_encap_t ) :: ndarray_oc N-dimensional array type for optimal control,  extends the abstract encap type Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) real(kind=pfdp), public, allocatable :: yflatarray (:) real(kind=pfdp), public, allocatable :: pflatarray (:) Type-Bound Procedures procedure, public :: setval => ndarray_oc_setval procedure, public :: copy => ndarray_oc_copy procedure, public :: norm => ndarray_oc_norm procedure, public :: pack => ndarray_oc_pack procedure, public :: unpack => ndarray_oc_unpack procedure, public :: axpy => ndarray_oc_axpy procedure, public :: eprint => ndarray_oc_eprint Functions public function ndarray_oc_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function cast_as_ndarray_oc (encap_polymorph) result(ndarray_oc_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndarray_oc ),\n  pointer public function get_array1d_oc (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:) public function get_array2d_oc (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:) public function get_array3d_oc (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine ndarray_oc_build (q, shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) public subroutine ndarray_oc_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_oc_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_oc_destroy (encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine ndarray_oc_destroy_single (this, x) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x public subroutine ndarray_oc_destroy_array (this, x) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) public subroutine ndarray_oc_setval (this, val, flags) Subroutine to set array to a scalar  value. Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine ndarray_oc_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine ndarray_oc_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine ndarray_oc_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine ndarray_oc_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine ndarray_oc_dump_hook (pf, level_index) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index public subroutine ndarray_oc_dump_all_hook (pf, level_index) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index public subroutine ndarray_oc_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_ndarray_oc.html","title":"pf_mod_ndarray_oc – LibPFASST"},{"text":"The main PFASST data type which includes pretty much everythingl Uses pf_mod_interpolate pf_mod_restrict pf_mod_utils pf_mod_timer pf_mod_dtype pf_mod_hooks pf_mod_pfasst pf_mod_comm Contents Subroutines pf_parareal_run pf_parareal_block_run pf_parareal_predictor pf_parareal_v_cycle pf_check_convergence_block pf_check_residual Subroutines public subroutine pf_parareal_run (pf, q0, dt, tend, nsteps, qend) Do the parareal algorithm\n  Set the number of time steps to do\n  The user can either pass in the number of time steps or\n  pass in the time step size and length of run\n  Allocate stuff for holding results Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf The complete PFASST structure class( pf_encap_t ), intent(in) :: q0 The initial condition real(kind=pfdp), intent(in) :: dt The time step for each processor real(kind=pfdp), intent(in) :: tend The final time of run integer, intent(in), optional :: nsteps The number of time steps class( pf_encap_t ), intent(inout), optional :: qend The computed solution at tend public subroutine pf_parareal_block_run (pf, q0, dt, nsteps, qend, flags) parareal controller for block mode\n  When starting a new block, broadcast new initial conditions to all procs\n  For initial block, this is done when initial conditions are set\n Reset some flags\n  Pack away your last solution\n  Everyone resets their q0\n  Just stick qend in q0\n  Update the step and t0 variables for new block\n Call the predictor to get an initial guess on all levels and all processors Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf class( pf_encap_t ), intent(in) :: q0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps class( pf_encap_t ), intent(inout), optional :: qend integer, intent(in), optional :: flags (:) public subroutine pf_parareal_predictor (pf, t0, dt, flags) The parareal predictor does a serial integration on the coarse level followed\n  by a fine integration if there is a fine level\n Step 1. Getting the initial condition on the coarsest level Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags public subroutine pf_parareal_v_cycle (pf, iteration, t0, dt, level_index_c, level_index_f, flags) Execute a V-cycle between levels nfine and ncoarse Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags public subroutine pf_check_convergence_block (pf, level_index, send_tag) Subroutine to check if the current processor has converged and\n to update the next processor on the status\n Note that if the previous processor hasn't converged yet\n (pstatus), the current processor can't be converged yet either\n Check to see if tolerances are met Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index integer, intent(in) :: send_tag identifier for status send and receive public subroutine pf_check_residual (pf, level_index, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: level_index logical, intent(out) :: residual_converged Return true if residual is below tolerances","tags":"","loc":"module/pf_mod_parareal.html","title":"pf_mod_parareal – LibPFASST"}]}